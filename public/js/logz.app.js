/* origin: public/webapp/app/account-region.js */
window.LogzIO = window.LogzIO || {};

window.LogzIO.UIStateResolvers = window.LogzIO.UIStateResolvers || {};

window.LogzIO.UIStateResolvers.getAccountRegion = ['$rootScope', '$stateParams', 'AccountService', function($rootScope, $stateParams, AccountService) {
    return AccountService.searchAccounts(0, 1, $stateParams.accountId).then(function (accountData) {
        if (!accountData || !accountData.results || !accountData.results.length) return;

        $rootScope.accountRegion = accountData.results[0].regionName;
    });
}];
/* origin: public/webapp/app/app.js */
/* eslint-disable max-lines */
var webApp = angular.module('webApp', [
    'ngAnimate',
    'ngCookies',
    'ngSanitize',
    'ngRoute',
    'ngDialog',
    'ui.router',
    'ui.router.stateHelper',
    'ngMaterial',
    'LocalStorageModule',
    'nvd3ChartDirectives',
    'customFilters',
    'utils',
    'cfp.hotkeys',
    'ngWebSocket',
    'ngFileSaver',
    'dndLists',
    'ncy-angular-breadcrumb',
    'smDateTimeRangePicker',
    'ngProgress'
]);

webApp.config(function ($stateProvider, $urlRouterProvider, $locationProvider, $urlMatcherFactoryProvider) {
    // Don't mind of trailing slash
    $urlMatcherFactoryProvider.strictMode(false);
    // Remove default prefix on hashbang
    $locationProvider.hashPrefix('');

    $stateProvider
        .state('goto', {
            url: '/goto/:urlId?switchToAccountId',
            controller: gotoCtrl,
            data: { authenticate: true }
        })
        .state('outer', {
            abstract: true,
            url: '/o',
            template: '<div ui-view></div>',
            controller: function() { }
        }).state('login', {
            url: '/login?accountId&username&password&id&token&timestamp&email&error&{redirect:any}', // {redirect:any} tells angular ui router to avoid special treat to this query param (usually it encodes it and we want to avoid that)
            templateUrl: 'app/outer/login/login.html',
            controller: 'LoginCtrl',
            data: {
                onlyAnonymous: true
            },
            params: {
                messageTitle: null,
                messageBody: null
            }
        }).state('outer.login', {
            url: '/login?accountId&username&password&id&token&timestamp&email&error&{redirect:any}', // {kibanaRoute:any} tells angular ui router to avoid special treat to this query param (usually it encodes it and we want to avoid that)
            templateUrl: 'app/outer/login/login.html',
            controller: 'LoginCtrl',
            data: {
                onlyAnonymous: true
            },
            params: {
                messageTitle: null,
                messageBody: null
            }
        }).state('outer.register', {
            url: '/signup?socialSignup?username&password&fullName&company&phone&jwt&error',
            templateUrl: 'app/outer/register/register.html',
            controller: 'RegisterCtrl',
            data: {
                onlyAnonymous: true
            }
        }).state('register', {
            url: '/signup?socialSignup?username&password&fullName&company&phone&jwt&error',
            templateUrl: 'app/outer/register/register.html',
            controller: 'RegisterCtrl',
            data: {
                onlyAnonymous: true
            }
        }).state('forgotPassword', {
            url: '/forgot-password?email',
            templateUrl: 'app/outer/forgot-password/forgot-password.html',
            controller: 'ForgotPasswordCtrl',
            data: {
                onlyAnonymous: true
            }
        }).state('outer.forgotPassword', {
            url: '/forgot-password?email',
            templateUrl: 'app/outer/forgot-password/forgot-password.html',
            controller: 'ForgotPasswordCtrl',
            data: {
                onlyAnonymous: true
            }
        }).state('validateResetPassword', {
            url: '/forgot-password/validate/:token',
            templateUrl: 'app/outer/forgot-password/validate-reset-password.html',
            controller: 'ValidateResetPasswordController',
            resolve: { isNewUser: function() { return false; } },
            data: {
                onlyAnonymous: true
            }
        }).state('outer.validateResetPassword', {
            url: '/forgot-password/validate/:token',
            templateUrl: 'app/outer/forgot-password/validate-reset-password.html',
            controller: 'ValidateResetPasswordController',
            resolve: { isNewUser: function() { return false; } },
            data: {
                onlyAnonymous: true
            }
        }).state('newUserSetPassword', {
            url: '/new-user/validate/:token',
            templateUrl: 'app/outer/forgot-password/validate-reset-password.html',
            controller: 'ValidateResetPasswordController',
            resolve: { isNewUser: function() { return true; } },
            data: {
                onlyAnonymous: true
            }
        }).state('outer.newUserSetPassword', {
            url: '/new-user/validate/:token',
            templateUrl: 'app/outer/forgot-password/validate-reset-password.html',
            controller: 'ValidateResetPasswordController',
            resolve: { isNewUser: function() { return true; } },
            data: {
                onlyAnonymous: true
            }
        }).state('dashboard', {
            abstract: true,
            url: '/dashboard?switchToAccountId',
            templateUrl: 'app/dashboard/dashboard.html',
            controller: 'DashboardCtrl',
            resolve: {
                loadFeatureFlagData: function (FeatureFlagService) {
                    // Makes sure our cache will have updated feature-flag data
                    // and avoids header jumps due to server data retrieval.
                    // All our app pages are dashboard nested states - thanks to that
                    // this method is called only once and not every page render
                    FeatureFlagService.clearCacheAndLoadData();
                },
                loadUserPermissions: function (UserPermissionsService) {
                    // Makes sure our cache will have updated user permissions data
                    // and avoids header jumps due to server data retrieval.
                    // All our app pages are dashboard nested states - thanks to that
                    // this method is called only once and not every page render
                    UserPermissionsService.clearCacheAndLoadData();
                }
            }
        }).state('dashboard.settings', {
            url: '/settings',
            template: '<div ui-view></div>',
            redirectTo: 'dashboard.settings.general',
            data: { authenticate: true },
            ncyBreadcrumb: {
                label: 'Settings'
            }
        }).state('dashboard.settings.general', {
            url: '/general',
            templateUrl: 'app/dashboard/settings/general/general.html',
            controller: 'GeneralSettingsController',
            data: { authenticate: true },
            ncyBreadcrumb: {
                label: 'General'
            }
        }).state('dashboard.settings.general.audit-trail', {
            url: '/audit-trail',
            views: {
                // https://github.com/angular-ui/ui-router/wiki/Multiple-Named-Views
                // So we could display the audit-trail on the bigger view, rather then a small one on the settings page
                '@dashboard.settings': {
                    templateUrl: 'app/dashboard/settings/audit-trail/audit-trail.html',
                    controller: 'AuditTrailCtrl',
                }
            },

            data: { authenticate: true },
            ncyBreadcrumb: {
                label: 'Audit Trail'
            },
            resolve: {
                hasPermissions: function ($q, $state, AuditTrailService) {
                    return AuditTrailService.userHasPermissionsToViewAudit().then(function (res) {
                        return res ? $q.when() : $state.go('dashboard.kibana');
                    });
                }
            },
        }).state('dashboard.settings.manage-users', {
            url: '/manage-users',
            templateUrl: 'app/dashboard/settings/manage-users/manage-users.html',
            controller: 'ManageUsersSettingsController',
            data: { authenticate: true }
        }).state('dashboard.settings.manage-accounts', {
            url: '/manage-accounts',
            templateUrl: 'app/dashboard/settings/manage-accounts/manage-accounts.html',
            controller: 'ManageAccountsSettingsController',
            data: {authenticate: true}
        }).state('dashboard.settings.manage-accounts_', {
            url: '/manage-accounts_',
            templateUrl: 'app/dashboard/settings/manage-accounts_/manage-accounts.html',
            data: {authenticate: true},
            resolve: {
                featureEnabled: function (FeatureFlagService) {
                    return FeatureFlagService.redirectIfFeatureDisabled('timeless-index', 'dashboard.settings.manage-accounts');
                }
            },
        }).state('dashboard.settings.usage-and-billing', {
            url: '/usage-and-billing?contractId&maxVolume&retention&planTypeId',
            templateUrl: 'app/dashboard/settings/usage-and-billing/usage-and-billing.html',
            controller: 'UsageAndBillingSettingsController',
            data: { authenticate: true }
        }).state('dashboard.settings.shared-tokens', {
            url: '/shared-tokens',
            templateUrl: 'app/dashboard/settings/shared-tokens/shared-tokens.html',
            controller: 'SharedTokensSettingsController',
            data: { authenticate: true }
        }).state('dashboard.settings.s3-archiving', {
            url: '/s3-archiving',
            templateUrl: 'app/dashboard/settings/s3-archiving/s3-archiving.html',
            controller: 'S3ArchivingSettingsController',
            data: { authenticate: true }
        }).state('dashboard.settings.field-mapping', {
            url: '/field-mapping',
            templateUrl: 'app/dashboard/settings/field-mapping/field-mapping.html',
            controller: 'FieldMappingSettingsController',
            data: { authenticate: true }
        }).state('dashboard.settings.system-status', {
            url: '/system-status',
            templateUrl: 'app/dashboard/settings/system-status/system-status.html',
            data: { authenticate: true }
        }).state('purchase-validation', {
            url: '/purchase/validation?invoiceId&mainProductId&retention&maxVolume&planTypeId&authKey',
            templateUrl: 'app/purchase/validation.html',
            controller: 'PurchaseValidationController',
            data: { authenticate: true }
        }).state('dashboard.kibana', {
            url: '/kibana?{kibanaRoute:any}&shareToken&snapshot_object_id', // {kibanaRoute:any} tells angular ui router to avoid special treat to this query param (usually it encodes it and we want to avoid that)
            templateUrl: 'app/dashboard/kibana-container/kibana-container.html',
            controller: 'KibanaContainerCtrl',
            data: { authenticate: true },
            ncyBreadcrumb: {
                label: 'Kibana'
            }
        }).state('dashboard.dataSources', {
            url: '/data-sources/:doc',
            templateUrl: 'app/dashboard/data-sources/data-sources.html',
            controller: 'DataSourcesCtrl',
            reloadOnSearch: false
        }).state('dashboard.alerts', {
            abstract: true,
            url: '/alerts',
            template: '<div ui-view></div>',
            controller: function() { },
            data: { authenticate: true },
        }).state('dashboard.alerts.definitions', {
            url: '/definitions',
            templateUrl: 'app/dashboard/alerts/view-alerts.html',
            controller: 'ViewAlertsController',
            data: { authenticate: true },
            ncyBreadcrumb: {
                label: 'Alerts'
            }
        }).state('dashboard.alerts.continuous', {
            url: '/optimizer-definitions',
            templateUrl: 'app/dashboard/alerts/triggers/view-triggers.html',
            controller: 'ViewTriggersController',
            controllerAs: 'vm',
            data: { authenticate: true }
        }).state('dashboard.alerts.triggered', {
            url: '/triggered',
            templateUrl: 'app/dashboard/alerts/view-triggered-alerts.html',
            controller: 'ViewTriggeredAlertsController',
            data: { authenticate:true }
        }).state('dashboard.alerts.endpoints', {
            url: '/endpoints',
            templateUrl: 'app/dashboard/alerts/notification-endpoints.html',
            controller: 'NotificationEndpointsController',
            data: { authenticate:true }
        }).state('dashboard.alerts.wizard', {
            abstract: true,
            template: '<div ui-view></div>',
            controller: function() { },
            data: { authenticate: true }
        }).state('dashboard.alerts.triggers', {
            url: '/optimizer-wizard',
            templateUrl: 'app/dashboard/alerts/alert-wizard/trigger-wizard-page.html',
            controller: 'AlertWizardPageController',
            data: { authenticate: true },
            ncyBreadcrumb: {
                label: '{{!createTriggerMode ? "Create an alert/optimizer" : "Edit an alert/optimizer"}}',
                parent: function($scope) {
                    return $scope.createTriggerMode ? 'dashboard.alerts.definitions' : 'dashboard.kibana';
                }
            },
            resolve: {
                featureEnabled : function (FeatureFlagService) {
                    return FeatureFlagService.redirectIfFeatureDisabled('continuous-aggregation', 'dashboard.alerts.wizard.step1');
                }
            }
        }).state('dashboard.alerts.wizard.step1', {
            url: '/wizard',
            templateUrl: 'app/dashboard/alerts/alert-wizard/alert-without-ca-wizard/create-alert-wizard-step-1.html',
            controller: 'AlertWizardStep1Controller',
            data: { authenticate: true }
        }).state('dashboard.alerts.wizard.step2', {
            url: '/wizard',
            templateUrl: 'app/dashboard/alerts/alert-wizard/alert-without-ca-wizard/create-alert-wizard-step-2.html',
            controller: 'AlertWizardStep2Controller',
            data: { authenticate: true }
        }).state('dashboard.alerts.wizard.step3', {
            url: '/wizard',
            templateUrl: 'app/dashboard/alerts/alert-wizard/alert-without-ca-wizard/create-alert-wizard-step-3.html',
            controller: 'AlertWizardStep3Controller',
            data: { authenticate: true }
        }).state('dashboard.alerts.wizard.step4', {
            url: '/wizard',
            templateUrl: 'app/dashboard/alerts/alert-wizard/alert-without-ca-wizard/create-alert-wizard-step-4.html',
            controller: 'AlertWizardStep4Controller',
            data: { authenticate: true }
        }).state('dashboard.alerts.view', {
            url: '/view-alert-in-kibana?eventTimestamp&timeRangeInMinutes&alertDefinitionId',
            data: { authenticate: true },
            resolve: {
                viewTriggeredAlertEvents: function ($stateParams, AlertWizardService) {
                    AlertWizardService.viewTriggeredAlertEvents($stateParams.eventTimestamp, $stateParams.timeRangeInMinutes, $stateParams.alertDefinitionId);
                }
            }
        }).state('dashboard.insights', {
            url: '/insights?assignee',
            templateUrl: 'app/dashboard/incidents/incidents.html',
            controller: 'IncidentsController',
            resolve: {
                retentionDays: function (UpgradeService) {
                    return UpgradeService.getRetentionDays();
                },
                markersFeatureEnabled : function (FeatureFlagService) {
                    return FeatureFlagService.isFeatureEnabled('markers-ui');
                }
            },
            data: { authenticate: true }
        }).state('dashboard.dataParsing', {
            url: '/data-parsing',
            templateUrl: 'app/dashboard/data-parsing/data-parsing-view.html',
            controller: 'DataParsingController',
            controllerAs: 'vm',
            resolve: {
                featureEnabled : function (FeatureFlagService) {
                    return FeatureFlagService.redirectIfFeatureDisabled('data-parsing', 'dashboard.dataSources');
                }
            },
            data: { authenticate: true }
        }).state('dashboard.dataParsing.step1', {
            url: '/step1',
            templateUrl: 'app/dashboard/data-parsing/step1/data-parsing-step1.html',
            controller: 'DataParsingStep1Controller',
            controllerAs: 'vmStep1',
            data: { authenticate: true }
        }).state('dashboard.dataParsing.step2', {
            url: '/step2',
            templateUrl: 'app/dashboard/data-parsing/step2/data-parsing-step2.html',
            controller: 'DataParsingStep2Controller',
            controllerAs: 'vmStep2',
            data: { authenticate: true }
        }).state('dashboard.dataParsing.step3', {
            url: '/step3',
            templateUrl: 'app/dashboard/data-parsing/step3/data-parsing-step3.html',
            controller: 'DataParsingStep3Controller',
            controllerAs: 'vmStep3',
            data: { authenticate: true }
        }).state('dashboard.dataParsing.step4', {
            url: '/step4',
            templateUrl: 'app/dashboard/data-parsing/step4/data-parsing-step4.html',
            controller: 'DataParsingStep4Controller',
            controllerAs: 'vmStep4',
            data: { authenticate: true }
        }).state('dashboard.welcome-flow', {
            url: '/welcome-flow',
            templateUrl: 'app/dashboard/welcome/welcome-flow.html',
            controller: 'WelcomeFlowController',
            data: { authenticate: true },
            resolve: {
                welcomeFlow: function() { return true; }
            }
        }).state('dashboard.apps', {
            url: '/apps?q',
            templateUrl: 'app/labs/labs.html',
            controller: 'LabsController'
        }).state('apps', {
            url: '/apps?q',
            templateUrl: 'app/labs/labs.html',
            redirectTo: 'dashboard.apps'
        }).state('dashboard.livetail', {
            url: '/live-tail',
            templateUrl: 'app/livetail/livetail.html',
            controller: 'LivetailController',
            resolve: {
                featureEnabled : function (FeatureFlagService) {
                    return FeatureFlagService.redirectIfFeatureDisabled('live-tail');
                }
            },
            data: { authenticate: true }

        // STYLEGUIDE //
        }).state('styleguide', {
            abstract: true,
            url: '/styleguide',
            // Add this to all ui-views of abstract (check that it does not break anything first)
            template: '<div ui-view class="abstract-view-container"></div>',
            controller: function() { },
        }).state('styleguide.app', {
            url: '/app',
            templateUrl: 'app/styleguide/app/styleguide.html',
            controller: 'AppStyleguideController',
            data: { adminOnly: true }

        // ADMIN ENDPOINTS //
        }).state('dashboard.admin', {
            url: '/__admin__',
            templateUrl: 'app/dashboard/admin/admin.html',
            controller: 'AdminCtrl',
            data: { adminOnly: true },
            ncyBreadcrumb: {
                label: 'Admin Panel',
            }
        }).state('dashboard.accountpage', {
            url: '/__admin__/account-page/:accountId',
            templateUrl: 'app/dashboard/admin/account.html',
            controller: 'AdminAccountPageController',
            resolve: {
                accountRegion: window.LogzIO.UIStateResolvers.getAccountRegion
            },
            ncyBreadcrumb: {
                label: 'Account {{accountId}}',
                parent: 'dashboard.admin'
            },
            data: { adminOnly: true }
        }).state('dashboard.accountpage.audit-trail', {
            url: '/audit-trail',
            views: {
                '@dashboard': {
                    templateUrl: 'app/dashboard/settings/audit-trail/audit-trail.html',
                    controller: 'AuditTrailCtrl',
                }
            },
            ncyBreadcrumb: {
                label: 'Audit Trail'
            },
            resolve: {
                accountRegion: window.LogzIO.UIStateResolvers.getAccountRegion
            },
            data: { adminOnly: true }
        }).state('dashboard.editEsTemplate', {
            url: '/__admin__/edit-es-template/:accountId',
            templateUrl: 'app/dashboard/admin/edit-es-template.html',
            controller: 'EditEsTemplateController',
            resolve: {
                accountRegion: window.LogzIO.UIStateResolvers.getAccountRegion
            },
            data: { adminOnly: true }
        }).state('dashboard.editLogTypesConfigTemplate', {
            url: '/__admin__/edit-log-types-config-template/:accountId',
            templateUrl: 'app/dashboard/admin/edit-log-types-config-template.html',
            controller: 'EditLogTypesConfigTemplateController',
            resolve: {
                accountRegion: window.LogzIO.UIStateResolvers.getAccountRegion
            },
            data: { adminOnly: true }
        }).state('dashboard.editSawmillConfig', {
            url: '/__admin__/edit-sawmill-config-template/:accountId',
            templateUrl: 'app/dashboard/admin/sawmill/sawmill-account.html',
            controller: 'sawmillAccountController',
            params: { accountName: false },
            resolve: {
                accountRegion: window.LogzIO.UIStateResolvers.getAccountRegion
            },
            data: { adminOnly: true }
        }).state('dashboard.editFieldsManipulationRules', {
            url: '/__admin__/account-page/:accountId/rules',
            templateUrl: 'app/dashboard/admin/manipulation-rules/edit-account-field-manipulation-rules.html',
            controller: 'EditAccountFieldManipulationController',
            resolve: {
                accountRegion: window.LogzIO.UIStateResolvers.getAccountRegion
            },
            data: { adminOnly: true }
        });

    $urlRouterProvider.otherwise(function ($injector) {
        var AuthService = $injector.get('AuthService');

        return AuthService.isAuthenticated() ? '/dashboard/kibana' : '/login';
    });

}).config(function($sceDelegateProvider) {
    $sceDelegateProvider.resourceUrlWhitelist([
        // Allow same origin resource loads.
        'self',
        // Allow loading from our assets domain.  Notice the difference between * and **.
        'https://sandbox.bluesnap.com/**',
        'https://bluesnap.com/**',
        'https://www.bluesnap.com/**',
        // All logzio subdomains
        'http://*.staging.us-east-1.internal.logz.io/**',
        'https://*.logz.io/**',
        'https://*.internal.logz.io/**'
    ]);
});

// We support both new way and old way (we used to inject embed flag in kibanaRoute instead of embed=true/false in query string)
angular.module('webApp').constant('appEmbedded',
    window.location.href.indexOf('embed=true') > 0 ||
    window.location.href.substr(window.location.href.indexOf('kibanaRoute')).indexOf('%3Fembed') > 0);

angular.module('webApp')
    .run(function ($rootScope, $state, $http, $cookies, $window, $q, AuthService, logzioApi, Logger, appEmbedded, Backend,
                   $location, AnalyticsService, ImpersonationService, UserService, ConfirmService, KibanaFrameService, cacheService, dialogValues) {

        var switchUserDialogErrors = {
            'SAME_USER': {
                'code': 1,
                'message': 'User already at the appointed account'
            }
        };


        // UGLY HACK!! This is one of the ugliest hacks i ever did.
        //             This is so we can use our 'backend' service from inside kibana
        window.logzioApi = logzioApi;

        function logout() {
            cacheService.clearAllCache();

            try { window.Intercom('shutdown'); }
            catch (err) { }
        }

        // browsers format Error.stack differently; always include message
        function formatStack(err) {
            if (err.stack && !~err.stack.indexOf(err.message)) {
                return 'Error: ' + err.message + '\n' + err.stack;
            }
            return err.stack;
        }
        // Look for errors on Logz.io UI (not kibana iframe)
        window.onerror = function (err, url, line) {
            var formatErr =  new Error(err + ' (' + url + ':' + line + ')');
            try {
                Logger.log({ logType: 'error', logzError:formatStack(formatErr), message: 'Error on Logz.io Main App: ' + formatErr, category: 'ui-error' });
            }
            catch (e) {
                console.error(e);
            }
            //DANGER - different behaviour in browsers, some will propagate the error
            //Chrome - 'false' will display the error
            return false;
        };

        $http.defaults.headers.common['Content-Type'] = 'application/json';
        $http.defaults.headers.post['Content-Type'] = 'application/json';
        $http.defaults.headers.put['Content-Type'] = 'application/json';

        $rootScope.$on('$stateChangeStart', function (event, toState, toParams) {

            /**
             * REMARK: This should be the first condition so we won't accidentally do other operations when not allowed
             */
            if (_.get(toState, 'data.authenticate') && !AuthService.isAuthenticated() && !appEmbedded) {
                event.preventDefault();

                // User isnâ€™t authenticated
                logout();
                $state.go('login', { redirect: [ '/', encodeURIComponent($window.location.hash) ].join('') });

                return;
            }

            var switchToAccountIdParam = toParams['switchToAccountId'];

            // See if we are requested to switch account
            if (switchToAccountIdParam) {
                event.preventDefault();
                // Remove the switchToAccountId to avoid infinite loop
                toParams['switchToAccountId'] = null;

                // Switch account if you have the ability, but otherwise work as normal
                _attemptSwitchAccount(switchToAccountIdParam)
                    .then(function() {
                        return AuthService.switchAccount(switchToAccountIdParam);
                    })
                    .then(function() {
                        $state.go(toState, toParams, {reload: true});
                    })
                    .catch(function(error) {
                        if (!error) { return; }

                        if (error.code === switchUserDialogErrors.SAME_USER.code) {
                            $state.go(toState, toParams, { reload : true});
                        }
                    })
                    .finally(function() {
                        // Prevent multiple dialogs at the same time.
                        dialogValues.switchUserDialog = false;
                    });

                return;
            }

            if ((_.get(toState, 'data.onlyAnonymous') && AuthService.isAuthenticated()) ||
                (_.get(toState, 'data.adminOnly') && (ImpersonationService.isImpersonating() || !AuthService.isAdmin()))) {

                event.preventDefault();
                $state.go('dashboard.kibana');

                return;
            }

            if (toState.redirectTo) {
                event.preventDefault();
                $state.go(toState.redirectTo, toParams, { location: 'replace' });

                // When adding another condition, add a return statement
            }

        });

        var initializedKibana = false; // Indicates if we initialized Kibana for the first time
        $rootScope.$on('$stateChangeSuccess', function (event, toState, params) {
            // update IntercomIO
            try {
                window.Intercom('update');
            }
            catch (err) { }
            try {
                if (toState.url.indexOf('?') < 0)
                    Munchkin.munchkinFunction('visitWebPage', { url: toState.url });
                else
                    Munchkin.munchkinFunction('visitWebPage', {
                        url: toState.url.substr(0, toState.url.indexOf('?')),
                        params: window.location.href.substr(window.location.href.indexOf('?')+1)
                    });
            }
            catch(err) { }

            // sends a pageview log to logz.io, with full url, name, title and an action
            AnalyticsService.report('pageview', {
                page: toState.name,
                url: window.location.href,
                title: toState.name,
                params: params,
                category: 'pageview'
            });


            // kibana iframe hack
            $rootScope.isKibanaVisible = toState.name === 'dashboard.kibana';
            if ($rootScope.isKibanaVisible && (!initializedKibana || params.kibanaRoute)) {
                // Build Kibana URL only if it's the first Kibana page load or we were referred with a new kibana route
                initializedKibana = true;
                KibanaFrameService.waitForAccountInitialLoad().then(function () {
                    KibanaFrameService.navigate(params.kibanaRoute);
                });
            }
        });

        /**
         * If `switchToAccountId` is present in the url's query params, try to switch to that account
         * @param param - The switchToAccountId query parameter
         * @private
         */
        function _attemptSwitchAccount(param) {
            var deferred = $q.defer();

            // Don't show if already present
            if (dialogValues.switchUserDialog) {
                return $q.reject();
            }

            UserService.getSummary()
                .then(function(accountData) {
                    // Ask the user if he wants to switch users (If he's not already on that account)
                    if (accountData.data.accountId !== +param) {

                        // Mark that the dialog is present
                        dialogValues.switchUserDialog = true;

                        ConfirmService.open({
                            template: 'directives/confirm-dialog/confirm-dialog.html',
                            confirmButtonText: 'Proceed',
                            width: '624px',
                            action: 'To view the link you selected, you will be redirected ' +
                            'to the relevant account and your current session may expire',
                            confirm: function() {
                                deferred.resolve();
                                this.closeThisDialog();
                            },
                            cancel: function() {
                                deferred.reject();
                                this.closeThisDialog();
                            }
                        });
                    }
                    else {
                        var errorObj = switchUserDialogErrors.SAME_USER;

                        deferred.reject(errorObj);
                    }
                });

            return deferred.promise;

        }

        (function() {
            if (location.pathname === '/context.html')
                return;
            var css = 'font-family: Roboto+Mono:300,400,500,700; font-size: 32px; color: #008ab1; font-weight: bold; padding: 10px 20px; background-color: #333; border-radius: 5px; border: 10px solid #333; border-left-width: 20px; border-right-width: 20px;';
            if(window.ENVIRONMENT === 'PROD' && !/logz-adminToken/.test(document.cookie)){
                console.clear();
                console.log('%clogz.io', css);
                console.log('');
                if(!window.console) window.console = {};
                var methods = ['log', 'debug', 'warn', 'info', 'error', 'group', 'groupEnd', 'groupCollapsed'];
                for(var i=0;i<methods.length;i++){
                    console[methods[i]] = function(){};
                }
            }
        })();

    });

angular.module('webApp')
    .constant('isHeroku', !!window.localStorage.getItem('ls._heroku_'))
    .constant('currentEnv', function() {
        var envOptions = ['STAGING', 'PROD'];
        if (envOptions.indexOf(window.ENVIRONMENT.toUpperCase()) !== -1)
            return window.ENVIRONMENT;
        return 'LOCAL';
    });

angular.module('webApp').config(['$httpProvider', function ($httpProvider) {
    $httpProvider.interceptors.push(['$timeout', '$q', '$injector', function ($timeout, $q, $injector) {
        return {
            responseError: function (error) {
                switch(error.status) {
                case 401: // UNAUTHORIZED
                    if (error.config && error.config.url !== '/auth' && !error.config.headers['X-USER-TOKEN'])
                        handleSessionExpired($injector, error.data);
                    break;

                case 400: // BAD_REQUEST
                    if (error.headers()['location'] && error.headers()['token'])
                        handleRedirect($injector, error);
                    break;
                }

                return $q.reject(error);
            }
        };
    }]);
}]);

var handleSessionExpired = function ($injector, errorMsg) {
    $injector.invoke(function ($state, AuthService, cacheService, $window) {

        AuthService.clearAuthToken();
        AuthService.clearAdminToken();
        cacheService.clearAllCache();

        var sessionExpiredCodeToData = {
            'default': {
                header: 'Invalid Session',
                content: 'Your session is either invalid or expired. Please log into Logz.io again.'
            },
            'replace-account-with-different-auth-settings': {
                header: 'Different session settings',
                content: 'Sorry... You\'ll need to log in again. The account you want to switch to has different security settings from the account you are currently logged into, so a new login is required.'
            }
        };

        var message = !errorMsg || !sessionExpiredCodeToData[errorMsg]
            ? sessionExpiredCodeToData['default']
            : sessionExpiredCodeToData[errorMsg];

        // TODO: Wrap this in a function
        $state.go('login', {
            messageTitle: message.header,
            messageBody: message.content,
            redirect: [ '/', encodeURIComponent($window.location.hash) ].join('')
        });
    });
};

var handleRedirect = function ($injector, error) {
    var location = error.headers()['location'];
    var token = error.headers()['token'];

    var requestUrl = _.get(error, 'config.url');
    var switchAccount = requestUrl && requestUrl.indexOf('/user/session/replace/') === 0;

    $injector.invoke(function ($stateParams, AuthService, ImpersonationService, cacheService) {
        if (token) {
            // Custom hack we need to support our sys admin users, when their switching an account to a different region account
            // this makes sure that AuthService.switchAccount() handling will be applied to them as well, otherwise they will have an invalid
            // adminToken that is different than userToken, and they will get error 401.
            if (switchAccount && !ImpersonationService.isImpersonating() && AuthService.isAdmin()) {
                cacheService.clearAllCache();
                AuthService.setAdminToken(token);
            }

            AuthService.setAuthToken(token);
        }

        if (location.indexOf('https://') !== 0 && location.indexOf('http://') !== 0) {
            location = [ 'http://', location ].join('');
        }

        var redirect = $stateParams.redirect || [ '/', window.location.hash ].join('');
        window.location = [ location, decodeURIComponent(redirect) ].join('');
    });
};


/**
 * Handle the #/goto call (try to get the parsed short URL from the server)
 */
var gotoCtrl = function(Backend, $state, $location) {
    var url = [ '/goto/', $state.params['urlId'] ].join('');
    Backend.GET(url, { returnUrl: true }).then(function(response) {
        $location.url(response.data);
    });
};

/* eslint-enable max-lines */

/* origin: public/webapp/app/configs/breadcrumbs-config.js */
angular.module('webApp').config(function ($breadcrumbProvider) {
    $breadcrumbProvider.setOptions({
        templateUrl: 'directives/app-breadcrumbs/app-breadcrumbs.html'
    });
});
/* origin: public/webapp/app/configs/highcharts-config.js */
angular.module('webApp').run(function () {
    Highcharts.setOptions({
        chart: {
            style: {
                fontFamily: 'Roboto, "Helvetica Neue", sans-serif'
            }
        },
        lang: {
            thousandsSep: ','
        },
        global: {
            useUTC: false //use browsers timezone
        }
    });
});
/* origin: public/webapp/app/configs/q-config.js */
angular.module('webApp').config(function ($qProvider) {

    //When not in prod and not in karma - TODO make this work with karma as well
    var displayErrors = window.ENVIRONMENT !== 'PROD' && window.ENVIRONMENT !== undefined;
    $qProvider.errorOnUnhandledRejections(displayErrors);
});
/* origin: public/webapp/app/configs/toaster-config.js */
angular.module('webApp').config(function ($mdToastProvider) {
    $mdToastProvider.addPreset('formToast', {
        methods: ['textContent', 'content', 'action', 'highlightAction', 'highlightClass', 'theme', 'parent', 'mode'],
        options: function () {
            return {
                templateUrl: 'directives/form-toast/form-toast.html',
                controller: 'formToastCtrl',
                controllerAs: 'toast',
                bindToController: true
            };
        }
    });
});
/* origin: public/webapp/app/dashboard/admin/account.js */
angular.module('webApp').controller('AdminAccountPageController', function($scope, $filter, $state, $stateParams, $window, ngDialog, AccountService, UserService, Backend, ImpersonationService, cacheService, UserPermissionsService) {

    cacheService.get('plan-type-defaults', function() {
        return Backend.GET('/plan-defaults').then(function(res) {
            return res.data;
        });
    }).then(function(planDefaults) {
        $scope.planDefaults = planDefaults;
    });

    var lastSawmillConfig;
    AccountService.getAccount($stateParams.accountId).then(function(account) {
        $scope.type_sub_account = 'SUB_ACCOUNT';
        $scope.type_owner_account = 'OWNER_ACCOUNT';
        $scope.account = account.account;
        $scope.accountName = account.account.accountName;
        $scope.suspensionMode = account.account.accountSettings.logsSuspensionMode;
        $scope.clusterId = account.account.accountSettings.primaryEsConfigId;
        $scope.regionName = account.account.regionName;

        $scope.sawmillEnabled = lastSawmillConfig = account.account.accountSettings.sawmillEnabled || false;

        $scope.accountType = account.accountType;
        $scope.accountRelations = account.accountRelations;
    });

    $scope.updateSawmillConfig = function () {
        if ($scope.loadingSawmill) return;
        $scope.loadingSawmill = true;
        var url = '__admin__/account/' + $stateParams.accountId + '/enable-sawmill';
        var options = {
            id: $stateParams.accountId,
            enabled: $scope.sawmillEnabled
        };
        Backend.POST(url, options).then(function () {
            $scope.loadingSawmill = false;
            lastSawmillConfig = $scope.sawmillEnabled;
        }).catch(function (error) {
            $scope.loadingSawmill = false;
            alert([ 'Error updating sawmill config!', JSON.stringify(error) ].join(' '));
        });
    };

    $scope.accountId = $stateParams.accountId;
    var initializeAccountData = function() {

        AccountService.getAccountUsers($scope.accountId).then(function(users) {
            $scope.accountUsers = users;
        });

        Backend.GET('/__admin__/account/' + $scope.accountId + '/plan').then(function(planDetails) {
            $scope.initialPlanDetails = _.clone(planDetails.data);
            $scope.planDetails = planDetails.data;
        });

        $scope.auth0Settings = { authSettings: {} };
        Backend.GET([ '/__admin__/account/', $scope.accountId, '/auth-settings' ].join('')).then(function (res) {
            var auth0Settings = res.data;

            $scope.auth0Settings.authSettings.mfa = !!auth0Settings.authSettings.multifactor;
            if (auth0Settings.authSettings.allowed_ip_prefixes)
                $scope.auth0Settings.authSettings.allowedIpPrefixes = auth0Settings.authSettings.allowed_ip_prefixes.join(', ');

            $scope.auth0Settings.connection = auth0Settings.connection;
        });
    };
    initializeAccountData();

    UserPermissionsService.hasPermission(UserPermissionsService.permissions.FORCE_IMPERSONATION).then(function (hasPermission) {
        $scope.forceImpersonationPermission = hasPermission;
    });

    Backend.GET([ '/__admin__/account/', $scope.accountId, '/support-access' ].join('')).then(function (res) {
        // services returns this in seconds count, in JS we work with milliseconds
        $scope.supportAccessEnd = (_.get(res, 'data.endApprovalDate') || 0) * 1000;
    });

    $scope.impersonateUser = function(username) {
        if (!$scope.supportAccessEnd && !$scope.forceImpersonationPermission) return;

        if (!$window.confirm('Are you sure you want to open the support console for ' + username + ' ?'))
            return;

        ImpersonationService.impersonate($scope.accountId, username);
    };

    $scope.blockUser = function(username, isActive) {
        if (!$window.confirm('Are you sure you want to block ' + username + ' ?'))
            return;

        UserService.updateUser(username, $scope.accountId, isActive);
    };

    $scope.updatePlan = function() {
        if ($scope.updatingPlan) return;
        $scope.updatingPlan = true;
        if (lastSawmillConfig !== $scope.sawmillEnabled) $scope.updateSawmillConfig();
        Backend.POST('/__admin__/account/' + $scope.accountId + '/plan', $scope.planDetails).then(function() {
            $scope.updatingPlan = false;
            $scope.$emit('plan-details-updated');

            $scope.initialPlanDetails = _.clone($scope.planDetails);

            alert('Successfully updated plan details');
        }).catch(function (res) {
            $scope.updatingPlan = false;
            alert([ 'Error updating plan details!', JSON.stringify(res.data) ].join(' '));
        });
    };
    $scope.applyPlanDefaults = function() {
        var planDefaults = _.find($scope.planDefaults, function(plan) { return plan.planType.toLowerCase() === $scope.planDetails.planType.toLowerCase(); });
        $scope.planDetails.maxDailyGB = planDefaults.maxDailyGB;
        $scope.planDetails.retentionDays = planDefaults.retentionDays;
        $scope.planDetails.warningDailyLimitPctThreshold = planDefaults.warningDailyLimitPctThreshold;
        $scope.planDetails.archivingSuspensionDailyLimitPctThreshold = planDefaults.archivingSuspensionDailyLimitPctThreshold;
        $scope.planDetails.indexingSuspensionDailyLimitPctThreshold = planDefaults.indexingSuspensionDailyLimitPctThreshold;
        $scope.planDetails.maxAlertsDefinition = planDefaults.maxAlertsDefinition;
        $scope.planDetails.maxUsersCount = planDefaults.maxUsersCount;
        $scope.planDetails.apiAccessEnabled = planDefaults.apiAccessEnabled;
        $scope.planDetails.queryApiEnabled = planDefaults.queryApiEnabled;
        $scope.planDetails.insightsFeatureEnabled = planDefaults.insightsFeatureEnabled;
        $scope.planDetails.maxSubAccounts = planDefaults.maxSubAccounts;
        $scope.planDetails.maxLiveTailSessions = planDefaults.maxLiveTailSessions;
        $scope.planDetails.maxLiveTailSessionsPerUser = planDefaults.maxLiveTailSessionsPerUser;
        $scope.planDetails.maxConcurrentQueriesApiUsers = planDefaults.maxConcurrentQueriesApiUsers;
        $scope.planDetails.maxConcurrentQueriesHumanUsers = planDefaults.maxConcurrentQueriesHumanUsers;
        $scope.planDetails.queryApiRetentionDays = planDefaults.queryApiRetentionDays;
        $scope.planDetails.maxTimelessIndices = planDefaults.maxTimelessIndices;
        $scope.planDetails.maxTimelessIndicesVolumeGb = planDefaults.maxTimelessIndicesVolumeGb;
    };

    $scope.updateAuthSettings = function() {
        if ($scope.updatingAuthSettings) return;
        $scope.updatingAuthSettings = true;

        var auth0Settings = { authSettings: {} };

        if ($scope.auth0Settings.connection) {
            auth0Settings.connection = $scope.auth0Settings.connection;
        }

        if ($scope.auth0Settings.authSettings.mfa) {
            auth0Settings.authSettings.multifactor = { 'provider': 'google-authenticator' };
        }

        if ($scope.auth0Settings.authSettings.allowedIpPrefixes && $scope.auth0Settings.authSettings.allowedIpPrefixes.length > 0) {
            var allowedIps = [];
            _.forEach($scope.auth0Settings.authSettings.allowedIpPrefixes.split(','), function(ip) {
                allowedIps.push(ip.trim());
            });
            auth0Settings.authSettings.allowed_ip_prefixes = allowedIps;
        }

        Backend.POST([ '/__admin__/account/', $scope.accountId, '/auth-settings' ].join(''), auth0Settings).then(function () {
            $scope.updatingAuthSettings = false;
            alert('Successfully updated auth0 settings');
        }).catch(function (res) {
            $scope.updatingAuthSettings = false;
            alert([ 'Error updating auth0 settings!', JSON.stringify(res.data) ].join(' '));
        });
    };

    $scope.editESConfig = function() {
        $state.go('dashboard.editEsTemplate', { accountId: $scope.accountId });
    };
    $scope.editLogTypesConfig = function() {
        $state.go('dashboard.editLogTypesConfigTemplate', { accountId: $scope.accountId });
    };
    $scope.editFieldsManipulationRules = function() {
        $state.go('dashboard.editFieldsManipulationRules', { accountId: $scope.accountId });
    };
    $scope.editAnalyzerSettings = function() {
        ngDialog.open({
            template: 'app/dashboard/admin/account/analyzer-settings.html',
            controller: 'AnalyzerSettingsController',
            width: '684px',
            showClose: false,
            scope: $scope.$new(),
            data: {
                accountId: $scope.accountId
            }
        });
    };

    $scope.deleteAccount = function() {
        ngDialog.open({
            template: 'app/dashboard/admin/delete-account-dialog.html',
            controller: 'DeleteAccountDialogController',
            width: '400px',
            scope: $scope,
            closeByEscape: true,
            showClose: false
        });
    };

    Backend.GET('/__admin__/es-clusters').then(function(clusters) {
        $scope.regionsToClusters = _.groupBy(clusters.data, 'regionName');
    });

    $scope.popupRegionChangeDialog = function() {
        ngDialog.open({
            template: 'app/dashboard/admin/change-account-region-dialog.html',
            controller: 'ChangeAccountRegionController',
            width: '550px',
            scope: $scope,
            closeByEscape: true,
            showClose: false
        });
    };

    $scope.toggleSuspendingAccount = function() {
        if (confirm('Are you sure you want to perform this action?')) {
            Backend.POST('/__admin__/account', {
                accountId: $scope.accountId,
                block: $scope.account.active
            }).finally(function() {
                $scope.account.active  = !$scope.account.active;
                cacheService.clear('accounts-list');
            });
        }
    };

    $scope.enableLogsUpload = function() {
        ngDialog.open({
            template: 'app/dashboard/admin/update-log-suspension-mode-dialog.html',
            controller: ['$scope', function(dialogScope) {
                dialogScope.suspend = function(suspensionMode) {
                    if (!window.confirm('Are you sure you want to update suspension mode to ' + suspensionMode + ' ?'))
                        return;

                    Backend.POST('/__admin__/account/' + $scope.accountId + '/update-logs-suspension-mode', {
                        logsSuspensionMode: suspensionMode
                    }).then(function() {
                        $scope.suspensionMode = suspensionMode;
                        dialogScope.closeThisDialog();
                    }).catch(function() {
                        alert('Error trying to change suspension mode');
                    });
                };
            }],
            width: '680px',
            closeByEscape: true,
            showClose: false
        });
    };

    $scope.goToAccountPage = function(accountId) {
        var url = $state.href('dashboard.accountpage', { accountId: accountId });
        $window.open(url, '_blank');
    };

    Backend.GET([ '/__admin__/account/', $scope.accountId, '/email-domains' ].join('')).then(function (res) {
        $scope.originalEmailDomains = res.data.join(',');
        $scope.inputEmailDomains = $scope.originalEmailDomains;
    });

    $scope.updateEmailDomains = function () {
        if ($scope.updatingEmailDomains) {
            return;
        }

        $scope.updatingEmailDomains = true;
        Backend.POST([ '/__admin__/account/', $scope.accountId, '/email-domains' ].join(''), { emailDomains: $scope.inputEmailDomains.split(',') }).then(function () {
            $scope.updatingEmailDomains = false;
            $scope.originalEmailDomains = $scope.inputEmailDomains;
        });
    };

    $scope.featureFlagUser = 'NONE';
    $scope.getFeatureFlagData = function () {
        $scope.loadingFeatureFlagData = true;

        var queryParams;
        if ($scope.featureFlagUser !== 'NONE') {
            queryParams = {
                userId: $scope.featureFlagUser
            };
        }

        Backend.GET([ '/__admin__/feature-flag/enabled-features/account/', $scope.accountId ].join(''), queryParams).then(function (res) {
            $scope.featureFlagData = res.data;
            $scope.loadingFeatureFlagData = false;
        });
    };

    var featureflagUserWatcher = $scope.$watch('featureFlagUser', $scope.getFeatureFlagData);
    $scope.$on('$destroy', function() {
        if (featureflagUserWatcher) featureflagUserWatcher();
    });
});

/* origin: public/webapp/app/dashboard/admin/account/analyzer-settings-controller.js */
angular.module('webApp').controller('AnalyzerSettingsController', function($scope, $window, Backend, logzioApi) {

    var loadAnalyzerSettings = function () {
        $scope.errorMessage = null;
        $scope.loading = true;

        return Backend.GET([ '/__admin__/account/', $scope.accountId, '/analyzer' ].join(''))
            .then(function(response){
                $scope.analyzerSettings = response.data;
            })
            .catch(function (error) {
                logzioApi.errorPopup('Oops',
                    ['Failed to fetch analyzer settings for account, error: ', error.data.message].join('\n'), true);
            })
            .finally(function () {
                $scope.loading = false;
            });
    };

    loadAnalyzerSettings();

    $scope.applyAnalyzerSettings = function() {
        if ($scope.loading || !$window.confirm('Are you sure you want to save your changes ?'))
            return;

        $scope.errorMessage = null;
        $scope.loading = true;
        Backend.PUT([ '/__admin__/account/', $scope.accountId, '/analyzer' ].join(''), $scope.analyzerSettings)
            .then(function (response) {
                $scope.loading = false;
                alert(response.data.message);
                $scope.closeThisDialog();
            })
            .catch(function(error) {
                $scope.loading = false;
                $scope.errorMessage = error.data.message;
            });
    };

    $scope.restoreDefaultAnalyzerSettings = function() {
        if ($scope.loading || !$window.confirm('Are you sure you want to restore default analyzer settings ?'))
            return;

        $scope.errorMessage = null;
        $scope.loading = true;
        Backend.DELETE([ '/__admin__/account/', $scope.accountId, '/analyzer' ].join(''))
            .then(function (response) {
                loadAnalyzerSettings().then(function () {
                    alert(response.data.message);
                    $scope.closeThisDialog();
                });
            })
            .catch(function(error) {
                $scope.loading = false;
                $scope.errorMessage = error.data.message;
            });
    };

});

/* origin: public/webapp/app/dashboard/admin/accounts.js */
angular.module('webApp').controller('AdminUsersController', function($rootScope, $scope, $state, AccountService, AuthService) {

    AuthService.getUser().then(function(currentUser) {
        $scope.currentUser = currentUser.data;
    });

    $scope.currentPage = 0;
    $scope.pageSize = 60;
    $scope.searchText = '';

    $scope.filterPlanType = 0;
    function getAccounts() {
        $scope.loadingData = true;

        $scope.searchResults = !!$scope.searchText;

        var from = $scope.currentPage * $scope.pageSize;

        var searchPromise = $scope.searchText ?
            AccountService.searchAccounts(from, $scope.pageSize, $scope.searchText, { planType: $scope.filterPlanType }) :
            AccountService.listAccounts(from, $scope.pageSize, { planType: $scope.filterPlanType });

        searchPromise.then(function(accounts) {

            $scope.accountsTotal = accounts.total;
            $scope.accountsPageSize = accounts.pageSize;
            $scope.accountsFrom = accounts.from;

            $scope.pages = new Array(Math.ceil($scope.accountsTotal / $scope.accountsPageSize));

            function calculateSizes(a) {
                var sizeInGB = (accounts.results[a].avgLastDaysBytes || 0) / 1024 / 1024 / 1024;
                accounts.results[a].avgLastDaysBytes = LogzIO.Strings.FriendlyNumber(sizeInGB.toFixed(4), 4);

                var volInGB = (accounts.results[a].vol2dateBytes || 0) / 1024 / 1024 / 1024;
                accounts.results[a].vol2dateBytes = LogzIO.Strings.FriendlyNumber(volInGB.toFixed(4), 4);
            }

            for (var i=0; i<accounts.results.length; i++) {
                calculateSizes(i);
            }

            accounts.results = _.uniq(accounts.results, function(a) { return a.id; });
            accounts.results.sort(function(a, b) {
                return parseFloat(b.avgLastDaysBytes) - parseFloat(a.avgLastDaysBytes);
            });
            _(accounts.results).forEach(function(account) {
                if (account.planExpirationDate)
                    account.planExpirationDate = LogzIO.Dates.unixToFriendly(account.planExpirationDate);
            });

            $scope.accounts = accounts;
            $scope.loadingData = false;
        });
    }

    $scope.search = function() {
        $scope.currentPage = 0;
        getAccounts();
    };
    $scope.cancelSearch = function() {
        $scope.currentPage = 0;
        $scope.searchText = '';
        getAccounts();
    };

    $scope.goToAccountPage = function(accountId) {
        $state.go('dashboard.accountpage', { accountId: accountId });
    };

    var filterWatcher = $scope.$watch('filterPlanType', getAccounts);

    $scope.$on('$destroy', function() {
        if (typeof filterWatcher === 'function')
            filterWatcher();
    });

});

/* origin: public/webapp/app/dashboard/admin/admin.js */
angular.module('webApp').controller('AdminCtrl', function($scope) {

    $scope.adminPages = [{
        title: 'Accounts',
        img: '',
        template: 'app/dashboard/admin/accounts.html',
        subTitle: 'Accounts & Users Management'
    }, {
        title: 'Insights',
        img: '',
        template: 'app/dashboard/admin/insights.html',
        subTitle: 'Insights'
    }, {
        title: 'Rates',
        img: '',
        template: 'app/dashboard/admin/rates.html',
        subTitle: 'Rates'
    }, {
        title: 'Notifications',
        img: '',
        template: 'app/dashboard/admin/global-notifications.html',
        subTitle: 'Global Notifications'
    }, {
        title: 'Sawmill',
        img: '',
        template: 'app/dashboard/admin/sawmill/sawmill.html',
        subTitle: 'Sawmill Configurations'
    }, {
        title: 'Migrator',
        img: '',
        template: 'app/dashboard/admin/migrator/account-migration.html',
        subTitle: 'Account Migration'
    }];

    $scope.chosenPage = 'Accounts';
    $scope.subTitle = 'Accounts & Users Management';

    $scope.pageTemplate = function(template) {
        for (var i=0; i<$scope.adminPages.length; i++) {
            if ($scope.adminPages[i].title === template) {
                return $scope.adminPages[i].template;
            }
        }
        return '';
    };
    $scope.displayPage = function(page) {
        $scope.chosenPage = page.title;
        $scope.subTitle = page.subTitle;
    };

});

/* origin: public/webapp/app/dashboard/admin/change-account-region-dialog-controller.js */
angular.module('webApp').controller('ChangeAccountRegionController', function($scope, Backend) {
    $scope.enabled = false;

    var watcher = $scope.$watch('accountToChangeItsRegion', function(entered) {
        $scope.enabled = entered === $scope.accountName.trim();
    });

    $scope.changeRegion = function() {
        if (!$scope.enabled) return;
        if ($scope.waitingForResponse) return;

        $scope.waitingForResponse = true;

        var request = { targetRegion: $scope.regionName };
        if ($scope.clusterId !== 'default') request.targetEsClusterId = $scope.clusterId;
        Backend.PUT([ '/__admin__/account/', $scope.accountId, '/change-region' ].join(''), request).then(function() {
            $scope.$parent.regionName = $scope.regionName;
            $scope.closeThisDialog();
        }).catch(function(err) {
            $scope.errorMessage = err.data;
            $scope.waitingForResponse = false;
        });
    };

    $scope.$on('$destroy', function() {
        if (typeof watcher === 'function') watcher();
    });
});
/* origin: public/webapp/app/dashboard/admin/create-insight-controller.js */
angular.module('webApp').controller('CreateInsightController', function($scope, Backend) {

    $scope.requesting = false;

    $scope.dialogTitle = 'Create Insight';

    if ($scope.editingInsightId) {
        $scope.insight = _.find($scope.insights, function(i) { return i.id === $scope.editingInsightId; });
        $scope.dialogTitle = 'Edit Insight';
    }

    $scope.createInsight = function() {
        if ($scope.createInsightsForm.$invalid) return;

        $scope.requesting = true;
        $scope.createResponse = undefined;

        var newInsight = {
            title: $scope.insight.title,
            description: $scope.insight.description,
            links: $scope.insight.links,
            tagName: $scope.insight.tagName,
            severity: $scope.insight.severity,
            state: $scope.insight.state,
            discussions: $scope.insight.discussions
        };

        var url = [ '/__admin__/insights/', $scope.editingInsightId === undefined ? 'create' : 'update' ].join('');
        if ($scope.editingInsightId !== undefined)
            newInsight.id = $scope.editingInsightId;

        Backend.POST(url, newInsight).then(function(response) {
            $scope.requesting = false;
            $scope.createResponse = response.data;
        }).catch(function(err) {
            $scope.requesting = false;
            $scope.createResponse = err;
        });
    };

});
/* origin: public/webapp/app/dashboard/admin/delete-account-dialog-controller.js */
angular.module('webApp').controller('DeleteAccountDialogController', function($scope, $state, $timeout, AccountService, Focus) {
    $scope.enabled = false;
    $timeout(function () {
        Focus('account-to-delete-focus');
    }, 0);

    var watcher = $scope.$watch('accountToDelete', function(entered) {
        $scope.enabled = entered === $scope.accountName.trim();
    });

    $scope.delete = function() {
        if (!$scope.enabled || $scope.deleteInProcess) return;

        $scope.deleteInProcess = true;

        AccountService.deleteAccount($scope.accountId).then(function() {
            AccountService.clearAccountListCache();
            $scope.closeThisDialog();
            $state.go('dashboard.admin');
        }, function (error) {
            $scope.deleteInProcess = false;
            alert([ 'Error deleting account!', JSON.stringify(error.data)].join(' '));
        });
    };

    $scope.$on('$destroy', function() {
        if (typeof watcher === 'function')
            watcher();
    });
});
/* origin: public/webapp/app/dashboard/admin/edit-es-template-controller.js */
angular.module('webApp').controller('EditEsTemplateController', function($scope, $stateParams, Backend) {

    $scope.saving = false;

    $scope.esTemplateFile = '';
    Backend.GET('/__admin__/account-settings/' + $stateParams.accountId)
        .then(function (res) {
            var accountSettings = res.data;
            if (!accountSettings.esTemplate.mappings)
                accountSettings.esTemplate.mappings = {};
            var spacingLevel = 2;
            $scope.esTemplateFile = JSON.stringify(accountSettings.esTemplate, null, spacingLevel);
        }).catch(function() {
            alert('error');
        });

    $scope.updateEsTemplate = function() {
        if ($scope.saving)
            return;

        $scope.saving = true;
        Backend.POST('/update-es-template', {
            accountId: $stateParams.accountId,
            setting: $scope.esTemplateFile
        }).then(function() {
            $scope.saving = false;
            alert('file saved successfully!');
        }).catch(function() {
            $scope.saving = false;
            alert('error');
        });
    };

});
/* origin: public/webapp/app/dashboard/admin/edit-log-types-config-template-controller.js */
angular.module('webApp').controller('EditLogTypesConfigTemplateController', function($scope, $stateParams, Backend, ngDialog) {
    var initialLoad = function() {
        $scope.loadingData = true;

        Backend.GET([ '/__admin__/account/', $stateParams.accountId, '/log-types' ].join(''))
            .then(function(res) {
                $scope.logTypesData = res.data;
            }).catch(function() {
                alert('error');
            }).finally(function() {
                $scope.loadingData = false;
            });
    };
    initialLoad();

    $scope.showEditDialog = function(logType, isFlat, reason, isNew) {
        ngDialog.open({
            template: 'app/dashboard/admin/edit-log-types-confirmation-dialog.html',
            scope: $scope,
            width: '700px',
            data: { logType: logType, isFlat: isFlat, reason: reason, isNew: isNew },
            showClose: false,
            closeByEscape: true
        });
    };

    $scope.upsertFlattenConfig = function(logType, isFlat, reason, isNew) {
        if(logType.trim() === '' || (isFlat && reason.trim() === '')) return;

        if (isNew && _.some($scope.logTypesData, function(logTypeData) { return logTypeData.logType === logType; })) {
            alert([ 'Log type \'', logType, '\' already exists!' ].join(''));
            return;
        }

        $scope.loadingData = true;
        ngDialog.closeAll();

        Backend.POST('/__admin__/account/flatten-logtype', { accountId: $stateParams.accountId, logType: logType, reason: reason, isFlat: isFlat })
            .then(function() {
                initialLoad();
            }).catch(function() {
                $scope.loadingData = false;
            });
    };
});
/* origin: public/webapp/app/dashboard/admin/global-notifications-controller.js */
angular.module('webApp').controller('AdminGlobalNotificationsController', function($scope, ngDialog, Backend) {

    var loadNotifications = function() {
        Backend.GET('/__admin__/all-global-notifications').then(function(res) {
            $scope.globalNotifications = res.data;

            var now = Date.now();
            $scope.inactiveNotifications = _.filter($scope.globalNotifications, function(notification) {
                if (!notification.active)
                    return true;

                if (!notification.fromDate && !notification.toDate)
                    return false;

                if (notification.fromDate && notification.toDate && now >= notification.fromDate && now <= notification.toDate)
                    return false;

                if (!notification.fromDate && now <= notification.toDate)
                    return false;

                if (!notification.toDate && now >= notification.fromDate)
                    return false;

                return true;
            });

            var inactiveNotificationIds = _.map($scope.inactiveNotifications, 'id');
            $scope.activeNotifications = _.filter($scope.globalNotifications, function(notification) {
                return inactiveNotificationIds.indexOf(notification.id) === -1;
            });
        });
    };
    loadNotifications();

    $scope.editNotification = function(notification) {

        var isNewNotification = !notification;

        // set some defaults
        if (isNewNotification) {
            notification = {
                active: true
            };
        }

        ngDialog.open({
            template: 'app/dashboard/admin/edit-global-notification-dialog.html',
            controller: ['$scope', '$rootScope', function(dialogScope, $rootScope) {

                if (dialogScope.ngDialogData.includeAccounts)
                    dialogScope.groupingType = 'byAccount';
                else if (dialogScope.ngDialogData.topics)
                    dialogScope.groupingType = 'byTopic';
                else if (dialogScope.ngDialogData.clustersIds)
                    dialogScope.groupingType = 'byCluster';

                dialogScope.$watch('groupingType', function(newValue) {
                    if (newValue === 'byAccount') {
                        dialogScope.ngDialogData.topics = '';
                        dialogScope.ngDialogData.clustersIds = '';
                    }
                    else if (newValue === 'byTopic') {
                        dialogScope.ngDialogData.includeAccounts = '';
                        dialogScope.ngDialogData.clustersIds = '';
                    }
                    else if (newValue === 'byCluster') {
                        dialogScope.ngDialogData.includeAccounts = '';
                        dialogScope.ngDialogData.topics = '';
                    }
                });

                dialogScope.savingNotification = false;
                dialogScope.saveNotification = function() {
                    if (dialogScope.ngDialogData.message === '')
                        return;

                    dialogScope.savingNotification = true;
                    Backend.POST('/__admin__/' + (isNewNotification ? 'create' : 'update') + '-global-notification', dialogScope.ngDialogData)
                        .then(function() {
                            dialogScope.savingNotification = false;
                            dialogScope.closeThisDialog();
                            loadNotifications();
                        }).catch(function() {
                            alert('There was an error saving the global notification.');
                            dialogScope.savingNotification = false;
                        });
                };

                dialogScope.previewNotification = function() {
                    $rootScope.$broadcast('global-notifications:preview', dialogScope.ngDialogData);
                };
            }],
            width: '700px',
            showClose: false,
            closeOnEsc: false,
            data: notification
        });
    };

    $scope.enableNotification = function(notification) {
        if (!window.confirm('Are you sure you want to enable this notification ?'))
            return;

        Backend.GET('/__admin__/global-notification/' + notification.id + '/enable').then(function() {
            loadNotifications();
        }).catch(function() {
            alert('error enabling notification');
        });
    };
    $scope.disableNotification = function(notification) {
        if (!window.confirm('Are you sure you want to disable this notification ?'))
            return;

        Backend.GET('/__admin__/global-notification/' + notification.id + '/disable').then(function() {
            loadNotifications();
        }).catch(function() {
            alert('error disabling notification');
        });
    };

});

/* origin: public/webapp/app/dashboard/admin/insights.js */
angular.module('webApp').controller('AdminInsightsController', function($scope, $timeout, ngDialog, Backend) {

    var INSIGHTS_SERVICE_PREFIX = '/__admin__/insights';

    $scope.pageSize = 20;
    $scope.page = 0;
    $scope.showingSearchResults = false;
    $scope.onlyPending = false;

    var addReadMoreLinkIfNeeded = function() {
        $timeout(function() {
            $('#admin-page .definition-description').each(function() {
                var description = $(this).find('.description');
                if (description.height() > $(this).height())
                    $(this).find('.read-more').removeClass('ng-hide');
            });
        }, 0);
    };

    $scope.loadInsights = function() {
        var endpointAddress = [ INSIGHTS_SERVICE_PREFIX ];
        if ($scope.onlyPending)
            endpointAddress.push('/pending');

        Backend.POST(endpointAddress.join(''), { from:($scope.page * $scope.pageSize), size:$scope.pageSize }).then(function(res) {
            $scope.insights = res.data;
            addReadMoreLinkIfNeeded();
            $scope.showingSearchResults = false;
            $scope.searchText = '';
        });
    };
    $scope.loadInsights();

    $scope.search = function() {
        if (!$scope.searchText || $scope.searchText.trim() === '') return;

        Backend.GET([ INSIGHTS_SERVICE_PREFIX, '/', $scope.searchText ].join('')).then(function(res) {
            $scope.insights = res.data ? [ res.data ] : null;
            addReadMoreLinkIfNeeded();
            $scope.showingSearchResults = true;
        });
    };

    $scope.clearSearch = function() {
        $scope.page = 0;
        $scope.loadInsights();
    };

    $scope.$watch('page', $scope.loadInsights);

    $scope.nextPage = function() {
        $scope.page++;
        $('div').animate({ scrollTop: 0 });
    };

    $scope.editInsight = function(insightId) {
        $scope.editingInsightId = insightId;
        ngDialog.open({
            template: 'app/dashboard/admin/create-insight.html',
            controller: 'CreateInsightController',
            width: '765px',
            scope: $scope,
            showClose: false,
            preCloseCallback: function() {
                $scope.editingInsightId = undefined;
            }
        });
    };

    $scope.expandDescription = function(event) {
        var link = $(event.currentTarget);
        link.addClass('ng-hide');

        var descriptionContainer = link.parents('.definition-description');
        descriptionContainer.css({'overflow':'visible'});
        descriptionContainer.css({'max-height':'600px'});
    };

    $scope.disableInsight = function(insightId) {
        Backend.POST([ INSIGHTS_SERVICE_PREFIX, '/', insightId, '/disable' ].join('')).then(function() {
            _.find($scope.insights, function(i) { return i.id === insightId; }).state = 'DISABLED';
        });
    };

    $scope.enableInsight = function(insightId) {
        Backend.POST([ INSIGHTS_SERVICE_PREFIX, '/', insightId, '/enable' ].join('')).then(function() {
            _.find($scope.insights, function(i) { return i.id === insightId; }).state = 'ENABLED_APPROVED';
        });
    };
});

/* origin: public/webapp/app/dashboard/admin/manipulation-rules/create-account-field-manipulation-rule-dialog-controller.js */
angular.module('webApp').controller('CreateAccountFieldManipulationRuleDialogController', function($scope, $state, Backend) {
    $scope.strategies = [
        { name: 'Stringify', value: 'STRINGIFY' },
        { name: 'Remove', value: 'REMOVE' }
    ];

    $scope.ruleData = {};
    $scope.createManipulationRule = function (ruleData) {
        $scope.requesting = true;
        Backend.POST([ '/__admin__/account/', $scope.accountId, '/rules' ].join(''), ruleData)
            .then(function() {
                alert('Manipulation rule created successfully');
                $scope.closeThisDialog();
            }).catch(function(res) {
                alert('Failed to create manipulation rule for account, error: ' + res.data.message);
            }).finally(function () {
                $scope.requesting = false;
            });
    };

});

/* origin: public/webapp/app/dashboard/admin/manipulation-rules/edit-account-field-manipulation-rules-controller.js */
angular.module('webApp').controller('EditAccountFieldManipulationController', function($scope, $stateParams, $q, ngDialog, Backend, logzioApi) {
    var initialLoad = function() {
        $scope.accountId = $stateParams.accountId;
        $scope.loadingData = true;

        $q.all([
            Backend.GET([ '/__admin__/account/', $stateParams.accountId, '/rules' ].join('')),
            Backend.GET([ '/__admin__/account/', $stateParams.accountId, '/log-types' ].join(''))
        ]).then(function(responses){
            $scope.rules = _.orderBy(responses[0].data, 'createAt');
            $scope.logTypes = responses[1].data;
            $scope.loadingData = false;
        }).catch(function () {
            $scope.loadingData = false;
            logzioApi.errorPopup('Oops', 'Failed to fetch account manipulating rules and/or log types', true);
        });
    };

    initialLoad();

    $scope.showCreateDialog = function() {
        ngDialog.open({
            template: 'app/dashboard/admin/manipulation-rules/create-account-field-manipulation-rule-dialog.html',
            controller: 'CreateAccountFieldManipulationRuleDialogController',
            closeByEscape: true,
            showClose: false,
            width: '765px',
            scope: $scope,
            preCloseCallback: initialLoad
        });
    };

    $scope.deleteRule = function(ruleId) {
        if (confirm('Are you sure you want to delete account field manipulation rule?') === false)
            return;

        $scope.loadingData = true;
        Backend.DELETE([ '/__admin__/account/', $stateParams.accountId, '/rules/', ruleId ].join('')).then(function() {
            initialLoad();
        }).catch(function(res) {
            alert('Failed to delete account log-adjuster rules, error: ' + res.data.message);
        }).finally(function () {
            $scope.loadingData = false;
        });
    };
});

/* origin: public/webapp/app/dashboard/admin/migrator/account-migration-controller.js */
angular.module('webApp').controller('AccountMigrationController', function($window, $scope, $interval, Backend, UserService, ngDialog) {

    $scope.historyPage = 0;
    $scope.suggestionsPage = 0;
    $scope.pageSize = 20;

    var getUserSummaryPromise = UserService.getSummary().then(function(res) { return res.data; });

    $scope.migrationAccounts = [];
    var getMigrationSuggestions = function() {
        Backend.POST('/__admin__/migrator/suggestions', { size: $scope.pageSize, from: (($scope.suggestionsPage || 0) * $scope.pageSize) }).then(function(accounts) {
            $scope.migrationAccounts = accounts.data.results;

            _.each($scope.migrationAccounts, function(account) {
                account.fullMigration = true;   // set the default
                Backend.GET('/__admin__/migrator/' + account.accountId + '/es-clusters').then(function(esClusters) {
                    account.esClusters = esClusters.data;
                });
            });
        }).catch(function(err) {
            if (updateMigrationsInterval)
                $interval.cancel(updateMigrationsInterval);

            alert('Error fetching suggested migrations.\nError: ' + angular.toJson(err));
        });
    };
    getMigrationSuggestions($scope.suggestionsPage);

    $scope.migrationHistory = [];
    var loadMigrationHistory = function() {
        Backend.POST('/__admin__/migrator/history', { size: $scope.pageSize, from: $scope.historyPage }).then(function(history) {
            $scope.migrationHistory = _.forEach(history.data.results, function(migration) {
                migration.startDate = migration.startDate ? migration.startDate * 1000 : undefined;
                migration.finishDate = migration.finishDate ? migration.finishDate * 1000 : undefined;
            });
        });
    };
    loadMigrationHistory();

    $scope.nextSuggestionsPage = function() { $scope.suggestionsPage++; };
    $scope.prevSuggestionsPage = function() { $scope.suggestionsPage--; };
    $scope.nextHistoryPage = function() { $scope.historyPage++; };
    $scope.prevHistoryPage = function() { $scope.historyPage--; };

    $scope.$watch('suggestionsPage', getMigrationSuggestions);
    $scope.$watch('historyPage', loadMigrationHistory);

    $scope.runningMigrations = [];
    var updateRunningMigrations = function() {
        Backend.POST('/__admin__/migrator/running', { size: $scope.pageSize, from: 0 }).then(function(migrations) {
            $scope.runningMigrations = _.forEach(migrations.data.results, function (migration) {
                migration.startDate = migration.startDate ? migration.startDate * 1000 : undefined;
            });
        });
    };
    var updateMigrationsInterval = $interval(updateRunningMigrations, 3000);
    updateRunningMigrations();


    $scope.startMigration = function(account) {
        getUserSummaryPromise.then(function(userSummary) {
            Backend.POST('/__admin__/migrator/start', {
                accountId: account.accountId,
                currentPlanType: account.currentPlanType,
                targetClusterId: account.targetClusterId,
                description: account.description,
                userId: userSummary.userId,
                fullMigration: account.fullMigration
            }).then(function() {
                // TODO: check for error starting this
                updateRunningMigrations();
                getMigrationSuggestions();
            });
        });
    };

    $scope.cancelMigration = function(migrationId) {
        if (!$window.confirm('Are you sure you want to abort ?'))
            return;
        Backend.POST('/__admin__/migrator/' + migrationId + '/cancel', {}).then(function() {
            updateRunningMigrations();
        });
    };

    $scope.openCreateMigrationDialog = function() {
        ngDialog.open({
            template: 'app/dashboard/admin/migrator/create-migration-dialog.html',
            controller: 'CreateMigrationDialogController',
            closeByEscape: false,
            showClose: false,
            width: '765px',
            scope: $scope
        });
    };

    $scope.$on('$destroy', function() {
        if (updateMigrationsInterval)
            $interval.cancel(updateMigrationsInterval);
    });
});
/* origin: public/webapp/app/dashboard/admin/migrator/create-migration-controller.js */
angular.module('webApp').controller('CreateMigrationDialogController', function($window, $scope, Backend, UserService, cacheService) {

    $scope.destinationCluster = {};

    UserService.getSummary().then(function(userSummary) {
        $scope.userSummary = userSummary.data;
    });

    cacheService.get('migrator-accounts', function() {
        return Backend.GET('/__admin__/migrator/accounts').then(function(accounts) {
            return accounts.data;
        });
    }).then(function(accounts) {
        $scope.migratableAccountOptions = _.map(accounts, function (account) {
            return  {
                text: account.accountName,
                prefix: account.accountId.toString(),
                value: account,
            };
        });
    });

    $scope.updateMigratingAccount = function(chosenAccount) {
        if (!$scope.migratableAccountOptions)
            return;

        $scope.destinationClusters = [];
        $scope.migratingAccount = chosenAccount;

        Backend.GET('/__admin__/migrator/' + chosenAccount.accountId + '/es-clusters').then(function(esClusters) {
            $scope.destinationClusters = esClusters.data;
        });
    };

    $scope.customCluster = '';
    $scope.fullMigration = true;
    $scope.migrate = function() {
        if (!$scope.userSummary || !$scope.migratingAccount)
            return;

        Backend.POST('/__admin__/migrator/start', {
            accountId: $scope.migratingAccount.accountId,
            currentPlanType: $scope.migratingAccount.currentPlanType,
            targetClusterId: $scope.targetClusterDisabled ? $scope.customCluster : $scope.destinationCluster.clusterId,
            description: $scope.migrateReason,
            userId: $scope.userSummary.userId,
            fullMigration: $scope.fullMigration
        }).then(function() {
            $window.alert('Migration created successfully.');
            $scope.closeThisDialog();
        }).catch(function(res) {
            $window.alert('There was an error creating the migration.\nError: ' + ((res && res.data && res.data.message) ? res.data.message : 'unknown'));
        });
    };

    $scope.targetClusterDisabled = false;
    var customClusterWatcher = $scope.$watch('customCluster', function(newVal) {
        $scope.targetClusterDisabled = (newVal && newVal.trim && newVal.trim() !== '');
    });

    $scope.$on('$destroy', function() {
        customClusterWatcher();
    });

});

/* origin: public/webapp/app/dashboard/admin/rate-dialog-controller.js */
angular.module('webApp').controller('rate-dialog-controller', function($scope, Backend) {
    $scope.copiedRate  = _.cloneDeep($scope.rate);
    if (!$scope.isExist) {
        $scope.rate = {};
        $scope.rate.dryRun = true;
    }

    $scope.cancel = function() {
        _.extend($scope.rate, $scope.copiedRate);
        $scope.closeThisDialog();
    };

    $scope.save = function(isExist) {
        var method = isExist ? 'PUT' : 'POST';
        Backend[method]('/__admin__/resource-rate', $scope.rate).then(function(res) {
            if (!isExist) {
                $scope.rates.push($scope.rate);
                $scope.rate.id = res.data.id;
            }
        }, function() {
            _.extend($scope.rate, $scope.copiedRate);
        }).finally(function() {
            $scope.closeThisDialog();
        });
    };
});
/* origin: public/webapp/app/dashboard/admin/rates-controller.js */
angular.module('webApp').controller('rates-controller', function($scope, ngDialog, ConfirmService, Backend) {

    $scope.loadingData = true;
    Backend.GET('/__admin__/resource-rate').then(function (res) {
        if (res.status && res.status === 200) {
            $scope.rates = res.data.rateDefinitions;
        }
        $scope.loadingData = false;
    }).catch(function (error) {
        $scope.loadingData = false;
        alert(['Error getting rates!', JSON.stringify(error)].join(' '));
    });


    $scope.openRateDialog = function(title, rate, isExist) {
        $scope.dialogTitle = title;
        $scope.rate = rate;
        $scope.isExist = isExist;
        ngDialog.open({
            template: 'app/dashboard/admin/rate-dialog.html',
            controller: 'rate-dialog-controller',
            width: '765px',
            scope: $scope,
            closeByEscape: true,
            showClose: false
        });
    };

    $scope.deleteRate = function(rate) {
        ConfirmService.open({
            template: 'directives/logz-confirm/logz-confirm.html',
            title: 'Are you sure?',
            action: 'Are you sure you want to delete this Rate?',
            confirm: function(scope) {
                Backend.DELETE('/__admin__/resource-rate', rate).then(function() {
                    _.remove($scope.rates, function(currentRate) {
                        return rate.id === currentRate.id;
                    });
                }).finally(function() {
                    scope.closeThisDialog();
                });
            }
        });
    };
}
);
/* origin: public/webapp/app/dashboard/admin/sawmill/sawmill-account.js */
angular.module('webApp').controller('sawmillAccountController', function ($scope, $stateParams, ngDialog, ConfirmService, Backend, sawmillEndpointService) {
    $scope.accountId = $stateParams.accountId;
    $scope.accountName = $stateParams.accountName || $scope.accountId;
    $scope.changeOrderState = false;
    var parsePipelineJsonData = function (pipelineDefinition) {
        try {
            var edited = JSON.parse(pipelineDefinition);
            return edited;
        }
        catch (e) {
            return pipelineDefinition;
        }
    };

    var flatPipeLineData = function (data) {
        _.forEach(data, function (value) {
            value.pipelineDefinitionParsed = parsePipelineJsonData(value.pipelineDefinition);
        });
        return data;
    };

    $scope.loadingGlobalPipelineConfigs = true;
    $scope.loadingLogTypePipelineConfigs = true;
    sawmillEndpointService.getAllAccountGlobalPipelineConfigs($scope.accountId).then(function (response) {
        $scope.sawmillGlobalPipelineConfigs = flatPipeLineData(response.data);
        $scope.loadingGlobalPipelineConfigs = false;
        flattenByPosition($scope.sawmillGlobalPipelineConfigs);
    });
    sawmillEndpointService.getAllAccountLogTypePipelineConfigs($scope.accountId).then(function (response) {
        $scope.sawmillLogTypePipelineConfigs = flatPipeLineData(response.data);
        $scope.loadingLogTypePipelineConfigs = false;
    });

    var initDialogProperties = function (sawmillPipelines, dialogType) {
        var dialogProperties = {
            template: 'directives/sawmill/create-sawmill-type.html',
            controller: 'createSawmillController',
            width: '765px',
            showClose: false
        };
        var dialogScope = $scope.$new();
        dialogScope.sawmillTypes = sawmillPipelines;
        dialogScope.dialogType = dialogType;
        dialogScope.accountID = $scope.accountId;
        dialogProperties.scope = dialogScope;
        return dialogProperties;
    };

    $scope.createSawmill = function (sawmillPipelines, dialogType) {
        ngDialog.open(initDialogProperties(sawmillPipelines, dialogType));
    };

    $scope.editSawmillConfigs = function (sawmillPipeline, dialogType) {
        sawmillPipeline.readOnly = sawmillPipeline.pipelineEditor && sawmillPipeline.pipelineEditor === 'SAWMILL_EDITOR_READONLY';

        var editDialogProperties = initDialogProperties(sawmillPipeline, dialogType);
        editDialogProperties.scope.sawmillTypeToEdit = sawmillPipeline;
        ngDialog.open(editDialogProperties);
    };

    var newSawmillConfigs = $scope.$on('new-sawmill-configs', function (event, args) {
        if (args.sawmillScope === 'GLOBAL') $scope.sawmillGlobalPipelineConfigs = flatPipeLineData(args.types);
        if (args.sawmillScope === 'LOG_TYPE') $scope.sawmillLogTypePipelineConfigs = flatPipeLineData(args.types);
    });

    $scope.deleteSawmillConfig = function (sawmillConfig) {
        var isLogType = sawmillConfig.hasOwnProperty('logType');
        var filter = isLogType ? {'logType': sawmillConfig.logType} : {'pipelineId': sawmillConfig.pipelineId};
        var sawmills = isLogType ? $scope.sawmillLogTypePipelineConfigs : $scope.sawmillGlobalPipelineConfigs;
        var sawmillScope = isLogType ? 'LOG_TYPE' : 'GLOBAL';

        var sawmillTypeIndexFound = _.findIndex(sawmills, filter);
        if (sawmillTypeIndexFound !== -1) {
            sawmills.splice(sawmillTypeIndexFound, 1);
        }
        sawmillEndpointService.deleteSawmillConfig(sawmillConfig, sawmillScope, $scope.accountId).then(function () {
        });
    };

    var moveArrayElementFromTo = function (anArray, from, to) {
        anArray.splice(to, 0, anArray.splice(from, 1)[0]);
        flattenByPosition(anArray);
    };

    var flattenByPosition = function (sawmillGlobalCollection) {
        _.orderBy(sawmillGlobalCollection, 'pipelineOrder', 'asc');
        var i = 1;
        _.forEach(sawmillGlobalCollection, function (item) {
            item.pipelineOrder = i;
            i++;
        });
    };

    $scope.moveDown = function (sawmillTypeToChange) {
        var itemPipelineOrder = sawmillTypeToChange.pipelineOrder;
        if (sawmillTypeToChange.pipelineOrder === $scope.sawmillGlobalPipelineConfigs.length) return;
        moveArrayElementFromTo($scope.sawmillGlobalPipelineConfigs, itemPipelineOrder - 1, itemPipelineOrder);
    };

    $scope.moveUp = function (sawmillTypeToChange) {
        var itemPipelineOrder = sawmillTypeToChange.pipelineOrder;
        if (itemPipelineOrder === 1) return;
        moveArrayElementFromTo($scope.sawmillGlobalPipelineConfigs, itemPipelineOrder - 1, itemPipelineOrder - 2);
    };

    $scope.toggleOrderState = function () {
        $scope.changeOrderState = !$scope.changeOrderState;
    };

    $scope.applyOrderInProgress = false;
    $scope.applyGlobalPipelineOrder = function () {
        if ($scope.applyOrderInProgress) return;
        $scope.applyOrderInProgress = true;
        flattenByPosition($scope.sawmillGlobalPipelineConfigs);

        var stepsData = {};
        _.forEach($scope.sawmillGlobalPipelineConfigs, function (sawmillPipline) {
            if (!stepsData.hasOwnProperty(sawmillPipline.step)) {
                stepsData[sawmillPipline.step] = { entityOrderList: [] };
            }

            stepsData[sawmillPipline.step].entityOrderList.push({
                key: sawmillPipline.pipelineId,
                order: sawmillPipline.pipelineOrder
            });
        });

        sawmillEndpointService.updateSawmillGlobalConfigOrder(stepsData, $scope.accountId).then(function () {
            $scope.applyOrderInProgress = false;
            $scope.changeOrderState = false;
        });
    };
    $scope.$on('$destroy', function () {
        if (newSawmillConfigs) newSawmillConfigs();
    });
});
/* origin: public/webapp/app/dashboard/admin/sawmill/sawmill.js */
angular.module('webApp').controller('sawmillController', function ($scope, ngDialog, ConfirmService, Backend, sawmillEndpointService) {

    $scope.loadingPage = true;
    sawmillEndpointService.getAllSawmillConfigs().then(function (response) {
        $scope.sawmillTypes = response.data;
        $scope.loadingPage = false;
    });


    var initDialogProperties = function () {
        var dialogProperties = {
            template: 'directives/sawmill/create-sawmill-type.html',
            controller: 'createSawmillController',
            width: '765px',
            showClose: false
        };
        var dialogScope = $scope.$new();
        dialogScope.sawmillTypes = $scope.sawmillTypes;
        dialogScope.dialogType = 'ADMIN';
        dialogProperties.scope = dialogScope;

        return dialogProperties;
    };

    $scope.createSawmillType = function () {
        ngDialog.open(initDialogProperties());
    };

    $scope.editSawmillType = function (sawmillType) {
        var editDialogProperties = initDialogProperties();
        editDialogProperties.scope.sawmillTypeToEdit = sawmillType;
        ngDialog.open(editDialogProperties);
    };

    var newSawmillConfigs = $scope.$on('new-sawmill-configs', function(event, args) {
        $scope.sawmillTypes = args.types;
    });

    $scope.deleteSawmillConfig = function (sawmillType) {
        var sawmillTypeIndexFound = _.findIndex($scope.sawmillTypes, {'logType': sawmillType.logType});
        if (sawmillTypeIndexFound !== -1) {
            $scope.sawmillTypes.splice(sawmillTypeIndexFound, 1);
        }
        var sawmillTypeName = sawmillType.logType.toLowerCase();
        sawmillEndpointService.deleteSawmillConfig(sawmillTypeName, 'ADMIN').then(function () {
        });

    };
    $scope.$on('$destroy', function () {
        if (newSawmillConfigs) newSawmillConfigs();
    });
}
);
/* origin: public/webapp/app/dashboard/alerts/alert-item.js */
angular.module('webApp').directive('alertItem', function ($timeout, $q, ngDialog, Backend, UpgradeService, ConfirmService, LabsService, AlertWizardService, TriggerWizardService, AnalyticsService, LogzioFileSaver, FeatureFlagService) {

    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/alerts/alert-item.html',
        scope: {
            alertData: '='
        },
        link: function(scope, elem) {
            var alertConditionMap = {
                'LESS_THAN': 'Less than',
                'GREATER_THAN': 'Greater than',
                'LESS_THAN_OR_EQUALS': 'Less than or equals',
                'GREATER_THAN_OR_EQUALS': 'Greater than or equals',
                'EQUALS': 'Equals',
                'NOT_EQUALS': 'Doesn\'t equal'
            };

            var alertTriggerTypeMap = {
                'NONE': '#',
                'COUNT': '#',
                'MIN': 'Minimum',
                'MAX': 'Maximum',
                'AVG': 'Average',
                'SUM': 'Sum'
            };

            var initializeAlert = function () {
                scope.alertData.alertDefinition.condition = alertConditionMap[scope.alertData.alertDefinition.operation];

                scope.alertData.alertDefinition.aggType = scope.alertData.alertDefinition.aggType || 'NONE'; // Support old alert types
                scope.alertData.alertDefinition.field = scope.alertData.alertDefinition.aggType === 'NONE' || scope.alertData.alertDefinition.aggType === 'COUNT'
                    ? 'events'
                    : scope.alertData.alertDefinition.aggField;
                scope.alertData.alertDefinition.triggerType = alertTriggerTypeMap[scope.alertData.alertDefinition.aggType];
            };
            initializeAlert();

            scope.toggleEnabled = function() {
                scope.enableAlert();
            };

            scope.openAlert = function() {

                var triggerId = scope.alertData.alertDefinition.alertDefinitionId;

                AnalyticsService.report('alerts:open-alert', {
                    category: 'alerts',
                    alertId: triggerId,
                });

                FeatureFlagService.isFeatureEnabled('continuous-aggregation').then(function (continuousAggregationEnabled) {
                    if(continuousAggregationEnabled){
                        TriggerWizardService.getTriggerDataById(triggerId, 'alerts/').then(function(res){
                            TriggerWizardService.storeDataAndOpenWizard(res.data, 'ALERT');//todo: add on edit 'CONTINUOUS_AGGREGATION'
                        });
                    }
                    else{
                        var copiedAlertDefinition = _.cloneDeep(scope.alertData.alertDefinition);
                        copiedAlertDefinition.filter = JSON.parse(copiedAlertDefinition.filter);
                        copiedAlertDefinition.notifications = JSON.parse(copiedAlertDefinition.notifications);
                        var editAlertData = {
                            alertDefinition: copiedAlertDefinition,
                            alertNotificationEndpoints: scope.alertData.alertNotificationEndpoints,
                            alertOutputTemplate: scope.alertData.alertOutputTemplate || {},
                        };
                        AlertWizardService.storeDataAndOpenWizard(editAlertData);
                    }
                });
            };

            var validateAlertEnableToggle = function (alertEnabled) {
                var d = $q.defer();

                if (!alertEnabled) { // User may always disable an alert
                    d.resolve();
                    return d.promise;
                }

                UpgradeService.getPlanDetails().then(function (planDetails) {
                    var amountOfEnabledAlerts = scope.alertData.getAmountOfEnabledAlerts();

                    var maxAlerts = planDetails.data.maxAlertsDefinition;
                    if (maxAlerts === 0) {
                        d.reject(true);
                    }
                    else if (amountOfEnabledAlerts >= maxAlerts) {
                        d.reject(false);
                    }
                    else {
                        d.resolve();
                    }
                });

                return d.promise;
            };

            scope.enableAlert = function(alertEnabled) {
                validateAlertEnableToggle(alertEnabled).then(function () {
                    scope.alertData.increaseDecreaseAmountOfEnabledAlerts(alertEnabled);
                    var enableAlertRequest = {
                        alertDefinitionId: scope.alertData.alertDefinition.alertDefinitionId,
                        enabled: alertEnabled
                    };
                    AnalyticsService.report('alerts:disable-enable', {
                        category: 'alerts',
                        alertId: enableAlertRequest.alertDefinitionId,
                        enabled: alertEnabled
                    });

                    Backend.POST('/enable-alert', enableAlertRequest).catch(function () {
                        // This means new alert(s) been created / enabled since the user session loaded the view alerts page
                        // and he exceeded his max enabled alerts by plan, we will show the upgrade service alert disabled dialog
                        scope.alertData.alertDefinition.enabled = false;
                        scope.alertData.increaseDecreaseAmountOfEnabledAlerts(false);
                        UpgradeService.showAlertDisabledDialog(false, false);
                    });
                }, function (failedDueToFreePlan) {
                    AnalyticsService.report('alerts:failed-enable-disable', {
                        category: 'alerts',
                    });

                    scope.alertData.alertDefinition.enabled = false;

                    if (failedDueToFreePlan) {
                        UpgradeService.showAlertsNotAvailableForPlanDialog();
                    }
                    else {
                        UpgradeService.showAlertDisabledDialog(false, false);
                    }
                });
            };

            scope.deleteAlert = function() {
                scope.destroyed = true;
                scope.alertData.increaseDecreaseAmountOfEnabledAlerts(false); // Delete an alert is possible if it is enabled, decrease the amount

                Backend.DELETE('/alerts/' + scope.alertData.alertDefinition.alertDefinitionId).then(function () {
                    AnalyticsService.report('alerts:delete', {
                        category: 'alerts',
                        alertId: scope.alertData.alertDefinition.alertDefinitionId,
                    });

                    $timeout(function() {
                        scope.$destroy();
                        elem.empty();
                    }, 1000);
                }).catch(function() {
                    AnalyticsService.report('alerts:delete-error', {
                        category: 'alerts',
                        alertId: scope.alertData.alertDefinition.alertDefinitionId,
                    });

                    alert('Failed to delete alert.\nThis might indicate that the alert was deleted already.\n Please refresh and try again.');
                    scope.destroyed = false;
                    scope.alertData.increaseDecreaseAmountOfEnabledAlerts(true);
                });
            };

            scope.exportToJSON = function () {
                var fileName = ['AlertDefinition_', scope.alertData.alertDefinition.alertDefinitionId, '.json'].join('');

                LogzioFileSaver(fileName, JSON.stringify(scope.alertData), 'data:text/json;charset=utf-8');
            };

            scope.contribute = function () {
                LabsService.contribute({
                    importedObjectId: scope.alertData.alertDefinition.alertDefinitionId,
                    id: scope.alertData.alertDefinition.alertDefinitionId,
                    name: scope.alertData.alertDefinition.title,
                    description: scope.alertData.alertDefinition.description,
                    objectType: 'ALERT',
                    logType: ''
                });
            };

        }
    };
});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/alert-without-ca-wizard/alert-wizard-menu-controller.js */
angular.module('webApp').controller('AlertWizardMenuController', function ($scope, $state, AlertWizardService, FeatureFlagService) {
    var alertData = AlertWizardService.getData();
    $scope.createAlertMode = alertData.alertDefinition.alertDefinitionId === undefined;

    $scope.steps = [
        { name: 'Conditions' },
        { name: 'Definitions' },
        { name: 'Triggers' }
    ];

    FeatureFlagService.isFeatureEnabled('customize-alert').then(function (customizeEnabled) {
        if (customizeEnabled)
            $scope.steps.push({ name: 'Customize', optional: true });
        getCurrentStepNumber();
    });

    $scope.doneSteps = [];
    for (var i = 1; i < $scope.steps.length + 1; i++) {
        if (!$scope.createAlertMode || i < $scope.stepNumber) {
            $scope.doneSteps.push(i);
        }
    }

    $scope.goToStep = function (stepNumber) {
        if ($scope.createAlertMode || !$scope.isStepValid()) {
            return;
        }

        $scope.saveStep();
        $state.go(['dashboard.alerts.wizard.step', stepNumber].join(''));
        AlertWizardService.report(['go-to-step-', stepNumber].join(''));
    };

    function getCurrentStepNumber() {
        $scope.stepNumber = _.findIndex($scope.steps, function (step) { return step.name === $scope.stepName; }) + 1;
    }

    getCurrentStepNumber();

});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/alert-without-ca-wizard/alert-wizard-menu.js */
angular.module('webApp').directive('alertWizardMenu', [function () {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/alerts/alert-wizard/alert-without-ca-wizard/alert-wizard-menu.html',
        scope: {
            stepName: '@',
            isStepValid: '&',
            saveStep: '&'
        },
        controller: 'AlertWizardMenuController'
    };
}]);
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/alert-without-ca-wizard/alert-wizard-step-1-controller.js */
angular.module('webApp').controller('AlertWizardStep1Controller', function($scope, $q, $state, $timeout, $window, AlertWizardService, Focus, ElasticSearchService, FeatureFlagService) {

    $scope.totalSteps = 3;
    FeatureFlagService.isFeatureEnabled('customize-alert').then(function(customizeEnabled) {
        if (customizeEnabled)
            $scope.totalSteps++;
    });

    var alertData = AlertWizardService.getData();
    if (!alertData) {
        $window.history.back();
        return;
    }

    $scope.alertDefinition = alertData.alertDefinition;
    $scope.alertOutputTemplate = alertData.alertOutputTemplate || {};
    $scope.createAlertMode = $scope.alertDefinition.alertDefinitionId === undefined;

    $scope.alertDefinition.aggType = $scope.alertDefinition.aggType || 'NONE';
    if ($scope.alertDefinition.aggType === 'COUNT') {
        $scope.alertDefinition.aggType = 'NONE'; // No COUNT operation in the wizard UI anymore, it was replaced with # of events (NONE) with a group by (services will treat that as COUNT but the wizard UI shouldn't)
    }
    $scope.alertDefinition.operation = $scope.alertDefinition.operation || 'GREATER_THAN';
    $scope.alertDefinition.threshold = $scope.alertDefinition.threshold || 0;
    $scope.alertDefinition.timeMinutes = $scope.alertDefinition.timeMinutes || 5;

    $scope.aggGroupByFields = {
        0: { value: '' },
        1: { value: '' },
        2: { value: '' },
    };
    $scope.selectedTriggerField = { value: $scope.alertDefinition.aggField};

    _.forEach($scope.alertDefinition.aggGroupByFields, function (field, index) {
        $scope.aggGroupByFields[index].value = field || '';
    });
    $scope.aggGroupByFields[0].value = $scope.alertDefinition.aggGroupBy || $scope.aggGroupByFields[0].value;

    $scope.alertNotificationEndpoints = alertData.alertNotificationEndpoints;

    $scope.thresholdRegex = '(\\-?\\d+)(\\.?\\d{0,2})';

    $scope.queryReadonlyMode = true;

    var stateBeforeEdit;
    $scope.enterEditMode = function () {
        stateBeforeEdit = {
            alertDefinitionQuery: $scope.alertDefinition.query,
            filters: _.cloneDeep($scope.filters),
            alertDefinitionFilter: _.cloneDeep($scope.alertDefinition.filter)
        };

        $scope.queryReadonlyMode = false;
    };

    $scope.cancelQueryEdit = function () {
        $scope.alertDefinition.query = stateBeforeEdit.alertDefinitionQuery;
        $scope.filters = stateBeforeEdit.filters;
        $scope.alertDefinition.filter = stateBeforeEdit.alertDefinitionFilter;
        $scope.stepForm['queryPanel'].$setValidity('query', true);
        $scope.queryReadonlyMode = true;
    };

    var querySaveInProgress = false;
    $scope.saveQueryEdit = function () {
        if ($scope.alertDefinition.query === stateBeforeEdit.alertDefinitionQuery) {
            $scope.stepForm['queryPanel'].$setValidity('query', true);
            $scope.queryReadonlyMode = true;
            return;
        }

        if (!$scope.stepForm['queryPanel'].$valid || querySaveInProgress) {
            return;
        }

        if (ElasticSearchService.isInProgress()) {
            querySaveInProgress = true;
            validationTimer.then(function () {
                $scope.queryReadonlyMode = $scope.stepForm['queryPanel'].$valid; // Stay in edit mode if query is invalid
                querySaveInProgress = false;
            });
        }
        else {
            $scope.queryReadonlyMode = $scope.stepForm['queryPanel'].$valid; // Stay in edit mode if query is invalid
        }
    };

    var validationTimer;
    $scope.validateQuery = function() {
        validationTimer = ElasticSearchService.validateQuery($scope.alertDefinition.query)
            .then(function (isValid) {
                $scope.stepForm['queryPanel'].$setValidity('query', isValid);
                AlertWizardService.report('validate-query', {isValid: isValid});
            });
    };

    var extractFilters = function (filters, negate) {
        if (!filters) {
            return;
        }

        for (var i = 0; i < filters.length; i++) {
            var filter = filters[i];
            if (filter.exists) {
                $scope.filters.push({
                    key: 'exists',
                    value: filter.exists.field,
                    negate: negate,
                    index: i
                });
            }
            else if (filter.match_phrase) {
                var keyName = Object.keys(filter.match_phrase)[0];
                $scope.filters.push({
                    key: keyName,
                    value: filter.match_phrase[keyName].query,
                    negate: negate,
                    index: i
                });
            }
        }
    };

    $scope.filters = [];
    if ($scope.alertDefinition.filter && $scope.alertDefinition.filter.bool) {
        extractFilters($scope.alertDefinition.filter.bool.must, false);
        extractFilters($scope.alertDefinition.filter.bool.must_not, true);
    }

    $scope.removeFilter = function (index) {
        var filter = $scope.filters[index];
        $scope.filters.splice(index, 1);
        filter.negate
            ? $scope.alertDefinition.filter.bool.must_not.splice(filter.index, 1)
            : $scope.alertDefinition.filter.bool.must.splice(filter.index, 1);
    };

    var aggTypeWatcher;

    $scope.clearSelectedGroupBy = function (logTypeIndex) {
        $scope.aggGroupByFields[logTypeIndex] = {value: ''};
    };

    $scope.selectGroupBy = function (type) {
        AlertWizardService.report(['add-group-by', type].join('-'));
    };

    var operationValidationWatcher = $scope.$watchCollection('[alertDefinition.operation, alertDefinition.aggType]', function () {
        var valid = $scope.alertDefinition.aggType === 'NONE' || ($scope.alertDefinition.operation !== 'EQUALS' && $scope.alertDefinition.operation !== 'NOT_EQUALS');
        $scope.stepForm['alertDefinition.operation'].$setValidity('valid', valid);
    });

    var checkIfDuplicated = function (item, array) {
        var count = 0;
        _.forEach(array, function (inner) {
            if (inner === item) {
                count++;
            }
        });
        return count <= 1;
    };

    var groupByWatcher = $scope.$watchCollection('[alertDefinition.aggType, aggGroupByFields[0].value, aggGroupByFields[1].value, aggGroupByFields[2].value, selectedTriggerField.value]', function () {
        var aggGroupFields = ['aggGroupByFields.first', 'aggGroupByFields.second', 'aggGroupByFields.third'];
        for (var i = 0, len = aggGroupFields.length; i < len; i++) {
            if (!$scope.stepForm[aggGroupFields[i]]) return;
        }
        if (!$scope.stepForm['selectedTriggerField']) return;

        $scope.alertDefinition.aggGroupByFields = [];
        $scope.alertDefinition.aggField = $scope.alertDefinition.aggType === 'NONE' ? null :
            $scope.selectedTriggerField.value === undefined ? null : $scope.selectedTriggerField.value;
        $scope.alertDefinition.aggGroupBy = $scope.aggGroupByFields[0].value; // Backward compatibility

        var stopAgg = false;
        _.forEach($scope.aggGroupByFields, function (aggGroupByField) {
            if (aggGroupByField.value !== '' && !stopAgg) {
                $scope.alertDefinition.aggGroupByFields.push(aggGroupByField.value);
            }
            else {
                stopAgg = true;
            }
        });

        var unionOfAggFields = _.concat([$scope.alertDefinition.aggField], $scope.alertDefinition.aggGroupByFields);

        $scope.stepForm['selectedTriggerField'].$setValidity('duplicate', checkIfDuplicated($scope.alertDefinition.aggField, unionOfAggFields));
        $scope.stepForm['selectedTriggerField'].$setValidity('required', !($scope.alertDefinition.aggType !== 'NONE' && $scope.alertDefinition.aggField === null));
        _.forEach(aggGroupFields, function (fieldFormName, index) {
            $scope.stepForm[fieldFormName].$setValidity('duplicate', checkIfDuplicated($scope.aggGroupByFields[index].value, unionOfAggFields));
        });
    });

    $scope.isStepValid = function () {
        var valid = $scope.stepForm.$valid;
        if (!$scope.queryReadonlyMode || !valid) {
            Focus('alert-wizard-step1-query-focus');
            showPleaseSubmit();
            return false;
        }

        return valid;
    };

    $scope.pleaseSubmitTimerRunning = false;
    var pleaseSubmitTimer;
    var showPleaseSubmit = function () {
        if ($scope.pleaseSubmitTimerRunning) {
            $timeout.cancel(pleaseSubmitTimer);
        }

        $scope.pleaseSubmitTimerRunning = true;
        pleaseSubmitTimer = $timeout(function () {
            $scope.pleaseSubmitTimerRunning = false;
        }, 2500);
    };

    $scope.saveStep = function() {
        var copiedAlertData = _.cloneDeep(alertData);
        AlertWizardService.storeData(copiedAlertData);
    };

    $scope.cancel = function () {
        AlertWizardService.report('cancel');
        AlertWizardService.clearData();
        $state.go(alertData.senderState);
    };

    $scope.goToAlertDefinitionPage = function() {
        if (!$scope.isStepValid()) {
            return;
        }

        $scope.saveStep();
        $state.go('dashboard.alerts.wizard.step2');
        AlertWizardService.report('go-to-alert-definition-test');
    };

    var savingAlert = false;
    $scope.save = function() {
        if (!$scope.isStepValid() || savingAlert) {
            return;
        }

        savingAlert = true;
        AlertWizardService.submitAlert($scope.alertDefinition, $scope.alertNotificationEndpoints, $scope.alertOutputTemplate).then(function () {
            AlertWizardService.clearData();
            $state.go('dashboard.alerts.definitions');
        }).catch(function () {
            alert('There was an error saving your alert');
            savingAlert = false;
        });
    };

    $scope.$on('$destroy', function () {
        if ($scope.pleaseSubmitTimerRunning) $timeout.cancel(pleaseSubmitTimer);
        if (groupByWatcher) groupByWatcher();
        if (operationValidationWatcher) operationValidationWatcher();
        if (aggTypeWatcher) aggTypeWatcher();
    });
});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/alert-without-ca-wizard/alert-wizard-step-2-controller.js */
angular.module('webApp').controller('AlertWizardStep2Controller', function($scope, $state, AlertWizardService, Focus, FeatureFlagService) {

    $scope.totalSteps = 3;
    FeatureFlagService.isFeatureEnabled('customize-alert').then(function(customizeEnabled) {
        if (customizeEnabled)
            $scope.totalSteps++;
    });

    var alertData = AlertWizardService.getData();
    $scope.alertDefinition = alertData.alertDefinition;
    $scope.createAlertMode = $scope.alertDefinition.alertDefinitionId === undefined;

    $scope.alertDefinition.severity = $scope.alertDefinition.severity || 'MEDIUM';
    $scope.alertDefinition.description = $scope.alertDefinition.description || '';

    $scope.alertNotificationEndpoints = alertData.alertNotificationEndpoints;
    $scope.alertOutputTemplate = alertData.alertOutputTemplate;

    $scope.isStepValid = function () {
        $scope.stepForm['alertDefinition.title'].$setTouched();

        var valid = $scope.stepForm.$valid;
        if (!valid) {
            Focus('alert-wizard-step2-title-invalid');
        }

        return valid;
    };

    $scope.saveStep = function() {
        AlertWizardService.storeData(alertData);
    };

    $scope.cancel = function () {
        AlertWizardService.clearData();
        $state.go(alertData.senderState);
    };

    $scope.goToAlertConditionsPage = function() {
        if (!$scope.createAlertMode && !$scope.isStepValid()) {
            // No need to disable him from going back in create alert mode, he will have to go through this step
            // again in order to complete the alert creation (in edit mode he can use the alert menu to navigate).
            return;
        }

        $scope.saveStep();
        $state.go('dashboard.alerts.wizard.step1');

    };

    $scope.goToAlertTriggersPage = function() {
        if (!$scope.isStepValid()) {
            return;
        }

        $scope.saveStep();
        $state.go('dashboard.alerts.wizard.step3');
    };

    var savingAlert = false;
    $scope.save = function() {
        if (!$scope.isStepValid() || savingAlert) {
            return;
        }

        savingAlert = true;
        AlertWizardService.submitAlert($scope.alertDefinition, $scope.alertNotificationEndpoints, $scope.alertOutputTemplate).then(function () {
            AlertWizardService.clearData();
            $state.go('dashboard.alerts.definitions');
        }).catch(function () {
            alert('There was an error saving your alert');
            savingAlert = false;
        });
    };
});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/alert-without-ca-wizard/alert-wizard-step-3-controller.js */
angular.module('webApp').controller('AlertWizardStep3Controller', function ($scope, $state, $q, AlertWizardService, NotificationEndpointService, Focus, AnalyticsService, FeatureFlagService) {

    $scope.totalSteps = 3;
    FeatureFlagService.isFeatureEnabled('customize-alert').then(function(customizeEnabled) {
        if (customizeEnabled)
            $scope.totalSteps++;
    });

    var alertData = AlertWizardService.getData();
    $scope.alertDefinition = alertData.alertDefinition;
    $scope.alertOutputTemplate = alertData.alertOutputTemplate;
    $scope.createAlertMode = $scope.alertDefinition.alertDefinitionId === undefined;

    $scope.recipientsChosen = $scope.recipientsChosen || [];

    $scope.numericFocusEvent = 'alert-wizard-step-3-supress-numeric-focus';
    $scope.invalidInputErrorMessage = 'No such endpoint or mail is invalid';

    $scope.goToAlertCustomizePage = function() {
        if (!$scope.isStepValid()) {
            return;
        }

        $scope.saveStep();
        $state.go('dashboard.alerts.wizard.step4');
    };

    if ($scope.alertDefinition.muteMinutes === undefined) {
        $scope.muteAmount = 1;
        $scope.muteType = 'HOURS';
    }
    else {
        var alertMuteMinutes = $scope.alertDefinition.muteMinutes;
        if (alertMuteMinutes % 1440 === 0) {
            $scope.muteAmount = alertMuteMinutes / 1440;
            $scope.muteType = 'DAYS';
        }
        else if (alertMuteMinutes % 60 === 0) {
            $scope.muteAmount = alertMuteMinutes / 60;
            $scope.muteType = 'HOURS';
        }
        else {
            $scope.muteAmount = alertMuteMinutes;
            $scope.muteType = 'MINUTES';
        }
    }

    if (!$scope.alertDefinition.notifications || !$scope.alertDefinition.notifications.notifications) {
        $scope.alertDefinition.notifications = {
            notifications: []
        };
    }

    $scope.alertNotificationEndpoints = alertData.alertNotificationEndpoints;
    if (!$scope.alertNotificationEndpoints) {
        $scope.alertNotificationEndpoints = alertData.alertNotificationEndpoints = [];
    }

    var getAllNotificationsCollection = function () {
        return NotificationEndpointService.getAllNotificationEndpoints().then(function (response) {
            return _.map(response.data, function (endpoint) {
                return {data: endpoint, name: endpoint.title};
            });
        });
    };

    $scope.recipientsCollection = [{
        name: 'Endpoints',
        itemIcon: function (suggestion) {
            return _.get(suggestion, 'data.templateName', '').toLowerCase();
        },
        action: {
            method: function () {
                AlertWizardService.addNewEndpoint($scope.recipientsCollection[0].data, $scope.recipientsChosen);
            },
            title: 'add a new endpoint'
        },
        noResults: 'No endpoints',
        id: 0,
        data: [],
    }, {
        groupType: 'emails', //indication to let 'logzio_grouped_multiselect that this is a mail group'
        name: 'Emails',
        icon: 'email',
        noResults: 'No emails, try typing yourself',
        id: 1,
        data: [],
    }];

    $scope.isLoadingRecipients = true;
    var notificationEmailsArray = _.map($scope.alertDefinition.notifications.notifications, function (email) {
        return email.address;
    });
    $scope.recipientsChosen = _.map(notificationEmailsArray, function (email, index) {
        return {name: email, id: index, group: 1};
    });
    $q.all({
        notificationsCollection: getAllNotificationsCollection(),
        emails: NotificationEndpointService.handleCachedEmailsList(notificationEmailsArray)
    }).then(function (values) {
        $scope.recipientsCollection[0].data = values.notificationsCollection;
        $scope.recipientsCollection[1].data = _.map(values.emails, function (email, index) {
            return {name: email, id: index, group: 1};
        });

        _.forEach($scope.alertNotificationEndpoints, function (notification) {
            var item, foundItem;
            item = {};
            _.set(item, 'data.id', notification.id);
            foundItem = _.find($scope.recipientsCollection[0].data, item);
            if (foundItem) {
                $scope.recipientsChosen.push(foundItem);
            }
        });
    }).finally(function () {
        $scope.isLoadingRecipients = false;
    });

    $scope.addEmailToCache = function (email) {
        NotificationEndpointService.handleCachedEmailsList([email]);
    };

    var validateMuteAmountAndSetAlertData = function () {
        $scope.muteAmount = $scope.muteAmount < 1
            ? 1 // Don't allow zero or negative numbers
            : Math.round(Number($scope.muteAmount));

        $scope.alertDefinition.muteMinutes = $scope.muteType === 'DAYS'
            ? $scope.muteAmount * 60 * 24
            : $scope.muteType === 'HOURS'
            ? $scope.muteAmount * 60
            : $scope.muteAmount;

        $scope.muteAmountMin = $scope.muteType === 'MINUTES' ? 5 : 1;
    };
    var muteAmountWatcher = $scope.$watch('muteAmount', validateMuteAmountAndSetAlertData);
    var muteTypeWatcher = $scope.$watch('muteType', validateMuteAmountAndSetAlertData);

    $scope.isStepValid = function () {
        if ($scope.stepForm['multiselectInput']) {
            $scope.stepForm['multiselectInput'].$setValidity('recipientsCount', $scope.recipientsChosen.length <= 15);
        }
        var valid = $scope.stepForm.$valid;
        if (!valid) {
            Focus($scope.stepForm['multiselectInput'].$invalid ? 'multiselect-input' : $scope.numericFocusEvent);
        }

        return valid;
    };

    $scope.saveStep = function() {
        setNotificationEndpoints();
        alertData.alertNotificationEndpoints = $scope.alertNotificationEndpoints;
        AlertWizardService.storeData(alertData);
    };

    $scope.cancel = function () {
        AlertWizardService.clearData();
        $state.go(alertData.senderState);
    };

    $scope.goToAlertDefinitionsPage = function() {
        if (!$scope.createAlertMode && !$scope.isStepValid()) {
            // No need to disable him from going back in create alert mode, he will have to go through this step
            // again in order to complete the alert creation (in edit mode he can use the alert menu to navigate).
            return;
        }

        $scope.saveStep();
        $state.go('dashboard.alerts.wizard.step2');
    };

    var savingAlert = false;

    function setNotificationEndpoints() {
        $scope.alertDefinition.notifications.notifications = [];
        $scope.alertNotificationEndpoints = [];
        _.forEach($scope.recipientsChosen, function (recipient) {
            if (recipient.data) { //its a notification endpoint
                $scope.alertNotificationEndpoints.push(recipient.data);
            }
            else { //its an email
                $scope.alertDefinition.notifications.notifications.push({
                    address: recipient.name,
                    type: 'EMAIL'
                });
            }
        });
    }

    $scope.submit = function () {
        if (!$scope.isStepValid() || savingAlert) {
            return;
        }

        savingAlert = true;
        setNotificationEndpoints();

        AlertWizardService.submitAlert($scope.alertDefinition, $scope.alertNotificationEndpoints, $scope.alertOutputTemplate).then(function () {
            AlertWizardService.clearData();
            $state.go('dashboard.alerts.definitions');
        }).catch(function () {
            alert('There was an error saving your alert');
            savingAlert = false;
        });
    };

    $scope.$on('$destroy', function () {
        if (muteTypeWatcher) muteTypeWatcher();
        if (muteAmountWatcher) muteAmountWatcher();
    });
});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/alert-without-ca-wizard/alert-wizard-step-4-controller.js */
angular.module('webApp').controller('AlertWizardStep4Controller', function ($scope, $state, $timeout, $document, AnalyticsService, AlertWizardService, MappingsService, FeatureFlagService, ElasticSearchService) {
    var alertData = AlertWizardService.getData();
    var MAX_COLUMNS = 7;

    $scope.totalSteps = 3;
    FeatureFlagService.isFeatureEnabled('customize-alert').then(function (customizeEnabled) {
        if (customizeEnabled)
            $scope.totalSteps++;
    });

    $scope.alertDefinition = alertData.alertDefinition;
    $scope.alertNotificationEndpoints = alertData.alertNotificationEndpoints;
    $scope.createAlertMode = $scope.alertDefinition.alertDefinitionId === undefined;

    $scope.alertOutputTemplate = alertData.alertOutputTemplate || {};
    if (typeof $scope.alertOutputTemplate.fieldsConfig === 'string') {
        $scope.alertOutputTemplate.fieldsConfig = JSON.parse($scope.alertOutputTemplate.fieldsConfig);
    }
    else {
        $scope.alertOutputTemplate.fieldsConfig = $scope.alertOutputTemplate.fieldsConfig ? $scope.alertOutputTemplate.fieldsConfig : [];
    }

    $scope.alertOutputTemplate.templateType = $scope.alertOutputTemplate.templateType || 'JSON';

    $scope.aggMode = $scope.alertDefinition.aggGroupByFields.length > 0 || !!$scope.alertDefinition.aggField;
    if ($scope.aggMode) {
        $scope.alertOutputTemplate.fieldsConfig = [];
    }

    $scope.updateFieldRegex = function (field, regex) {
        if (!field || regex === undefined) return;
        $timeout(function () { //some work around a bug with ng-animate
            var fieldItem = _.find($scope.alertOutputTemplate.fieldsConfig, {
                name: field
            });
            fieldItem.data = regex;
            $scope.getPreviewData();
            AlertWizardService.report('update-field-regex');
        }, 500);
    };

    $scope.removeTableField = function (field) {
        $scope.alertOutputTemplate.fieldsConfig = _.reject($scope.alertOutputTemplate.fieldsConfig, function (fieldConfig) {
            return fieldConfig.name === field;
        });
        if ($scope.alertOutputTemplate.sortBy === field) {
            delete $scope.alertOutputTemplate.sortBy;
            delete $scope.alertOutputTemplate.sortOrder;
        }
        $scope.getPreviewData();
        AlertWizardService.report('remove-table-field', {field: field});
    };

    $scope.sortByField = function (fieldName) {
        if (!$scope.isAggregatableField(fieldName)) return;
        if ($scope.alertOutputTemplate.sortBy === fieldName) {
            $scope.alertOutputTemplate.sortOrder = $scope.alertOutputTemplate.sortOrder === 'DESC' ? 'ASC' : 'DESC';
        }
        else {
            $scope.alertOutputTemplate.sortOrder = 'DESC';
        }
        $scope.alertOutputTemplate.sortBy = fieldName;
        $scope.getPreviewData();
        AlertWizardService.report('sort-by-field', {field: fieldName});
    };

    var savingAlert = false;
    $scope.loadingResults = false;
    function extractHeadersAndSamples(res) {
        if ($scope.aggMode) {
            var headers = _.get(res, 'data.fieldsConfig', []);
            $scope.alertOutputTemplate.fieldsConfig = _.map(headers, function (header) {
                return {name: header.name, data: header.data};
            });
        }
        $scope.sampleLogs = [];
        $scope.sampleLogs = _.get(res, 'data.samples', []);
    }

    $scope.submit = function (preview) {
        if (savingAlert) return;
        if (!preview && !$scope.isStepValid()) return;

        savingAlert = true;
        $scope.loadingResults = preview;
        AlertWizardService.submitAlert($scope.alertDefinition, $scope.alertNotificationEndpoints, $scope.alertOutputTemplate, preview).then(function (res) {
            if (preview) {
                extractHeadersAndSamples(res);
            }
            else {
                AlertWizardService.clearData();
                $state.go('dashboard.alerts.definitions');
            }
        }).catch(function (error) {
            $scope.error = 'There was an error saving your alert';
            console.error(error);
        }).finally(function () {
            savingAlert = false;
            $scope.loadingResults = false;
        });

    };

    var aggregatableFields = {};
    ElasticSearchService.retrieveElasticIndexedFields().then(function (fields) {
        $scope.aggregatableFields = _.forEach(fields, function (field) {
            aggregatableFields[field.name] = field.aggregatable;
        });
    });
    $scope.isAggregatableField = function (fieldName) {
        return aggregatableFields[fieldName] === true;
    };

    $scope.getTableValidity = function () {
        if (!$scope.stepForm['outputTableFields']) return true;
        var valid = $scope.getObjectSize($scope.alertOutputTemplate.fieldsConfig) > 0;

        $scope.stepForm['outputTableFields'].$setValidity('missing', valid);
        return valid;
    };

    $scope.isStepValid = function () {
        if ($scope.alertOutputTemplate.templateType === 'JSON') return true;
        return $scope.getTableValidity();
    };

    $scope.getPreviewData = function () {
        $scope.submit(true);
    };

    $scope.outputTableSelectedField = {value: ''};
    $scope.addFieldToOutputTable = function () {
        if ($scope.getObjectSize($scope.alertOutputTemplate.fieldsConfig) >= MAX_COLUMNS) {
            return;
        }

        var fieldToAdd = $scope.outputTableSelectedField;
        if (_.some($scope.alertOutputTemplate.fieldsConfig, {name: fieldToAdd.value})) {
            return;
        }

        $scope.alertOutputTemplate.fieldsConfig = $scope.alertOutputTemplate.fieldsConfig || [];
        $scope.alertOutputTemplate.fieldsConfig.push({
            name: fieldToAdd.value,
            data: '',
        });
        $scope.getPreviewData();
        $scope.getTableValidity();
        AlertWizardService.report('add-field-to-output-table', {field: fieldToAdd.value});
    };

    $scope.getObjectSize = function (object) {
        return _.size(object);
    };

    $scope.cancel = function () {
        AlertWizardService.clearData();
        $state.go(alertData.senderState);
        AlertWizardService.report('cancel');
    };

    $scope.saveStep = function () {
        if (!$scope.isStepValid()) {
            return;
        }
        alertData.alertOutputTemplate = $scope.alertOutputTemplate;
        AlertWizardService.storeData(alertData);
    };

    $scope.goToAlertTriggerPage = function () {
        if (!$scope.createAlertMode && !$scope.isStepValid()) {
            return;
        }

        $scope.saveStep();
        $state.go('dashboard.alerts.wizard.step3');
    };
    if ($scope.aggMode && $scope.alertOutputTemplate.templateType === 'TABLE') $scope.getPreviewData();

});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/regex-popover/regex-popover.js */
angular.module('webApp').controller('regexPopoverController', function ($scope) {
    $scope.regexInput = $scope.data.regexInput;

    $scope.cancel = function () {
        $scope.closeCallback();
    };
    $scope.applyRegex = function () {
        $scope.popoverCloseCallbackFunction($scope.data.field, $scope.regexInput);
        $scope.closeCallback(true);
    };
});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/trigger-wizard-directives/trigger-group-by-directive/trigger-group-by-controller.js */
angular.module('webApp').controller('TriggerWizardGroupByController', function ($scope) {

    $scope.addGroupIsShow = true;
    $scope.REMOVE_GROUP_BY_TEXT = 'Remove';

    $scope.clearSelectedGroupBy = function (logTypeIndex) {
        $scope.aggGroupByFields[logTypeIndex] = {
            value: '',
            isShown: false
        };
        isAddGroupBtnShown();
        $scope.clearCallback();
    };

    $scope.addGroupBySection = function () {
        var availableGroupBySection = _.findKey($scope.aggGroupByFields, ['isShown', false]);

        $scope.aggGroupByFields[availableGroupBySection].isShown = true;
        isAddGroupBtnShown();
    };

    var isAddGroupBtnShown = function (){
        $scope.addGroupIsShow = _.find($scope.aggGroupByFields, ['isShown', false]);
    };
});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/trigger-wizard-directives/trigger-group-by-directive/trigger-group-by-directive.js */
angular.module('webApp').directive('triggerWizardGroupBy', function () {
    return {
        restrict: 'E',
        scope: {
            aggGroupByFields: '=',
            changeCallback: '=',
            clearCallback: '='
        },
        controller: 'TriggerWizardGroupByController',
        templateUrl: 'app/dashboard/alerts/alert-wizard/trigger-wizard-directives/trigger-group-by-directive/trigger-group-by-directive.html'
    };
});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/trigger-wizard-directives/trigger-recipients-directive/trigger-recipients-controller.js */
angular.module('webApp').controller('TriggerWizardRecipientsController', function ($scope, $q, AlertWizardService, NotificationEndpointService) {

    $scope.invalidInputErrorMessage = 'No such endpoint or mail is invalid';

    $scope.recipientsCollection = [{
        name: 'Endpoints',
        itemIcon: function (suggestion) {
            return _.get(suggestion, 'data.templateName', '').toLowerCase();
        },
        action: {
            method: function () {
                AlertWizardService.addNewEndpoint($scope.recipientsCollection[0].data, $scope.recipientsChosen.data);
            },
            title: 'add a new endpoint'
        },
        noResults: 'No endpoints',
        id: 0,
        data: [],
    }, {
        groupType: 'emails', //indication to let 'logzio_grouped_multiselect that this is a mail group'
        name: 'Emails',
        icon: 'email',
        noResults: 'No emails, try typing yourself',
        id: 1,
        data: [],
    }];

    var getAllNotificationsCollection = function () {
        return NotificationEndpointService.getAllNotificationEndpoints().then(function (response) {
            return _.map(response.data, function (endpoint) {
                return {data: endpoint, name: endpoint.title};
            });
        });
    };

    $scope.isLoadingRecipients = true;
    var notificationEmailsArray = _.map($scope.recipients.emailNotifications.notifications, function (email) {
        return email.address;
    });
    $scope.recipientsChosen.data = _.map(notificationEmailsArray, function (email, index) {
        return {name: email, id: index, group: 1};
    });

    $q.all({
        notificationsCollection: getAllNotificationsCollection(),
        emails: NotificationEndpointService.handleCachedEmailsList(notificationEmailsArray)
    }).then(function (values) {
        $scope.recipientsCollection[0].data = values.notificationsCollection;
        $scope.recipientsCollection[1].data = _.map(values.emails, function (email, index) {
            return {name: email, id: index, group: 1};
        });

        _.forEach($scope.recipients.notificationEndpoints, function (notification) {
            var item, foundItem;
            item = {};
            _.set(item, 'data.id', notification.id);
            foundItem = _.find($scope.recipientsCollection[0].data, item);
            if (foundItem) {
                $scope.recipientsChosen.data.push(foundItem);
            }
        });
    }).finally(function () {
        $scope.isLoadingRecipients = false;
    });

    $scope.addEmailToCache = function (email) {
        NotificationEndpointService.handleCachedEmailsList([email]);
    };
});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/trigger-wizard-directives/trigger-recipients-directive/trigger-recipients-directive.js */
angular.module('webApp').directive('triggerWizardRecipients', function () {
    return {
        restrict: 'E',
        scope: {
            recipients: '=',
            recipientsChosen: '='
        },
        controller: 'TriggerWizardRecipientsController',
        templateUrl: 'app/dashboard/alerts/alert-wizard/trigger-wizard-directives/trigger-recipients-directive/trigger-recipients-directive.html'
    };
});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/trigger-wizard-directives/trigger-table-format-directive/trigger-table-format-controller.js */
angular.module('webApp').controller('TriggerTableFormatController', function ($scope, $timeout, $state, ElasticSearchService, AlertWizardService, TriggerWizardService) {

    var MAX_COLUMNS = 7;

    $scope.api.getPreviewData = function () {
        $scope.getPreviewData();
    };

    $scope.alertNotificationEndpoints = $scope.triggerData.output.target.notificationEndpoints || {};

    if (typeof $scope.triggerData.output.format.fieldsConfig === 'string') {
        $scope.triggerData.output.format.fieldsConfig = JSON.parse($scope.triggerData.output.format.fieldsConfig);
    }
    else {
        $scope.triggerData.output.format.fieldsConfig = $scope.triggerData.output.format.fieldsConfig ? $scope.triggerData.output.format.fieldsConfig : [];
    }

    function updateAggMode() {
        $scope.aggMode = TriggerWizardService.isAggMode($scope.triggerData);
        if ($scope.aggMode) {
            $scope.triggerData.output.format.fieldsConfig = [];
        }
    }
    updateAggMode();

    $scope.updateFieldRegex = function (field, regex) {
        if (!field || regex === undefined) return;
        $timeout(function () { //some work around a bug with ng-animate
            var fieldItem = _.find($scope.triggerData.output.format.fieldsConfig, {
                name: field
            });
            fieldItem.data = regex;
            $scope.getPreviewData();
            TriggerWizardService.report('update-field-regex');
        }, 500);
    };

    $scope.removeTableField = function (field) {
        $scope.triggerData.output.format.fieldsConfig = _.reject($scope.triggerData.output.format.fieldsConfig, function (fieldConfig) {
            return fieldConfig.name === field;
        });
        if ($scope.triggerData.output.format.sortBy === field) {
            delete $scope.triggerData.output.format.sortBy;
            delete $scope.triggerData.output.format.sortOrder;
        }
        $scope.getPreviewData();
        TriggerWizardService.report('remove-table-field', {field: field});
    };

    $scope.sortByField = function (fieldName) {
        if (!$scope.isAggregatableField(fieldName)) return;
        if ($scope.triggerData.output.format.sortBy === fieldName) {
            $scope.triggerData.output.format.sortOrder = $scope.triggerData.output.format.sortOrder === 'DESC' ? 'ASC' : 'DESC';
        }
        else {
            $scope.triggerData.output.format.sortOrder = 'DESC';
        }
        $scope.triggerData.output.format.sortBy = fieldName;
        $scope.getPreviewData();
        TriggerWizardService.report('sort-by-field', {field: fieldName});
    };

    $scope.loadingResults = false;
    function parseTableData(res) {
        if ($scope.aggMode) {
            var headers = _.get(res.data, 'fieldsConfig', []);
            $scope.triggerData.output.format.fieldsConfig = _.map(headers, function (header) {
                return {name: header.name, data: header.data};
            });
        }
        $scope.sampleLogs = [];
        $scope.sampleLogs = _.get(res.data, 'samples', []);
    }

    $scope.getPreviewData = function () {
        $scope.loadingResults = true;
        $scope.callbackFn($scope.triggerData);//fetch current data before getting samples
        updateAggMode();

        TriggerWizardService.getTableSamples($scope.triggerData).then(function (res) {
            parseTableData(res);
        }).catch(function () {
            $scope.error = 'There was an error getting trigger table data';
        }).finally(function () {
            $scope.loadingResults = false;
        });
    };

    var aggregatableFields = {};
    ElasticSearchService.retrieveElasticIndexedFields().then(function (fields) {
        $scope.aggregatableFields = _.forEach(fields, function (field) {
            aggregatableFields[field.name] = field.aggregatable;
        });
    });
    $scope.isAggregatableField = function (fieldName) {
        return aggregatableFields[fieldName] === true;
    };

    $scope.getTableValidity = function () {
        if (!$scope.tableForm['outputTableFields']) return true;
        var valid = $scope.getObjectSize($scope.triggerData.output.format.fieldsConfig) > 0;

        $scope.tableForm['outputTableFields'].$setValidity('missing', valid);
        return valid;
    };

    $scope.outputTableSelectedField = {value: ''};
    $scope.addFieldToOutputTable = function () {
        if ($scope.getObjectSize($scope.triggerData.output.format.fieldsConfig) >= MAX_COLUMNS) {
            return;
        }

        var fieldToAdd = $scope.outputTableSelectedField;
        if (_.some($scope.triggerData.output.format.fieldsConfig, {name: fieldToAdd.value})) {
            return;
        }

        $scope.triggerData.output.format.fieldsConfig = $scope.triggerData.output.format.fieldsConfig || [];
        $scope.triggerData.output.format.fieldsConfig.push({
            name: fieldToAdd.value,
            data: '',
        });
        $scope.getPreviewData();
        $scope.getTableValidity();
        TriggerWizardService.report('add-field-to-output-table', {field: fieldToAdd.value});
        $scope.tableForm['outputTableFields'].$setValidity('required', true);
    };

    $scope.getObjectSize = function (object) {
        return _.size(object);
    };

    $scope.$watch('triggerData.output.format.type', function (type) {
        //the timeout is due to the fact that the wizard controller is not ready yet with the notifications endpoints
        //while this action runs over it before it initialized.
        //todo this should be done with sync of the controller
        if(type === 'TABLE') $timeout($scope.getPreviewData);
    });
});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/trigger-wizard-directives/trigger-table-format-directive/trigger-table-format.js */
angular.module('webApp').directive('triggerTableFormat', function () {
    return {
        restrict: 'E',
        scope: {
            triggerData: '=',
            callbackFn: '&',
            api: '='
        },
        controller: 'TriggerTableFormatController',
        templateUrl: 'app/dashboard/alerts/alert-wizard/trigger-wizard-directives/trigger-table-format-directive/trigger-table-format.html'
    };
});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/trigger-wizard-directives/trigger-wizard-query-directive/alert-wizard-query-controller.js */
angular.module('webApp').controller('AlertWizardQueryController', function ($scope, $q, $state, $timeout, $window, TriggerWizardService, Focus, ElasticSearchService, KibanaFiltersService) {
    
    $scope.queryReadOnlyMode = true;

    var stateBeforeEdit;

    $scope.enterEditMode = function () {
        stateBeforeEdit = {
            alertDefinitionQuery: $scope.triggerQuery,
            filters:  _.cloneDeep($scope.filters),
            alertDefinitionFilter: _.cloneDeep($scope.triggerFilter)
        };

        $scope.queryReadOnlyMode = false;
    };

    $scope.cancelQueryEdit = function () {
        $scope.triggerQuery = stateBeforeEdit.alertDefinitionQuery;
        $scope.filters = stateBeforeEdit.filters;
        $scope.triggerFilter = stateBeforeEdit.alertDefinitionFilter;
        $scope.queryForm['triggerQuery'].$setValidity('query', true);
        $scope.queryReadOnlyMode = true;
    };

    var querySaveInProgress = false;
    $scope.saveQueryEdit = function () {
        if ($scope.triggerQuery === stateBeforeEdit.alertDefinitionQuery) {
            $scope.queryForm['triggerQuery'].$setValidity('query', true);
            $scope.queryReadOnlyMode = true;
            return;
        }

        if (!$scope.queryForm['triggerQuery'].$valid || querySaveInProgress) {
            return;
        }

        if (ElasticSearchService.isInProgress()) {
            querySaveInProgress = true;
            validationTimer.then(function () {
                $scope.queryReadOnlyMode = $scope.queryForm.$valid; // Stay in edit mode if query is invalid
                querySaveInProgress = false;
            });
        }
        else {
            $scope.queryReadOnlyMode = $scope.queryForm.$valid; // Stay in edit mode if query is invalid
        }
    };

    var validationTimer;
    $scope.validateQuery = function() {
        validationTimer = ElasticSearchService.validateQuery($scope.triggerQuery)
            .then(function (isValid) {
                $scope.queryForm['triggerQuery'].$setValidity('query', isValid);
                TriggerWizardService.report('validate-query', {isValid: isValid});
            });
    };

    function addFilterToFilters(key, value, negate, index) {
        $scope.filters.push({
            key: key,
            value: value,
            negate: negate,
            index: index
        });
    }

    var extractFilters = function (filters, negate) {

        var keyName, value;

        if (!filters) {
            return;
        }

        _.forEach(filters, function (filter, index) {
            if (filter.exists) {

                addFilterToFilters('exists', filter.exists.field, negate, index);
            }
            else if (filter.match_phrase) {

                keyName = Object.keys(filter.match_phrase)[0];
                addFilterToFilters(keyName, filter.match_phrase[keyName].query, negate, index);
            }
            else if(filter.bool) {

                keyName = Object.keys(filter.bool.should[0].match_phrase)[0];
                value = KibanaFiltersService.extractValuesFromIsOneOfFilter(filter.bool.should, keyName);
                addFilterToFilters(keyName, value, negate, index);
            }
            else if(filter.range) {

                keyName = Object.keys(filter.range)[0];
                value = KibanaFiltersService.extractValuesFromIsBetweenFilter(filter.range[keyName]);
                addFilterToFilters(keyName, value, negate, index);
            }
        });
    };

    $scope.filters = [];
    if ($scope.triggerFilter && $scope.triggerFilter.bool) {
        extractFilters($scope.triggerFilter.bool.must, false);
        extractFilters($scope.triggerFilter.bool.must_not, true);
    }

    $scope.removeFilter = function (index) {
        var filter = $scope.filters[index];
        $scope.filters.splice(index, 1);
        filter.negate
            ? $scope.triggerFilter.bool.must_not.splice(filter.index, 1)
            : $scope.triggerFilter.bool.must.splice(filter.index, 1);
    };

    $scope.focuseIfQueryNotValid = function () {
        if (!$scope.queryReadOnlyMode) {
            Focus('alert-wizard-step1-query-focus');
            showPleaseSubmit();
        }
    };

    $scope.pleaseSubmitTimerRunning = false;
    var pleaseSubmitTimer;
    var showPleaseSubmit = function () {
        if ($scope.pleaseSubmitTimerRunning) {
            $timeout.cancel(pleaseSubmitTimer);
        }

        $scope.pleaseSubmitTimerRunning = true;
        pleaseSubmitTimer = $timeout(function () {
            $scope.pleaseSubmitTimerRunning = false;
        }, 2500);
    };

    $scope.$on('$destroy', function () {
        if ($scope.pleaseSubmitTimerRunning) $timeout.cancel(pleaseSubmitTimer);
    });

});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/trigger-wizard-directives/trigger-wizard-query-directive/alert-wizard-query.js */
angular.module('webApp').directive('alertWizardQuery', function () {
    return {
        restrict: 'E',
        scope: {
            triggerQuery: '=',
            triggerFilter: '='
        },
        controller: 'AlertWizardQueryController',
        templateUrl: 'app/dashboard/alerts/alert-wizard/trigger-wizard-directives/trigger-wizard-query-directive/alert-wizard-query.html'
    };
});
/* origin: public/webapp/app/dashboard/alerts/alert-wizard/trigger-wizard-page-controller.js */
/* eslint-disable max-lines */
angular.module('webApp').controller('AlertWizardPageController', function ($scope, $timeout, $window, $state, AlertWizardService, TriggerWizardService, AuthService, Focus, LogzToast) {

    $scope.CONTINUOUS_AGGREGATION_NAME = 'CONTINUOUS_AGGREGATION';
    $scope.ALERT_NAME = 'ALERT';
    $scope.CONDITION_NAME = 'CONDITION';
    $scope.SCHEDULE_NAME = 'SCHEDULE';
    $scope.TABLE_FORMAT_NAME = 'TABLE';
    $scope.JSON_FORMAT_NAME = 'JSON';
    $scope.NULL_VALUE = 'NULL';
    $scope.NONE_VALUE = 'NONE';
    $scope.COUNT_VALUE = 'COUNT';
    $scope.OVER_PERIOD_COUNTER = 5;
    $scope.MAX_MINUTE_PERIOD_VALUE = 60;
    $scope.MIN_MINUTE_PERIOD_VALUE = 5;
    $scope.MAX_HOUR_PERIOD_VALUE = 24;
    $scope.MIN_HOUR_PERIOD_VALUE = 1;
    $scope.TRIGGER_THRESHOLD = Math.pow(10, 380); //max value in sql

    var timelessIndexTypeMap;
    $scope.triggerSubmitted = false;

    //get data
    $scope.triggerData = TriggerWizardService.getData();
    $scope.createTriggerMode = _.get($scope.triggerData, 'id', false);
    $scope.showAggConfirmDialog = false;
    getTimelessIndicesAndTypes();

    declareTriggerPageParameters();
    initTriggerDataModel();

    //only admin users will be able to create continuous aggregation
    $scope.targetGroupButtonsData.uiData.disabledBtnsList = [$scope.CONTINUOUS_AGGREGATION_NAME];//disable as default
    AuthService.isAdminRole().then(function (isAdminRole) {
        if (isAdminRole) {$scope.targetGroupButtonsData.uiData.disabledBtnsList = '';}//enable if the user is admin
    });

    $scope.tableApi = {
        getPreviewData: function () {}
    };

    // clear the group by fields after the user cancels the group by via the aggregation dialog
    $scope._clearGroupByFields = function(){
        _.forEach($scope.aggGroupByFields, function (field) {
            field.value = '';
            field.isShown = false;
        });
    };

    $scope.selectGroupBy = function (type) {
        TriggerWizardService.openConfirmAggregationDialog($scope.showAggConfirmDialog)
            .then(function () {
                TriggerWizardService.report('add-group-by', {groupByType: type});
                $scope.tableApi.getPreviewData();
            })
            .catch(function () {
                // clear the 'group by' fields
                $scope._clearGroupByFields();
                $scope.tableApi.getPreviewData();
            });
    };

    // the is a callback from the group by directive, called if the user manually clears the group by fields
    $scope.clearGroupByCallback = function () {
        TriggerWizardService.report('clear-group-by');
        $scope.tableApi.getPreviewData();
    };

    // clear the 'trigger if' condition
    $scope._clearTriggerIfCondition = function(){
        $scope.triggerIfSelectedField.value = '';
        $scope.triggerIfAppSelect.model = $scope.NONE_VALUE;
    };

    $scope.selectTriggerIf = function (type) {
        TriggerWizardService.openConfirmAggregationDialog($scope.showAggConfirmDialog)
            .then(function () {
                TriggerWizardService.report('add-aggregation', {aggregationByType: type});
                $scope.tableApi.getPreviewData();
            })
            .catch(function () {
                $scope._clearTriggerIfCondition();
                $scope.tableApi.getPreviewData();
            });
    };

    $scope.clearTriggerIf = function (isCondition) {
        TriggerWizardService.report('clear-aggregation');
        isCondition ? $scope.triggerIfSelectedField.value = '' : $scope.scheduleTriggerIfSelectedField.value = '';
        $scope.tableApi.getPreviewData();
    };

    $scope.cancel = function () {
        TriggerWizardService.report('cancel');
        TriggerWizardService.clearData();
        $state.go($scope.triggerData.senderState);
    };

    function declareTriggerPageParameters() {
        //group by section
        $scope.aggGroupByFields = {
            0: {value: '', isShown: false},
            2: {value: '', isShown: false},
            1: {value: '', isShown: false}
        };

        //target section
        $scope.targetGroupButtonsData = {
            callback: function (value) {
                //adjust trigger according to the select action (for phase 1 - will be changed in phase 2)
                if (value === $scope.ALERT_NAME) {
                    $scope.triggerGroupButtonsData.uiData.value = $scope.CONDITION_NAME;
                    $scope.triggerGroupButtonsData.uiData.disabledBtnsList = [$scope.SCHEDULE_NAME];
                    $scope.formatGroupButtonsData.uiData.disabledBtnsList = '';
                }
                else if (value === $scope.CONTINUOUS_AGGREGATION_NAME) {
                    $scope.triggerGroupButtonsData.uiData.value = $scope.SCHEDULE_NAME;
                    $scope.triggerGroupButtonsData.uiData.disabledBtnsList = [$scope.CONDITION_NAME];

                    //phase 1 - continuous aggregation will include only JSON output format
                    $scope.formatGroupButtonsData.uiData.disabledBtnsList = [$scope.TABLE_FORMAT_NAME];
                    $scope.formatGroupButtonsData.uiData.value = $scope.triggerData.output.format.type = $scope.JSON_FORMAT_NAME;
                }
            },
            uiData: {
                data: [{
                    label: 'Alert',
                    value: $scope.ALERT_NAME
                }, {
                    label: 'Optimizer',
                    value: $scope.CONTINUOUS_AGGREGATION_NAME
                }],
                value: $scope.ALERT_NAME,
                disabledBtnsList: ''
            }
        };

        //alert(target)
        $scope.recipientsChosen = {data: []};
        $scope.suppressNotificationCounter = {value: 1};
        $scope.supressNotificationTime = 'day';
        $scope.suppressMinVal = 1;
        $scope.invalidSuppressionError = 0;

        $scope.suppressNotificationGroupButtonsData = {
            callback: function (value) {
                $scope.supressNotificationTime = value;
                $scope.suppressMinVal = 1;
                $scope.invalidSuppressionError = 0;

                if (value === 'minute') {
                    $scope.suppressMinVal = 5;

                    if ($scope.suppressNotificationCounter.value < $scope.suppressMinVal) {
                        $scope.suppressNotificationCounter.value = 5;
                        $scope.invalidSuppressionError = 1;
                    }
                }
            },
            uiData: {
                data: [{
                    label: 'Day',
                    value: 'day'
                }, {
                    label: 'Hour',
                    value: 'hour'
                }, {
                    label: 'Minute',
                    value: 'minute'
                }],
                value: 'hour'
            }
        };

        //CA(target)
        $scope.timelessIndexAppSelect = {
            model: '',
            changeCallback: function (value) {
                $scope.timelessIndexType = timelessIndexTypeMap[value];
                $scope.timelessIndexAppSelect.invalid = false;
            },
            options: []
        };

        //trigger section ---------------------------------------------------------
        $scope.triggerGroupButtonsData = {
            uiData: {
                data: [{
                    label: 'Condition',
                    value: $scope.CONDITION_NAME
                }, {
                    label: 'Schedule',
                    value: $scope.SCHEDULE_NAME
                }],
                value: $scope.CONDITION_NAME,
                disabledBtnsList: [$scope.SCHEDULE_NAME]
            }
        };

        //condition(trigger)
        $scope.triggerIfSelectedField = {value: ''};

        $scope.triggerIfAppSelect = {
            model: $scope.NONE_VALUE,
            changeCallback: function (value) {
                if (value === $scope.NONE_VALUE) {
                    $scope.clearTriggerIf(true);
                }
            },
            options: [{
                text: '# of events',
                value: $scope.NONE_VALUE
            }, {
                text: 'Minimum',
                value: 'MIN',
            }, {
                text: 'Maximum',
                value: 'MAX',
            }, {
                text: 'Average',
                value: 'AVG',
            }, {
                text: 'Sum',
                value: 'SUM',
            }]
        };

        $scope.triggerConditionAppSelect = {
            model: 'GREATER_THAN',
            options: [{
                text: 'Greater than',
                value: 'GREATER_THAN'
            }, {
                text: 'Greater than or equal to',
                value: 'GREATER_THAN_OR_EQUALS',
            }, {
                text: 'Less than',
                value: 'LESS_THAN',
            }, {
                text: 'Less than or equal to',
                value: 'LESS_THAN_OR_EQUALS',
            }, {
                text: 'Equal to',
                value: 'EQUALS',
            }, {
                text: 'Not equal to',
                value: 'NOT_EQUALS',
            }]
        };


        $scope.overPeriodCounter = {value: $scope.OVER_PERIOD_COUNTER};
        $scope.conditionOverPeriodMaxVal = {value: $scope.MAX_MINUTE_PERIOD_VALUE};
        $scope.conditionOverPeriodMinVal = {value: $scope.MIN_MINUTE_PERIOD_VALUE};
        $scope.conditionOverPeriodGroupButtonsData = {
            callback: function (value) {
                if (value === 'minute') {
                    $scope.conditionOverPeriodMaxVal.value = $scope.MAX_MINUTE_PERIOD_VALUE;
                    $scope.conditionOverPeriodMinVal.value = $scope.MIN_MINUTE_PERIOD_VALUE;
                }
                else {
                    $scope.conditionOverPeriodMaxVal.value = $scope.MAX_HOUR_PERIOD_VALUE;
                    $scope.conditionOverPeriodMinVal.value = $scope.MIN_HOUR_PERIOD_VALUE;
                }
            },
            uiData: {
                data: [{
                    label: 'Hour',
                    value: 'hour'
                }, {
                    label: 'Minute',
                    value: 'minute'
                }],
                value: 'minute'
            }
        };

        //schedule(trigger)
        var EVERY_1_HOUR = 'EVERY_1_HOUR';
        var EVERY_4_HOURS = 'EVERY_4_HOURS';
        var EVERY_6_HOURS = 'EVERY_6_HOURS';
        var EVERY_8_HOURS = 'EVERY_8_HOURS';
        var EVERY_1_DAY = 'EVERY_1_DAY';
        var EVERY_10_MINUTES = 'EVERY_10_MINUTES';
        var EVERY_30_MINUTES = 'EVERY_30_MINUTES';

        $scope.triggerOnceEveryAppSelect = {
            model: EVERY_1_HOUR,
            options: [{text: '1', value: EVERY_1_HOUR}, {text: '4', value: EVERY_4_HOURS}, {text: '6', value: EVERY_6_HOURS}, {text: '8', value: EVERY_8_HOURS}]
        };
        $scope.minutesOnceEveryOption = [{text: '10', value: EVERY_10_MINUTES}, {text: '30', value: EVERY_30_MINUTES}];
        $scope.hoursOnceEveryOption = [{text: '1', value: EVERY_1_HOUR}, {text: '4', value: EVERY_4_HOURS}, {text: '6', value: EVERY_6_HOURS}, {text: '8', value: EVERY_8_HOURS}];
        $scope.daysOnceEveryOption = [{text: '1', value: EVERY_1_DAY}];

        $scope.triggerOnceEveryGroupButtonsData = {
            callback: function (value) {
                changeTriggerOnceEverySelectOptions(value);
            },
            uiData: {
                data: [{
                    label: 'Day',
                    value: 'day'
                }, {
                    label: 'Hour',
                    value: 'hour'
                }, {
                    label: 'Minute',
                    value: 'minute'
                }],
                value: 'hour'
            }
        };

        $scope.scheduleTriggerIfSelectedField = {value: ''};

        $scope.scheduleTriggerIfAppSelect = {
            model: $scope.NULL_VALUE,
            changeCallback: function (value) {
                if ($scope.isGroupByValuesEmpty() && value === $scope.NULL_VALUE) {
                    $scope.scheduleTriggerIfAppSelect.invalid = true;
                }
                else {
                    $scope.scheduleTriggerIfAppSelect.invalid = false;
                }

                if (value === $scope.NULL_VALUE || value === $scope.COUNT_VALUE) {
                    $scope.clearTriggerIf(false);
                }
            },
            options: [{
                text: 'No Aggregation',
                value: $scope.NULL_VALUE,
            }, {
                text: '# of events',
                value: $scope.COUNT_VALUE,
            }, {
                text: 'Minimum',
                value: 'MIN',
            }, {
                text: 'Maximum',
                value: 'MAX',
            }, {
                text: 'Average',
                value: 'AVG',
            }, {
                text: 'Sum',
                value: 'SUM',
            }]
        };

        //format section ---------------------------------------------------------
        $scope.formatGroupButtonsData = {
            callback: function (value) {
                $scope.triggerData.output.format.type = value;
            },
            uiData: {
                data: [{
                    label: 'Default format',
                    value: $scope.JSON_FORMAT_NAME
                }, {
                    label: 'Custom format',
                    value: $scope.TABLE_FORMAT_NAME
                }],
                value: $scope.JSON_FORMAT_NAME,
                disabledBtnsList: ''
            }
        };
    }

    function parseEnumToTimeUnitAndAmount(enumValue) {
        if (enumValue.includes('MINUTE')) {
            $scope.triggerOnceEveryAppSelect.options = $scope.minutesOnceEveryOption;
            $scope.triggerOnceEveryGroupButtonsData.uiData.value = 'minute';
        }
        else if (enumValue.includes('DAY')) {
            $scope.triggerOnceEveryAppSelect.options = $scope.daysOnceEveryOption;
            $scope.triggerOnceEveryGroupButtonsData.uiData.value = 'day';
        }
        else {
            $scope.triggerOnceEveryAppSelect.options = $scope.hoursOnceEveryOption;
            $scope.triggerOnceEveryGroupButtonsData.uiData.value = 'hour';
        }
        $scope.triggerOnceEveryAppSelect.model = enumValue;
    }

    $scope.isGroupByContainerEmpty = function () {
        return _.find($scope.aggGroupByFields, 'isShown');
    };

    $scope.isGroupByValuesEmpty = function () {
        return _.find($scope.aggGroupByFields, 'value');
    };

    function getTimelessIndicesAndTypes() {
        $scope.timelessIndexAppSelectDisabled = true;
        TriggerWizardService.getTimelessIndicesAndTypes().then(function (res) {
            if (!_.size(res[0])) {
                $scope.targetGroupButtonsData.uiData.disabledBtnsList = [$scope.CONTINUOUS_AGGREGATION_NAME];
                $scope.continuousAggregationDisabled = true;
                return;
            }

            $scope.timelessIndexAppSelectDisabled = false;

            $scope.timelessIndexAppSelect.options = res[0];
            timelessIndexTypeMap = res[1];
        });
    }

    function convertToMinutes(timeUnit, timeAmount) {
        if (timeUnit === 'hour') {
            return timeAmount * 60;
        }
        else if (timeUnit === 'day') {
            return timeAmount * 60 * 24;
        }
        return timeAmount;
    }

    function modifyTriggerOnceEveryOptions(options) {
        $scope.triggerOnceEveryAppSelect.options.length = 0;

        options.forEach(function (val) {
            $scope.triggerOnceEveryAppSelect.options.push(val);
        });
        $scope.triggerOnceEveryAppSelect.model = $scope.triggerOnceEveryAppSelect.options[0].value;
    }

    function changeTriggerOnceEverySelectOptions(trigger) {
        if (trigger === 'minute') {
            modifyTriggerOnceEveryOptions($scope.minutesOnceEveryOption);
        }
        else if (trigger === 'hour') {
            modifyTriggerOnceEveryOptions($scope.hoursOnceEveryOption);
        }
        else {
            modifyTriggerOnceEveryOptions($scope.daysOnceEveryOption);
        }
    }

    function parseDataFromServer() {
        var emailNotifications = $scope.triggerData.output.target.emailNotifications;
        $scope.triggerData.output.target.emailNotifications = JSON.parse(!_.isString(emailNotifications) ? JSON.stringify(emailNotifications) : emailNotifications);

        if (_.isString($scope.triggerData.search.filter)) {
            $scope.triggerData.search.filter = JSON.parse($scope.triggerData.search.filter);
        }

        var aggType = _.get($scope.triggerData.triggerOn.aggregation, 'aggregationType', $scope.NONE_VALUE);
        $scope.triggerIfAppSelect.model = (aggType === $scope.COUNT_VALUE ? $scope.NONE_VALUE : aggType);//server return COUNT when there is group by without aggregation -> need to be translated to NONE in UI

        var aggTypeAll = _.get($scope.triggerData.search.metricsAggregations[0], 'aggregationType', $scope.NULL_VALUE);
        $scope.scheduleTriggerIfAppSelect.model = aggTypeAll;
        $scope.scheduleTriggerIfSelectedField.value = _.get($scope.triggerData.search.metricsAggregations[0], 'fieldToAggregateOn', '');

        $scope.formatGroupButtonsData.uiData.value = _.get($scope.triggerData.output.format, 'type', $scope.JSON_FORMAT_NAME);
        $scope.triggerConditionAppSelect.model = _.get($scope.triggerData.triggerOn, 'comparisonOperator', 'GREATER_THAN');
        $scope.triggerIfSelectedField.value = _.get($scope.triggerData.triggerOn.aggregation, 'fieldToAggregateOn', '');

        if (!$scope.triggerData.output.format) {
            $scope.triggerData.output.format = {type: $scope.JSON_FORMAT_NAME};
        }
        $scope.triggerTypeOnEdit = _.get($scope.triggerData, 'triggerType', $scope.ALERT_NAME);
        $scope.targetGroupButtonsData.uiData.value = $scope.triggerTypeOnEdit;
        $scope.targetGroupButtonsData.callback($scope.targetGroupButtonsData.uiData.value);
        $scope.targetGroupButtonsData.uiData.disabledBtnsList = $scope.triggerTypeOnEdit === $scope.ALERT_NAME ? [$scope.CONTINUOUS_AGGREGATION_NAME] : [$scope.ALERT_NAME];

        $scope.timelessIndexAppSelect.model = _.get($scope.triggerData.output.target.timelessIndex, 'id', '');
        $scope.timelessIndexType = _.get($scope.triggerData.output.target.timelessIndex, 'logType', '');

        _.forEach($scope.triggerData.search.groupBy, function (value, index) {
            $scope.aggGroupByFields[index].value = value;
            $scope.aggGroupByFields[index].isShown = true;
        });

        parseEnumToTimeUnitAndAmount(_.get($scope.triggerData.triggerOn, 'frequency', $scope.hoursOnceEveryOption));
        TriggerWizardService.parseMinutesToTimeUnitAndAmount($scope.triggerData.output.target.suppressNotificationInMinutes, $scope.suppressNotificationGroupButtonsData.uiData, $scope.suppressNotificationCounter);
        TriggerWizardService.parseMinutesToTimeUnitAndAmount($scope.triggerData.search.periodInMinutes, $scope.conditionOverPeriodGroupButtonsData.uiData, $scope.overPeriodCounter);
        $scope.conditionOverPeriodGroupButtonsData.callback($scope.conditionOverPeriodGroupButtonsData.uiData.value);
    }

    function initTriggerDataModel() {
        var defaults = {
            name: '',
            description: '',
            search: {
                periodInMinutes: '',
                metricsAggregations: [{}], //list of object as preparation for multiple aggregation metrics (in server)
                source: { // todo - source (targetIndices)
                    allTimelessIndices: false,
                    timelessIndice: [],
                    allSubAccountsIndices: true,
                    subAccountsIds: []
                }
            },
            triggerOn: {
                aggregation: {},
                threshold: 0
            },
            output: {
                format: {type: $scope.JSON_FORMAT_NAME},
                target: {
                    severity: 'MEDIUM',
                    emailNotifications: {'notifications': []},
                    notificationEndpoints: []
                }
            }
        };
        $scope.triggerData = _.defaultsDeep($scope.triggerData, defaults);

        if ($scope.createTriggerMode) parseDataFromServer();
    }

    $scope.fetchTriggerData = function () {
        var calculatedTriggerData = {
            search: {
                groupBy: TriggerWizardService.getGroupByFieldsList($scope.aggGroupByFields),
                periodInMinutes: convertToMinutes($scope.conditionOverPeriodGroupButtonsData.uiData.value, $scope.overPeriodCounter.value),
                metricsAggregations: [{}]
            },
            triggerOn: {
                type: $scope.triggerGroupButtonsData.uiData.value,
                aggregation: {}
            },
            output: {
                target: {
                    emailNotifications: {'notifications': []},
                    notificationEndpoints: [],
                    suppressNotificationInMinutes: convertToMinutes($scope.suppressNotificationGroupButtonsData.uiData.value, $scope.suppressNotificationCounter.value),
                    timelessIndex: {
                        id: $scope.timelessIndexAppSelect.model,
                        logType: $scope.timelessIndexType
                    }
                },
                format: {}
            }
        };

        if (calculatedTriggerData.triggerOn.type === $scope.CONDITION_NAME) {
            calculatedTriggerData.triggerOn.aggregation.aggregationType = $scope.triggerIfAppSelect.model;
            calculatedTriggerData.triggerOn.aggregation.fieldToAggregateOn = $scope.triggerIfSelectedField.value || null;
            calculatedTriggerData.triggerOn.comparisonOperator = $scope.triggerConditionAppSelect.model;
        }
        else {//SCHEDULE
            calculatedTriggerData.triggerOn.frequency = $scope.triggerOnceEveryAppSelect.model;
            calculatedTriggerData.search.metricsAggregations[0].aggregationType = $scope.scheduleTriggerIfAppSelect.model;
            calculatedTriggerData.search.metricsAggregations[0].fieldToAggregateOn = $scope.scheduleTriggerIfSelectedField.value || null;
        }

        $scope.triggerData = _.merge($scope.triggerData, calculatedTriggerData);
        !_.size(calculatedTriggerData.search.groupBy) ? $scope.triggerData.search.groupBy = [] : $scope.triggerData.search.groupBy;

        $scope.triggerData.output.target.notificationEndpoints = TriggerWizardService.setNotificationEndpointsAndEmails($scope.recipientsChosen.data)[0];
        $scope.triggerData.output.target.emailNotifications.notifications = TriggerWizardService.setNotificationEndpointsAndEmails($scope.recipientsChosen.data)[1];
        $scope.showAggConfirmDialog = $scope.formatGroupButtonsData.uiData.value === $scope.TABLE_FORMAT_NAME && !!_.size($scope.triggerData.output.format.fieldsConfig);
    };

    $scope.aggGroupBysMapToPlace = {
        0: 'aggGroupByFields.first',
        1: 'aggGroupByFields.second',
        2: 'aggGroupByFields.third'
    };

    $scope.setValidityRequiredOnGroupByAndAggregationfields = function (duplicatedTriggerIfKey, triggerIfFormName, triggerIfFormNameValue) {
        var duplicatedTriggerIfName = $scope.aggGroupBysMapToPlace[duplicatedTriggerIfKey];

        if (duplicatedTriggerIfName && $scope.triggerForm.groupByForm[duplicatedTriggerIfName] && triggerIfFormNameValue !== '') {
            $scope.triggerForm.groupByForm[duplicatedTriggerIfName].$setValidity('required', false);
            $scope.triggerForm[triggerIfFormName].$setValidity('required', false);
        }
        else {
            _.forEach($scope.aggGroupBysMapToPlace, function (value) {
                $scope.triggerForm.groupByForm[value].$setValidity('required', true);
            });
            $scope.triggerForm[triggerIfFormName].$setValidity('required', true);
        }
    };

    $scope.handleDuplicateAggregationAndGroupByFields = function () {
        var duplicatedTriggerIf = _.findKey($scope.aggGroupByFields, ['value', $scope.triggerIfSelectedField.value]);
        var duplicatedScheduleTriggerIf = _.findKey($scope.aggGroupByFields, ['value', $scope.scheduleTriggerIfSelectedField.value]);

        if ($scope.targetGroupButtonsData.uiData.value === $scope.ALERT_NAME) {
            $scope.setValidityRequiredOnGroupByAndAggregationfields(duplicatedTriggerIf, 'triggerIfSelectedField', $scope.triggerIfSelectedField.value);
        }
        else {
            $scope.setValidityRequiredOnGroupByAndAggregationfields(duplicatedScheduleTriggerIf, 'scheduleTriggerIfSelectedField', $scope.scheduleTriggerIfSelectedField.value);
        }
    };

    function isOptimizerTriggerType() {
        return $scope.targetGroupButtonsData.uiData.value === $scope.CONTINUOUS_AGGREGATION_NAME;
    }

    function manageFormValidity() {
        //handle invalid form fields
        $scope.triggerForm['triggerName'].$setTouched();
        if ($scope.triggerForm['triggerName'].$invalid) {
            Focus('triggerName');
        }

        if ($scope.triggerForm['triggerIfSelectedField']) {
            $scope.triggerForm['triggerIfSelectedField'].$setValidity('required', !($scope.triggerIfAppSelect.model !== $scope.NONE_VALUE && !$scope.triggerIfSelectedField.value));
        }
        if ($scope.triggerForm['scheduleTriggerIfSelectedField']) {
            $scope.triggerForm['scheduleTriggerIfSelectedField'].$setValidity('required', !(($scope.scheduleTriggerIfAppSelect.model !== $scope.COUNT_VALUE && $scope.scheduleTriggerIfAppSelect.model !== $scope.NULL_VALUE) && !$scope.scheduleTriggerIfSelectedField.value));
        }
        if ($scope.triggerForm.tableForm['outputTableFields']) {
            $scope.triggerForm.tableForm['outputTableFields'].$setValidity('required', !($scope.formatGroupButtonsData.uiData.value === $scope.TABLE_FORMAT_NAME && !_.size($scope.triggerData.output.format.fieldsConfig)));
        }
        if ($scope.triggerForm['scheduleTriggerIfAppSelect']) {
            $scope.triggerForm['scheduleTriggerIfAppSelect'].$setValidity('required', !($scope.isGroupByValuesEmpty() && $scope.scheduleTriggerIfAppSelect.model === $scope.NULL_VALUE));
            $scope.scheduleTriggerIfAppSelect.invalid = !!$scope.triggerForm['scheduleTriggerIfAppSelect'].$invalid;
        }

        if ($scope.triggerForm['timelessIndexAppSelect']) {
            if ($scope.timelessIndexAppSelect.model === '' && isOptimizerTriggerType()) {
                $scope.timelessIndexAppSelect.invalid = true;
                $scope.triggerForm['timelessIndexAppSelect'].$setValidity('required', false);
            }
            else {
                $scope.timelessIndexAppSelect.invalid = false;
                $scope.triggerForm['timelessIndexAppSelect'].$setValidity('required', true);
            }
        }
        //handle validity when group by and aggregation use the same field
        $scope.handleDuplicateAggregationAndGroupByFields();
    }

    $scope.submitTrigger = function () {

        manageFormValidity();
        if (!$scope.triggerForm.$valid) {
            return;
        }

        $scope.fetchTriggerData();

        $scope.triggerSubmitted = true;

        TriggerWizardService.submitTrigger($scope.triggerData, $scope.targetGroupButtonsData.uiData.value)
            .then(function () {
                TriggerWizardService.openTriggerSavedDialog($scope.triggerData, isOptimizerTriggerType());
            })
            .catch(function(error){
                var errorMessage = error.data ?
                    'Error: ' + error.data.message :
                    'There was an error, please contact support';

                LogzToast.error(errorMessage, false);

                TriggerWizardService.report('submit-failed');
                $scope.triggerSubmitted = false;
            });
    };
});
/* eslint-disable max-lines */

/* origin: public/webapp/app/dashboard/alerts/alerts-menu-controller.js */
angular.module('webApp').controller('AlertMenuController', function ($scope, $state, FeatureFlagService, AuthService, $q) {

    $scope.pages = [{
        title: 'Alert Definitions',
        state: 'dashboard.alerts.definitions',
    }, {
        title: 'Triggered Alerts',
        state: 'dashboard.alerts.triggered',
    }, {
        title: 'Alert Endpoints',
        state: 'dashboard.alerts.endpoints',
    }];

    $q.all({
        isFeatureEnabled: FeatureFlagService.isFeatureEnabled('continuous-aggregation'),
        isAdmin: AuthService.isAdminRole(),
    }).then(function (res) {
        if(res.isFeatureEnabled && res.isAdmin){
            $scope.pages.splice(1, 0, {
                title: 'Optimizer definitions',
                state: 'dashboard.alerts.continuous',
            });
        }
    });

    $scope.goToPage = function (state) {
        $state.go(state);
    };
});
/* origin: public/webapp/app/dashboard/alerts/alerts-menu.js */
angular.module('webApp').directive('alertsMenu', [function () {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/alerts/alerts-menu.html',
        scope: {
            pageTitle: '@',
        },
        controller: 'AlertMenuController'
    };
}]);
/* origin: public/webapp/app/dashboard/alerts/email-tag/logzio-email-tag.js */
angular.module('webApp').directive('logzioEmailTag', [function() {

    var html = '<div class="email-tag">' +
        '<span class="prefix">{{emailPrefix}}</span>' +
        '<span class="suffix">{{emailSuffix}}</span>' +
        '<span ng-if="deletable" class="email-tag-x" ng-click="onDelete()">' +
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 9.67 9.58"><defs></defs><title>Asset 1</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><line class="tag" x1="8.82" y1="8.73" x2="0.85" y2="0.85"/><line class="tag" x1="0.85" y1="8.73" x2="8.82" y2="0.85"/></g></g></svg>' +
        '</span>' +
        '</div>';

    return {
        restrict: 'E',
        template: html,
        scope: {
            email: '=',
            deletable: '@?',
            onDelete: '&?'
        },
        link: function(scope) {
            scope.emailPrefix = scope.deletable
                ? scope.email
                : scope.email.substr(0, scope.email.indexOf('@'));
            scope.emailSuffix = scope.deletable
                ? ''
                : scope.email.substr(scope.email.indexOf('@'));
        }
    };

}]);
/* origin: public/webapp/app/dashboard/alerts/notification-endpoints-controller.js */
angular.module('webApp').controller('NotificationEndpointsController', function($scope, ngDialog, ConfirmService, NotificationEndpointService, AnalyticsService) {

    $scope.loadingPage = true;

    NotificationEndpointService.getAllNotificationEndpoints().then(function (response) {
        $scope.notificationEndpoints = response.data;
        $scope.loadingPage = false;
    });

    var initDialogProperties = function () {
        var dialogProperties = {
            template: 'directives/alert-webhooks/upsert-notification-endpoint.html',
            controller: 'UpsertNotificationEndpointController',
            width: '765px',
            showClose: false
        };

        var dialogScope = $scope.$new();
        dialogScope.notificationEndpoints = $scope.notificationEndpoints;
        dialogProperties.scope = dialogScope;

        return dialogProperties;
    };

    $scope.createNotificationEndpoint = function () {
        ngDialog.open(initDialogProperties());
    };

    $scope.editNotificationEndpoint = function (notificationEndpoint) {
        var editDialogProperties = initDialogProperties();
        editDialogProperties.scope.notificationEndpointToEdit = notificationEndpoint;
        ngDialog.open(editDialogProperties);
    };

    $scope.deleteNotificationEndpoint = function (notificationEndpoint) {
        var notificationEndpointIndexFound = _.findIndex($scope.notificationEndpoints, { 'id': notificationEndpoint.id });
        if (notificationEndpointIndexFound !== -1) {
            $scope.notificationEndpoints.splice(notificationEndpointIndexFound, 1);
        }
        NotificationEndpointService.deleteNotificationEndpoint(notificationEndpoint).then(function () {
            AnalyticsService.report('alerts:delete-notification-endpoint', {
                category: 'alerts',
                endPoint: notificationEndpoint.templateName
            });
        });
    };
});

/* origin: public/webapp/app/dashboard/alerts/triggered-alerts-list/triggered-alerts-list.js */
/* eslint-disable */
angular.module('webApp').directive('triggeredAlertsList', function ($state, ngDialog, Backend, AuthService, dateService, TriggerWizardService, AlertWizardService, kibanaNavigator, AnalyticsService, FeatureFlagService) {

    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/alerts/triggered-alerts-list/triggered-alerts-list.html',
        scope: {
            triggeredAlerts: '=',
            showDate: '=',
            severityFiter: '='
        },
        link: function (scope) {

            var numPadLeft = function (num) {
                return ((num < 10) ? '0' : '') + num;
            };

            var friendlyDate = function (timestamp) {
                var time = new Date(timestamp);

                var friendlyDate = '';

                if (scope.showDate)
                    friendlyDate += time.getDate() + '/' + (time.getMonth() + 1) + '/' + time.getFullYear().toString().substr(2) + ' ';

                friendlyDate += numPadLeft(time.getHours()) + ':' + numPadLeft(time.getMinutes()) + ':' + numPadLeft(time.getSeconds());

                return friendlyDate;
            };

            var triggeredAlertsWatcher = scope.$watch('triggeredAlerts', function () {
                if (!scope.triggeredAlerts)
                    return;

                var count = 1;
                for (var i = scope.triggeredAlerts.length - 1; i >= 0; i--) {
                    if (i != 0 && scope.triggeredAlerts[i].alertDefinitionId == scope.triggeredAlerts[i - 1].alertDefinitionId) {
                        scope.triggeredAlerts[i].collapsed = true;
                        count++;
                    }
                    else {
                        if (count > 1) {
                            scope.triggeredAlerts[i].count = count;
                        }
                        count = 1;
                    }

                    scope.triggeredAlerts[i].friendlyTimestamp = friendlyDate(scope.triggeredAlerts[i].eventTimestamp);
                }

                scope.triggeredAlerts = scope.triggeredAlerts.sort(function (a, b) {
                    return b.eventTimestamp - a.eventTimestamp;
                });
            });

            scope.openDuplicates = function (index, count) {
                for (var i = index; i < index + count; i++) {
                    scope.triggeredAlerts[i].collapsed = false;
                }
                scope.triggeredAlerts[index].count = 0;
            };

            function openDialogOnEditAlertError(){
                ngDialog.open({
                    template: '<p style="padding: 5px;">We could not edit this alert definition, this might indicate that the alert has been deleted</p>',
                    width: '662px',
                    plain: true,
                    showClose: false
                });
            };

            scope.editAlert = function (alertId) {
                FeatureFlagService.isFeatureEnabled('continuous-aggregation').then(function (continuousAggregationEnabled) {
                    if(continuousAggregationEnabled){
                        TriggerWizardService.getTriggerDataById(alertId, 'alerts/').then(function(res){
                            if (res.data && res.data.code && res.data.code === 500) {
                                AnalyticsService.report('triggers:edit-alert-error', {
                                    category: 'triggers',
                                    triggerId: alertId
                                });
                                openDialogOnEditAlertError();
                            }
                            else{
                                AnalyticsService.report('triggers:edit-alert', {
                                    category: 'triggers',
                                    triggerId: alertId
                                });

                                TriggerWizardService.storeDataAndOpenWizard(res.data, 'ALERT');
                            }
                        });
                    }
                    else{
                        Backend.GET('/alerts/' + alertId).then(function (res) {
                            if (res.data && res.data.code && res.data.code === 500) {
                                AnalyticsService.report('alerts:edit-alert-error', {
                                    category: 'alerts',
                                    alertId: alertId
                                });
                                openDialogOnEditAlertError();
                            }
                            else {
                                var alertDefinition = res.data.alertDefinition;
                                alertDefinition.filter = JSON.parse(alertDefinition.filter);
                                alertDefinition.notifications = JSON.parse(alertDefinition.notifications);
                                var editAlertData = {
                                    alertDefinition: alertDefinition,
                                    alertNotificationEndpoints: res.data.alertNotificationEndpoints,
                                };
                                AnalyticsService.report('alerts:edit-alert', {
                                    category: 'alerts',
                                    alertId: alertId
                                });
                                AlertWizardService.storeDataAndOpenWizard(editAlertData);
                            }
                        });
                    }
                });
            };

            scope.viewTriggeredAlertEvents = function (triggeredAlert) {
                AlertWizardService.viewTriggeredAlertEvents(triggeredAlert.eventTimestamp,
                    triggeredAlert.timeRangeInMinutes, triggeredAlert.alertDefinitionId, true);
            };

            scope.$on('$destroy', function () {
                if (triggeredAlertsWatcher) triggeredAlertsWatcher();
            });

        }
    };

});
/* eslint-enable */
/* origin: public/webapp/app/dashboard/alerts/triggers/active-triggers-counter-service.js */
angular.module('webApp').service('ActiveTriggersCounterService', function($q, UpgradeService) {

    var self = this;

    var countValue = 0;

    self.addEnabledTrigger = function() {
        countValue++;
    };

    self.removeDisabledTrigger = function() {
        countValue--;
    };

    self.count = function() {
        return countValue;
    };

    self.toggleTrigger = function(triggerEnabled) {
        var d = $q.defer();

        if (!triggerEnabled) { // User may always disable an alert
            self.removeDisabledTrigger();
            d.resolve(triggerEnabled);
            return d.promise;
        }

        UpgradeService.getPlanDetails().then(function (planDetails) {
            var amountOfEnabledAlerts = self.count();
            var maxAlerts = planDetails.data.maxAlertsDefinition;

            if (maxAlerts === 0) {
                d.reject(true);
            }
            else if (amountOfEnabledAlerts >= maxAlerts) {
                d.reject(false);
            }
            else {
                self.addEnabledTrigger();
                d.resolve(triggerEnabled);
            }
        });

        return d.promise;
    };
});

/* origin: public/webapp/app/dashboard/alerts/triggers/trigger-frequency-text.const.js */
angular.module('webApp').constant('TRIGGER_FREQ_MAP', {
    'EVERY_1_DAY': 'Every 1 day',
    'EVERY_2_DAYS': 'Every 2 days',
    'EVERY_1_HOUR': 'Every 1 hour',
    'EVERY_4_HOURS': 'Every 4 hours',
    'EVERY_6_HOURS': 'Every 6 hours',
    'EVERY_8_HOURS': 'Every 8 hours',
    'EVERY_1_MINUTE': 'Every 1 minute',
    'EVERY_5_MINUTES': 'Every 5 minutes',
    'EVERY_10_MINUTES': 'Every 10 minutes',
    'EVERY_30_MINUTES': 'Every 30 minutes'
});

/* origin: public/webapp/app/dashboard/alerts/triggers/trigger-item-controller.js */
angular.module('webApp').controller('TriggerItemController', function ($timeout, $q, ngDialog, Backend, UpgradeService, ConfirmService, LabsService, AlertWizardService, TriggerWizardService, AnalyticsService, TRIGGER_FREQ_MAP, ActiveTriggersCounterService, $scope, $element) {

    var vm = this;

    vm.openTrigger = openTrigger;
    vm.toggleTrigger = toggleTrigger;
    vm.deleteAlert = deleteAlert;
    vm.$onInit = $onInit;

    function $onInit(){
        if(vm.triggerData.enabled){
            // update the count of the current active triggers in order to check the quota of active triggers/alerts the account has
            ActiveTriggersCounterService.addEnabledTrigger();
        }
        vm.frequency = TRIGGER_FREQ_MAP[vm.triggerData.triggerOn.frequency];
    }

    function openTrigger() {
        AnalyticsService.report('triggers:open-trigger', { category: 'triggers', triggerId: vm.triggerData.id });
        TriggerWizardService.storeDataAndOpenWizard(vm.triggerData, 'CONTINUOUS_AGGREGATION');
    }

    function toggleTrigger(triggerEnabled) {
        // we should try first in order to make sure the user didn't exceed his max enabled triggers/alerts
        ActiveTriggersCounterService.toggleTrigger(triggerEnabled)
            .then(updateTriggerData)
            .catch(function (failedDueToFreePlan) {
                AnalyticsService.report('triggers:failed-enable-disable', { category: 'triggers', triggerId: vm.triggerData.id });

                vm.triggerData.enabled = false;

                if (failedDueToFreePlan) {
                    UpgradeService.showAlertsNotAvailableForPlanDialog();
                }
                else {
                    UpgradeService.showAlertDisabledDialog(false, false);
                }
            });
    }

    function updateTriggerData(triggerEnabled) {

        if(vm.requestInProggress){
            return;
        }

        var triggerId = vm.triggerData.id;

        var triggerUpdateData = _.cloneDeep(vm.triggerData);

        // should be updated already, but lets decouple this method from the toggle component
        triggerUpdateData.enabled = triggerEnabled;

        vm.requestInProggress = true;

        Backend.PUT('/triggers/' + triggerId, triggerUpdateData).then(function(response){
            AnalyticsService.report('triggers:disable-enable', { category: 'triggers', triggerId: triggerId, enabled: triggerEnabled });
            vm.triggerData = response.data;
        }).catch(function (error) {
            vm.triggerData.enabled = !triggerEnabled;

            if(error.status === 500) {
                alert('Failed to ' + (triggerEnabled ? 'enable' : 'disable') + ' trigger.\n Please refresh and try again.');
            }
            else {
                // This means new alert(s) been created / enabled since the user session loaded the view alerts page
                // and he exceeded his max enabled alerts by plan, we will show the upgrade service alert disabled dialog
                ActiveTriggersCounterService.removeDisabledTrigger();
                UpgradeService.showAlertDisabledDialog(false, false);
            }
        }).finally(function(){
            vm.requestInProggress = false;
        });
    }

    // TODO: rename to deleteTrigger after the alert definitions view is removed, here and in the deleteAlertDialog
    function deleteAlert() {
        var triggerId = vm.triggerData.id;
        vm.destroyed = true;

        if(vm.triggerData.enabled){
            // remove it from the active count service
            ActiveTriggersCounterService.removeDisabledTrigger();
        }

        Backend.DELETE('/triggers/' + triggerId).then(function () {
            AnalyticsService.report('triggers:delete', { category: 'triggers', triggerId: triggerId });
            $timeout(function() {
                $scope.$destroy();
                $element.empty();
            }, 1000);
        }).catch(function() {
            AnalyticsService.report('triggers:delete-error', { category: 'triggers', triggerId: triggerId });
            alert('Failed to delete trigger.\nThis might indicate that the trigger was deleted already.\n Please refresh and try again.');
            vm.destroyed = false;
            if(vm.triggerData.enabled) {
                ActiveTriggersCounterService.addEnabledTrigger();
            }
        });
    }
});
/* origin: public/webapp/app/dashboard/alerts/triggers/trigger-item.js */
angular.module('webApp').component('triggerItem', {
    templateUrl: 'app/dashboard/alerts/triggers/trigger-item.html',
    controller: 'TriggerItemController',
    controllerAs: 'vm',
    bindings: {
        triggerData: '='
    }
});
/* origin: public/webapp/app/dashboard/alerts/triggers/view-triggers-controller.js */
angular.module('webApp').controller('ViewTriggersController', function (Backend) {

    var vm = this;

    vm.loadingTriggers = true;
    vm.triggers = [];

    Backend.GET('/triggers').then(function(response) {
        vm.loadingTriggers = false;

        if (!response.data || !response.data.length) {
            return;
        }

        vm.triggers = response.data;
    });
});
/* origin: public/webapp/app/dashboard/alerts/view-alerts-controller.js */
angular.module('webApp').controller('ViewAlertsController', function ($rootScope, $scope, $timeout, ngDialog, Backend, DelayChunkLoader) {

    $scope.loadingAlerts = true;
    $scope.alerts = [];
    $scope.emptyDueToFilter = false;

    var totalAmountOfEnabledAlerts = 0;
    var getAmountOfEnabledAlerts = function () {
        // Use this as a function instead of passing the number as a field in alertData to the directives because this number may change using increaseDecreaseAmountOfEnabledAlerts()
        return totalAmountOfEnabledAlerts;
    };

    var increaseDecreaseAmountOfEnabledAlerts = function (alertEnabled) {
        totalAmountOfEnabledAlerts += alertEnabled ? 1 : -1;
    };

    Backend.GET('/alerts/all').then(function (response) {
        if (!response.data || !response.data.length) {
            $scope.loadingAlerts = false;
            return;
        }

        totalAmountOfEnabledAlerts = _.filter(response.data, function (alertData) { return alertData.alertDefinition.enabled; }).length;
        var alertsReceived = response.data.map(function (alertData) {
            return {
                alertDefinition: alertData.alertDefinition,
                alertNotificationEndpoints: alertData.alertNotificationEndpoints,
                alertOutputTemplate: alertData.alertOutputTemplate,
                notificationsObj: angular.fromJson(alertData.alertDefinition.notifications),
                getAmountOfEnabledAlerts: getAmountOfEnabledAlerts,
                increaseDecreaseAmountOfEnabledAlerts: increaseDecreaseAmountOfEnabledAlerts
            };
        });
        alertsReceived = _.sortBy(alertsReceived, 'alertDefinition.title');

        DelayChunkLoader($scope.alerts, alertsReceived, 5, 500);
        $scope.loadingAlerts = false;
    });

    var severityFilterWatcher = $scope.$watch('severityFiter', function () {
        if (!$scope.severityFiter) {
            $scope.emptyDueToFilter = false;
            return;
        }

        $scope.emptyDueToFilter = _.findIndex($scope.alerts, function (alert) { return alert.alertDefinition.severity === $scope.severityFiter; }) === -1;
    });

    $scope.$on('$destroy', function () {
        if (severityFilterWatcher) severityFilterWatcher();
    });
});
/* origin: public/webapp/app/dashboard/alerts/view-triggered-alerts-controller.js */
angular.module('webApp').controller('ViewTriggeredAlertsController', function ($scope, Backend) {

    $scope.loadingPage = true;
    $scope.notFilteredTriggeredAlerts = {};
    $scope.triggeredAlerts = {};
    $scope.emptyDueToFilter = false;
    var previousLoadedAlerts = {'Today': [], 'Yesterday': [], 'Older': []};
    var groups = ['Today', 'Yesterday', 'Older'];
    $scope.emptyDueToEndOfData = false;

    $scope.pageSize = 20;
    var startPage = 0;

    var filterAlerts = function () {

        if (!$scope.severityFiter) {
            $scope.triggeredAlerts = $scope.notFilteredTriggeredAlerts;
            $scope.emptyDueToFilter = false;
            return;
        }

        $scope.triggeredAlerts = {};

        _.forEach(groups, function (group) {
            $scope.triggeredAlerts[group] = _.filter($scope.notFilteredTriggeredAlerts[group], function (triggeredAlert) {
                return triggeredAlert.severity === $scope.severityFiter;
            });
        });
        $scope.emptyDueToFilter = !$scope.triggeredAlerts['Today'].length && !$scope.triggeredAlerts['Yesterday'].length && !$scope.triggeredAlerts['Older'].length;
    };

    var loadAlerts = function () {

        //define defaults
        startPage = startPage || 0;
        previousLoadedAlerts = previousLoadedAlerts || {'Today': [], 'Yesterday': [], 'Older': []};

        $scope.isGettingAlertEvents = true;
        Backend.POST('/get-alert-events', {
            from: startPage,
            size: $scope.pageSize
        }).then(function (res) {
            if (!res.data || res.data === '') {
                $scope.empty = true;
                return;
            }
            var rawEvents = res.data;

            // organize into groups
            $scope.notFilteredTriggeredAlerts = {'Today': [], 'Yesterday': [], 'Older': []};

            var now = new Date();
            var today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            var yesterday = (new Date(today)).setDate(today.getDate() - 1);

            for (var i = 0; i < rawEvents.length; i++) {
                if (rawEvents[i].eventTimestamp >= today) {
                    $scope.notFilteredTriggeredAlerts.Today.push(rawEvents[i]);
                }
                else if (rawEvents[i].eventTimestamp >= yesterday) {
                    $scope.notFilteredTriggeredAlerts.Yesterday.push(rawEvents[i]);
                }
                else {
                    $scope.notFilteredTriggeredAlerts.Older.push(rawEvents[i]);
                }
            }
            filterAlerts();

            //concat current alerts data to the new data by time frames
            groups.forEach(function (item) {
                $scope.triggeredAlerts[item] = (previousLoadedAlerts[item]).concat($scope.triggeredAlerts[item]);
            });

            $scope.empty = !$scope.notFilteredTriggeredAlerts.Today.length && !$scope.notFilteredTriggeredAlerts.Yesterday.length && !$scope.notFilteredTriggeredAlerts.Older.length;
            $scope.emptyDueToEndOfData = true;
        }).finally(function () {
            $scope.loadingPage = false;
        });
    };

    $scope.loadMoreTriggeredAlerts = function () {
        startPage += $scope.pageSize;

        //save the current alerts data by time frames
        previousLoadedAlerts = {'Today': [], 'Yesterday': [], 'Older': []};
        groups.forEach(function (item) {
            previousLoadedAlerts[item] = $scope.triggeredAlerts[item].slice();
        });

        loadAlerts();
    };

    var severityFilterWatcher = $scope.$watch('severityFiter', filterAlerts);

    $scope.$on('$destroy', function () {
        if (severityFilterWatcher) {
            severityFilterWatcher();
        }
    });
    loadAlerts();
});
/* origin: public/webapp/app/dashboard/dashboard.js */
angular.module('webApp').controller('DashboardCtrl', function ($scope, $state, $rootScope, AccountService, AuthService, ImpersonationService, UserService, UpgradeService, appEmbedded) {

    $scope.upgradeNow = function() {
        $state.go('dashboard.settings.usage-and-billing');
    };

    if (AuthService.isAdmin())
        $scope.isImpersonating = ImpersonationService.isImpersonating();
    $scope.containerClass = function() { return $state.current.name.replace('dashboard.', ''); };
    $rootScope.additionalContainerClasses = [];
    $scope.additionalContainerClasses = function() { return $rootScope.additionalContainerClasses.join(' '); };
    $scope.logout = AuthService.logout;
    $scope.stopImpersonation = ImpersonationService.stopImpersonation;

    $('#kibana-container').hide();

    if (appEmbedded) return;

    AuthService.getUser().then(function(res) {
        $scope.user = res.data;
    }).catch(function() {
        $state.go('login');
    });

    $scope.accountName = '';
    if (AuthService.isAuthenticated()) {
        UserService.getSummary().then(function(res) {
            $scope.accountName = res.data.accountName;
        });
    }

    $scope.goHome = function() {
        $state.go('login');
    };

});
/* origin: public/webapp/app/dashboard/data-parsing/apply-dialog/apply-dialog-controller.js */
angular.module('webApp').controller('DataParsingApplyDialogController', function ($scope, DataParsingService, AnalyticsService) {
    $scope.logType = DataParsingService.formData.logType;

    $scope.apply = function () {
        $scope.loading = true;
        DataParsingService.reportAnalytics('apply-config-start');

        DataParsingService.apply().then(function () {
            $scope.succeeded = true;
            DataParsingService.reportAnalytics('apply-config-success');
            AnalyticsService.report('pageview', {
                url: [window.location.href, '/apply-config'].join(''),
                category: 'pageview'
            });
        }).catch(function (error) {
            $scope.succeeded = false;
            DataParsingService.reportAnalytics('apply-config-failed', {error: error});
        }).finally(function () {
            $scope.loading = false;
        });
    };
});
/* origin: public/webapp/app/dashboard/data-parsing/data-parsing-controller.js */
angular.module('webApp').controller('DataParsingController', function ($scope, $state, DataParsingService, ngDialog) {
    var vm = this;

    vm.steps = [ 'Setup', 'Parse', 'Enrich', 'Validate' ];
    vm.formData = DataParsingService.formData;
    vm.saveData = DataParsingService.saveData;

    vm.helpers = {
        parseMethod : 'app/dashboard/data-parsing/wizard-helpers/parse-method.html',
        parseResults : 'app/dashboard/data-parsing/wizard-helpers/parse-results.html',
        fieldType : 'app/dashboard/data-parsing/wizard-helpers/field-type.html',
        parseError : 'app/dashboard/data-parsing/wizard-helpers/parse-error.html',
        duplicateField : 'app/dashboard/data-parsing/wizard-helpers/duplicate-field.html',
        duplicateFieldAndParseError : 'app/dashboard/data-parsing/wizard-helpers/duplicates-field-and-parse-error.html',
        fieldRenameAlert : 'app/dashboard/data-parsing/wizard-helpers/field-rename.html'
    };

    var setTouched = function (form) {
        if (!form) {
            return;
        }
        angular.forEach(form.$error, function (error) {
            angular.forEach(error, function (errorField) {
                if (!errorField.$setTouched && errorField.$error) {
                    setTouched(errorField);
                    return;
                }
                errorField.$setTouched();
            });
        });
    };

    vm.goNext = function () {
        setTouched(vm.dataParsingForm);
        if (!vm.dataParsingForm.$valid) {
            return;
        }

        var newStepIndex = getCurrentStepIndex() + 1;
        goToStep(newStepIndex);
    };

    vm.goBack = function () {
        var newStepIndex = getCurrentStepIndex() - 1;
        goToStep(newStepIndex);
    };

    vm.submit = function () {
        if (getCurrentStepIndex() !== vm.steps.length) {
            return;
        }

        ngDialog.open({
            template: 'app/dashboard/data-parsing/apply-dialog/apply-dialog.html',
            controller: 'DataParsingApplyDialogController',
            width: '500px',
            closeByEscape: false,
            closeByDocument: false,
            showClose: false
        });
        DataParsingService.reportAnalytics('submit-dialog');
    };

    var goToStep = function (stepIndex) {
        $state.go([ 'dashboard.dataParsing.step', stepIndex ].join(''));
        setCurrentStep(stepIndex);
        DataParsingService.reportAnalytics(['go-to-step', stepIndex].join('-'));
    };
    vm.formChange = function () {
        DataParsingService.saveConfig().then(function () {
            vm.formData = DataParsingService.formData;
            vm.saveData = DataParsingService.saveData;
        });
    };

    var getCurrentStepIndex = function () {
        return parseInt($state.current.name.replace('dashboard.dataParsing.step', ''));
    };

    var setCurrentStep = function (stepNumber) {
        var step = vm.steps[stepNumber - 1];
        if (!step) {
            return; // May happen if the user clicked the next/back button too fast
        }

        vm.currentStep = step;
    };
    setCurrentStep(getCurrentStepIndex());
    DataParsingService.getStaticConfigValues();
    if (!_.get(vm, 'formData.dataSource.logType') && !($state.current.name === 'dashboard.dataParsing.step1')) {
        goToStep(1);
    }

    var formDataWatcher = $scope.$watch(function () { return DataParsingService.formData; }, function () {
        vm.formData = DataParsingService.formData;
    });

    $scope.$on('$destroy', function () {
        if (formDataWatcher)
            formDataWatcher();
    });
});

// TODO KPI analytics
/* origin: public/webapp/app/dashboard/data-parsing/data-parsing-service.js */
/* eslint-disable max-lines */
angular.module('webApp').service('DataParsingService', function ($q, Backend, AccountService, ColorService, AnalyticsService) {
    var module = {};
    var copiedCurrentUsedFieldTypes = {};
    module.config = {};
    module.staticValues = {
        geoip: {
            optional: [],
            mandatory: [],
        },
        datetime: {
            timeZones: [],
            formats: []
        }
    };
    module.saveData = {
        saveStatus: '',
        lastSaveDate: ''
    };
    var FormData = function (logType) {
        this.logType = logType;
        this.dataSource= {
            selected: false,
            type: 'useShippedLogs'
        };
        this.leadingTimestampPreview = {};
        this.parseData = {};
        this.selectedLogLines = [];
        this.startIndex = 0;
        this.geoip = {};
        this.timestampFields = [];
        this.customTimeField = false;
        this.useShippedTimestamp = false;
    };
    module.formData = new FormData();

    module.parseIt = function () {
        return Backend.POST(['/account/dataparsing/log-types/', module.formData.logType, '/parsing'].join(''), {
            parsingSteps: module.config.parsingSteps
        }).then(function (res) {
            copiedCurrentUsedFieldTypes = _.cloneDeep(_.get(module.formData, 'parsingData.fields'));

            module.fillNonCapturedData(res.data, module.formData.selectedLogLines);
            module.fillMissingValues(res.data);
            module.convertParsedFieldsToParsingData(res.data);
            module.removeUnusedFieldTypesConfigs(copiedCurrentUsedFieldTypes);

            for (var i = 0; i < res.data.length; i++) {
                if (!res.data[i].succeeded) continue;

                module.saveConfig(); // Whenever the user has at least one successful parse result - save the config
                break;
            }
            return res;
        }).catch(function (err) {
            module.formData.parsingData = undefined;
            throw err;
        });
    };

    module.getSampleLogs = function () {
        return Backend.GET(['/account/dataparsing/log-types/', module.formData.logType, '/sample-logs'].join('')).then(function (res) {
            var rawLogLines = _.get(res, 'data');
            return rawLogLines;
        }).catch(function (err) {
            console.error('error getting log lines:', err);
            throw err;
        });
    };

    module.initialSelectedLogLines = function (logLines) {
        module.config.sampleLogs = [];
        module.formData.parsingData = undefined;

        _.forEach(logLines, function (logLine) {
            module.config.sampleLogs.push({
                id: logLine.id,
                source: logLine.source,
                parsedMessage: [{value: logLine.source.message}]
            });
        });
    };

    module.fillNonCapturedData = function (parsed, originalMessages) {
        var logsCollection = [], cleanLogsCollection = [], lastEnd, thisStart, orderedLog, filledLog;
        _.forEach(parsed, function (log) {
            cleanLogsCollection.push(_.omitBy(_.get(log, 'result.source'), _.isString));
        });
        _.forEach(cleanLogsCollection, function (log, logIndex) { // convert parsed message to a collection
            logsCollection.push([]);
            _.forEach(log, function (value, key) {
                if (_.isArray(value)) {
                    logsCollection[logIndex] = _.concat(logsCollection[logIndex], _.map(value, function (val) {
                        return _.merge({field: key}, val);
                    }));
                }
                else {
                    logsCollection[logIndex].push(_.merge({field: key}, value));
                }
            });
        });

        var colorMemory = { }; // handle situation of grok with multiple & identical field name.
        var colorIndex = 0;

        _.forEach(logsCollection, function (log, logIndex) { //order by start index
            orderedLog = _.orderBy(log, 'start');
            filledLog = [];
            lastEnd = 0;
            _.forEach(orderedLog, function (field) { //fill uncaught values in order
                thisStart = field.start;
                if (lastEnd < thisStart) { //found uncaught message
                    filledLog.push({value: originalMessages[logIndex].source.message.substring(lastEnd, field.start)}); //changed
                }

                if (!colorMemory[field.field]) {
                    colorMemory[field.field] =  parsingColors[colorIndex % parsingColors.length];
                    colorIndex++;
                }
                field.rgbaString = ColorService.convertHexToRgba(colorMemory[field.field], 0.1);

                filledLog.push(field);
                lastEnd = field.end;
            });
            if (lastEnd < originalMessages[logIndex].source.message.length) {
                filledLog.push({value: originalMessages[logIndex].source.message.substring(lastEnd, originalMessages[logIndex].source.message.length)});
            }

            // If the parse did not succeed we keep the original parsed message (in case there is one) to avoid losing current parse colors in sample logs
            module.formData.selectedLogLines[logIndex].parsedMessage = parsed[logIndex].succeeded
                ? filledLog
                : _.get(originalMessages[logIndex], 'parsedMessage') || [{ value: module.formData.selectedLogLines[logIndex].source.message }];
        });
    };

    module.fillMissingValues = function (parsed) {
        var fields = {}, parsedLogs = [], rgba, editedLog, fieldName;
        _.forEachRight(parsed, function (log) { // set fields of the first message to be the decisive
            if (!log.succeeded)
                return;
            _.forEach(_.get(log, 'result.source'), function (value, key) {
                if (_.isObject(value))
                    fields[key] = value.start;
                if (_.isArray(value))
                    fields[key] = value[0].start;
            });
        });

        // Using _.map caused a weird error when having a field named 'length', apparently objects with length are treated as arrays.
        var fieldsForDataParsing = [];
        _.forEach(Object.keys(fields), function (fieldName) {
            fieldsForDataParsing.push({ field: fieldName, start: fields[fieldName] });
        });
        fields = _.sortBy(fieldsForDataParsing, 'start');

        _.forEach(parsed, function (log) { // go over each log and fill missing fields values
            editedLog = [];
            _.forEach(fields, function (field, index) {
                fieldName = field.field;
                if (log.succeeded && log.result.source[fieldName]) {
                    var color = parsingColors[index % parsingColors.length];
                    rgba = ColorService.convertHexToRgba(color, 0.1);
                    var value;
                    if (_.isArray(log.result.source[fieldName])) {
                        value = _.map(log.result.source[fieldName], 'value');
                        editedLog.push({field: fieldName, values: value, rgbaString: rgba, value: value.join(' ,')});
                    }
                    else {
                        value = log.result.source[fieldName].value;
                        editedLog.push({field: fieldName, value: value, rgbaString: rgba});
                    }

                }
                else {
                    editedLog.push({field: fieldName});
                }
            });
            parsedLogs.push(editedLog);
        });
        module.formData.parsedLogsLines = parsedLogs;
    };

    module.removeUnusedFieldTypesConfigs = function (originalFieldTypes) {
        // verify log types mapping (field name ==> field type)
        _.forEach(originalFieldTypes, function (field) {
            if (!_.find(module.formData.parsingData.fields, {name: field.name})) {
                module.config.fieldTypes = _.omit(module.config.fieldTypes, field.name);

                // verify additional timestamp configs
                _.unset(module.config, ['datetime.fieldsConfig.', field.name].join(''));
            }
        });

        // verify default timestamp configs
        var existingTimestampField = _.findKey(module.config.fieldTypes, function (val) {
            return val === 'date';
        });
        if (!existingTimestampField) {
            module.config.datetime = {};
        }

        // verify geoip configs
        module.formData.geoipField = _.findKey(module.config.fieldTypes, function (val) {
            return val === 'geoip';
        });
        if (!module.formData.geoipField) {
            module.formData.geoip = {};
        }

        //verify leading timestamp
        if (module.config.leadingTimestamp) {
            if (!_.get(module.config, ['fieldTypes.', module.config.leadingTimestamp ].join(''))) {
                _.unset(module.config, 'leadingTimestamp');
            }
        }
    };

    module.convertParsedFieldsToParsingData = function (parseResult) {
        var parsedLogs = module.formData.parsedLogsLines;
        if (!parsedLogs.length) {
            module.formData.parsingData = undefined;
            return;
        }
        var fieldTypes = module.config.fieldTypes || {};
        module.formData.parsingData = {
            succeeded: false,
            parsingSamples: [],
            fields: []
        };
        _.forEach(parsedLogs, function (parsedLog, index) {
            var parsingSample = {
                succeeded: parseResult[index].succeeded,
                values: []
            };
            if (parseResult[index].succeeded) {
                module.formData.parsingData.succeeded = true;
            }

            _.forEach(parsedLog, function (fieldData) {
                var fieldName = fieldData.field;
                var alreadyInList = _.some(module.formData.parsingData.fields, { name: fieldName });

                if (!alreadyInList) {
                    var currentESMappingsWithRenames =  _.get(parseResult[index], 'currentESMappingsWithRenames');
                    var currentTemplateMappings = _.get(parseResult[index], 'currentTemplateMappings');
                    var fieldInEsMappingRename = _.get(currentESMappingsWithRenames, fieldName);

                    var fieldType = _.get(fieldInEsMappingRename, 'fieldType');
                    var templateFieldType = _.get(currentTemplateMappings, fieldName);
                    var fieldRename = _.get(fieldInEsMappingRename, 'fieldRename');

                    module.formData.parsingData.fields.push({
                        name: fieldName,
                        fieldRename: fieldRename || '',
                        type: fieldType || fieldTypes[fieldName] || templateFieldType || 'Automatic',

                        currentEsMapping: _.capitalize(templateFieldType),

                        // Thx to _.get this also takes care of the scenario when currentESMappingsWithRenames or
                        // fieldInEsMappingRename are undefined, editable should be true
                        editable: !fieldType && !fieldRename
                    });
                }

                parsingSample.values.push({
                    values : fieldData.values,
                    value: fieldData.value,
                    rgbaString: fieldData.rgbaString
                });

                if (!fieldData.value) {
                    parsingSample.partialMatch = true;
                }
            });

            module.formData.parsingData.parsingSamples.push(parsingSample);
        });
    };

    module.applyGeoTimeData = function () {
        var optionalGeoIpFieldsObject = {}, optionalGeoIpFieldsArray;
        module.formData.geoipField = _.findKey(module.config.fieldTypes, function (val) {
            return val === 'geoip';
        });
        optionalGeoIpFieldsArray = _.get(module.config.geoip, 'defaultConfig.properties');
        _.forEach(optionalGeoIpFieldsArray, function (key) {
            optionalGeoIpFieldsObject[key] = true;
        });
        _.set(module.formData.geoip, 'optional', optionalGeoIpFieldsObject);
    };

    module.getUpdatedSettings = function (logType) {
        return Backend.GET(['/account/dataparsing/log-types/', logType, '/config'].join('')).then(function (res) {
            module.config = res.data || {};
            return module.config;
        }).catch(function (err) {
            module.config = {};
            throw err;
        }).finally(function () {
            module.formData = new FormData(logType);
            module.formData.grokPattern = _.get(module.config, 'parsingSteps[0].config.patterns[0]');
            module.formData.parseData.parseMethod = _.get(module.config, 'parsingSteps[0].method');
            module.applyGeoTimeData();
            module.formData.selectedLogLines = _.map(module.config.sampleLogs, function (val) {
                return {
                    id: val.id, source: val.source, parsedMessage: [{value: val.source.message}]
                };
            });
        });
    };

    var handleCustomTimestampsAndTimezones = function () {
        var copiedModuleConfiguration = _.cloneDeep(module.config);

        if (_.get(copiedModuleConfiguration, 'leadingTimestamp') === '@timestamp') {
            delete copiedModuleConfiguration.leadingTimestamp;
        }

        var defaultTimezone = _.get(copiedModuleConfiguration, 'datetime.defaultConfig.timeZone');
        if (defaultTimezone && defaultTimezone.toLowerCase() === 'automatic') {
            delete copiedModuleConfiguration.datetime.defaultConfig.timeZone;
        }

        var manualDateConfig = _.get(copiedModuleConfiguration, 'datetime.fieldsConfig');
        if (manualDateConfig) {
            _.forEach(manualDateConfig, function (config) {
                if (config.timeZone && config.timeZone.toLowerCase() === 'automatic') {
                    delete config.timeZone;
                }
            });
        }

        if (!_.size(copiedModuleConfiguration.fieldTypes)) {
            copiedModuleConfiguration.fieldTypes = {};
        }

        return copiedModuleConfiguration;
    };

    var saving = false;
    module.saveConfig = function () {
        var promise = $q.defer(), logType = module.formData.logType;
        if (!logType || saving) {
            promise.reject();
            return promise.promise;
        }
        saving = true;
        module.saveData.saveStatus = 'Saving...';
        module.saveData.lastSaveDate = '';

        var copiedModuleConfiguration = handleCustomTimestampsAndTimezones();

        Backend.POST(['/account/dataparsing/log-types/', logType, '/config'].join(''), copiedModuleConfiguration).then(function (res) {
            module.saveData.saveStatus = 'All changes saved at';
            module.saveData.lastSaveDate = new Date();
            saving = false;
            promise.resolve(res);
        }).catch(function () {
            module.saveData.saveStatus = 'Failed saving';
            saving = false;
        });
        return promise.promise;
    };

    module.getStaticConfigValues = function () {
        Backend.GET('/account/dataparsing/static-config-values').then(function (res) {
            module.staticValues = res.data;
        });
    };

    module.previewTimestamp = function (data) {
        return Backend.POST('/account/dataparsing/datetime', data);
    };

    module.apply = function () {
        return Backend.POST(['/account/dataparsing/log-types/', module.formData.logType, '/apply'].join(''));
    };

    module.getAccountLogTypes = function () {
        return Backend.GET('/account/dataparsing/log-types');
    };

    module.getValidateData = function () {
        return Backend.GET(['/account/dataparsing/log-types/', module.formData.logType, '/validate'].join(''));
    };

    module.reportAnalytics = function (eventName, additionalData) {
        var data = _.assign({ category: 'data-parsing', logType: module.formData.logType }, additionalData);
        if (module.formData.grokPattern)
            data.grokPattern = module.formData.grokPattern;
        AnalyticsService.report(eventName, data);
    };

    var parsingColors = [
        '#b763de',
        '#28b40d',
        '#ff0000',
        '#54c7c6',
        '#b763de',
        '#589026',
        '#3b448b',
        '#ff008e',
        '#fff200',
    ];

    return module;
});
/* eslint-enable max-lines */

/* origin: public/webapp/app/dashboard/data-parsing/step1/data-parsing-step1-controller.js */
angular.module('webApp').controller('DataParsingStep1Controller', function ($timeout, DataParsingService) {
    var vmStep1 = this;
    vmStep1.formData = DataParsingService.formData;
    vmStep1.SAWMILL_EDITOR_READONLY = 'SAWMILL_EDITOR_READONLY';

    DataParsingService.getAccountLogTypes().then(function (logTypesRes) {
        vmStep1.availiableLogTypes = _.orderBy(logTypesRes.data, function (logData) {
            return logData.logType.toLowerCase();
        });
        vmStep1.finishLoading = true;
    });

    vmStep1.changeLogType = function () {
        DataParsingService.getUpdatedSettings(vmStep1.formData.logType).then(function () {
            DataParsingService.reportAnalytics('choose-log-type');
        });
    };

    if (vmStep1.formData.logType) {
        // We had it cached because the user was in the data parsing wizard during his session, we gotta reload config
        vmStep1.changeLogType();
    }
});
/* origin: public/webapp/app/dashboard/data-parsing/step2/data-parsing-step2-controller.js */
angular.module('webApp').controller('DataParsingStep2Controller', function ($scope, $timeout, DataParsingService, ngDialog, UserService) {
    var vmStep2 = this;
    vmStep2.formData = DataParsingService.formData;
    vmStep2.config = DataParsingService.config;
    vmStep2.validateSelectedLogs = '';
    vmStep2.formData.selectedLogLines = DataParsingService.formData.selectedLogLines;
    vmStep2.config.patternName = vmStep2.config.patternName || vmStep2.formData.logType; // TODO will be needed to adjust a little when we add the option of multi patterns (needs to make sure this doesn't conflict with another pattern and same name)
    vmStep2.availableFieldTypes = [
        {val: 'boolean', name: 'Boolean'},
        {val: 'date', name: 'Date (timestamp)'},
        {val: 'double', name: 'Double'},
        {val: 'geoip', name: 'GeoIp Enrichment'},
        {val: 'ip', name: 'IP'},
        {val: 'keyword', name: 'Keyword (String)'},
        {val: 'long', name: 'Long'},
    ];
    vmStep2.availableFieldTypesExtra = [
        {val: 'byte', name: 'Byte'},
        {val: 'geo_point', name: 'Geo Point'},
        {val: 'float', name: 'Float'},
        {val: 'integer', name: 'Integer'},
        {val: 'text', name: 'Text (Analysed Field)'},
        {val: 'short', name: 'Short'},
    ];
    vmStep2.hideWhitespaceCharacters = false;

    // Validate all field types with sample logs
    vmStep2.validateAllFields = function () {
        if (vmStep2.formData.parsingData === undefined){
            return;
        }

        for (var i = 0; i < vmStep2.formData.parsingData.fields.length; i++) {
            vmStep2.checkSamplesOnFieldType(i, vmStep2.formData.parsingData.fields[i]['type']);
        }
    };

    var renderColors = function() {
        $timeout(function () {
            vmStep2.shouldColor = true;
        }, 100);
    };
    renderColors();

    vmStep2.collapseExpandLog = function (log) {
        if (!log.toggleAvailable) {
            return;
        }

        log.toggle = !log.toggle;
        DataParsingService.reportAnalytics('collapse-expand-row');
    };

    var accountId;
    UserService.getSummary().then(function (res) {
        accountId = res.data.accountId;
    });

    vmStep2.isParsingValid = true;
    var currentChangeVersion = 0;
    vmStep2.parseIt = function () {
        var changeVersion = ++currentChangeVersion;

        if (!vmStep2.formData.grokPattern || !vmStep2.formData.parseData.parseMethod || !_.size(vmStep2.formData.selectedLogLines)) {
            vmStep2.formData.parsingData = undefined;
            vmStep2.loadingParsingResults = false;
            vmStep2.isParsingValid = true;
            return;
        }

        vmStep2.loadingParsingResults = true;

        _.set(DataParsingService.config, 'parsingSteps[0].config.patterns[0]', vmStep2.formData.grokPattern);
        _.set(DataParsingService.config, 'parsingSteps[0].method', 'grok');
        DataParsingService.parseIt().then(function () {
            if (changeVersion < currentChangeVersion){
                return;
            }

            vmStep2.formData.parsingData = DataParsingService.formData.parsingData;
            vmStep2.notEfficientGrok = false;
            vmStep2.compileError = false;
            renderColors();
            vmStep2.validateAllFields();

            DataParsingService.reportAnalytics('parse', { parseMethod: 'grok', parsePattern: vmStep2.formData.grokPattern });
        }).catch(function (err) {
            if (changeVersion < currentChangeVersion){
                return;
            }

            vmStep2.formData.parsingData = undefined;
            vmStep2.notEfficientGrok = err.status === 403;
            vmStep2.compileError = !vmStep2.notEfficientGrok;
            DataParsingService.reportAnalytics('parse-error', { error: err });

            if (vmStep2.notEfficientGrok) {
                vmStep2.mailToAddress = [ 'mailto:help@logz.io?subject=Assistance required for grok optimization - ', accountId, '&body=* Log Type: ', vmStep2.formData.logType, '%0D%0A* Grok Pattern: ', vmStep2.formData.grokPattern  ].join('');
            }
        }).finally(function () {
            if (changeVersion < currentChangeVersion){
                return;
            }

            vmStep2.isParsingValid = !vmStep2.compileError && !vmStep2.notEfficientGrok && vmStep2.formData.parsingData.succeeded;
            vmStep2.loadingParsingResults = false;
        });
    };

    vmStep2.selectSampleLogLines = function () {
        var selectLogLinesScope = $scope.$new();
        selectLogLinesScope.selectedLogLines = vmStep2.formData.selectedLogLines;

        ngDialog.open({
            template: 'app/dashboard/data-parsing/step2/select-logs/data-parsing-select-logs.html',
            controller: 'DataParsingSelectLogsController',
            width: '1140px',
            closeByEscape: false,
            closeByDocument: false,
            showClose: false,
            scope: selectLogLinesScope,
            preCloseCallback: vmStep2.parseIt
        });
        DataParsingService.reportAnalytics('select-sample-log-lines');
    };

    vmStep2.displayLogSamples = function (action) {
        vmStep2.formData.startIndex += action === 'next' ? 1 : -1;
        var logSamplesCounter = vmStep2.formData.selectedLogLines.length;
        vmStep2.formData.startIndex = vmStep2.formData.startIndex >= 0 ? vmStep2.foxrmData.startIndex : 0;
        if (vmStep2.formData.startIndex >= logSamplesCounter - 1) {
            vmStep2.formData.startIndex = logSamplesCounter - 2;
        }

        _.forEach(vmStep2.formData.selectedLogLines, function (sample, index) {
            sample.showing = vmStep2.formData.startIndex + 1 >= index && vmStep2.formData.startIndex <= index;
        });
        DataParsingService.reportAnalytics('parse-table-paging');
    };

    vmStep2.removeLogSample = function (id) {
        vmStep2.formData.parsingData = undefined;
        _.remove(vmStep2.formData.selectedLogLines, { id: id });
        _.remove(vmStep2.config.sampleLogs, { id: id });
        DataParsingService.saveConfig();
        DataParsingService.reportAnalytics('remove-log-line');
    };

    var removeDatetimeConfigByFieldName = function (fieldName) {
        var customDateConfig = _.get(vmStep2.config, 'datetime.fieldsConfig');
        if (customDateConfig &&
            customDateConfig[fieldName]) {

            delete customDateConfig[fieldName]; // Not timestamp configured anymore
        }

        if (vmStep2.config.leadingTimestamp === fieldName) {
            delete vmStep2.config.leadingTimestamp;
        }
    };

    vmStep2.checkSamplesOnFieldType = function (fieldIndex, type) {
        var checkResult, field, parseTypeResults = [];

        if (fieldIndex === -1){
            return;
        }

        _.forEach(vmStep2.formData.parsingData.parsingSamples, function (parsingSample) {
            if(!parsingSample.succeeded){
                return parseTypeResults;
            }
            field = parsingSample.values[fieldIndex];

            if (field === undefined){
                return parseTypeResults;
            }

            if (field.values){
                var listResults = [];
                if (type.toLowerCase() === 'geo_point'){
                    listResults.push(field.values.length === 2);
                    _.forEach(field.values, function (value) {
                        checkResult = checkType(value, 'number');
                        listResults.push(checkResult);
                    });
                }
                else {
                    _.forEach(field.values, function (value) {
                        checkResult = checkType(value, type);
                        listResults.push(checkResult);
                    });
                }
                parseTypeResults.push(!listResults.contains(false));
            }
            else {
                checkResult = checkType(field.value, type);
                parseTypeResults.push(checkResult);
            }

            vmStep2.formData.parsingData.fields[fieldIndex].noSampleApproved = !parseTypeResults.contains(true);
        });

        return parseTypeResults;
    };
    
    var checkType = function (value, type) {
        if (value === undefined) {
            return false;
        }

        if (_.includes(['long', 'integer', 'short', 'byte', 'double', 'float', 'number'], type.toLowerCase())) {
            return !isNaN(value) && angular.isNumber(+value);
        }
        else if (_.includes(['ip', 'geoip'], type.toLowerCase())) {
            var chekIfStringIsIp = /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/;
            var matchResult = value.match(chekIfStringIsIp);
            return matchResult !== null && matchResult.length > 0;
        }

        return true;
    };

    vmStep2.changeFieldTypeCallback = function (fieldName, newType) {
        var fieldIndex;
        if (newType.toLowerCase() === 'automatic') {
            var fieldTypes = _.get(vmStep2.config, 'fieldTypes');
            if (fieldTypes) {
                delete fieldTypes[fieldName];
            }
        }
        else {
            _.set(vmStep2.config, [ 'fieldTypes.', fieldName ].join(''), newType);
        }

        if (newType.toLowerCase() !== 'date') {
            removeDatetimeConfigByFieldName(fieldName);
        }

        fieldIndex = _.findIndex(vmStep2.formData.parsingData.fields, {'name': fieldName});

        vmStep2.checkSamplesOnFieldType(fieldIndex, newType);

        DataParsingService.saveConfig();
        DataParsingService.reportAnalytics('parsing-table-change-field-type', {fieldName: fieldName, fieldType: newType});
    };

    if (vmStep2.formData.selectedLogLines) {
        _.forEach(vmStep2.formData.selectedLogLines, function (log) {
            log.toggle = false; // Collapse all log lines
        });

        if (!vmStep2.formData.parsingData) {
            vmStep2.parseIt();
        }
    }
});
/* origin: public/webapp/app/dashboard/data-parsing/step2/select-logs/data-parsing-select-logs-controller.js */
angular.module('webApp').controller('DataParsingSelectLogsController', function ($rootScope, $scope, $timeout, DataParsingService) {
    $scope.selectLog = function (log) {
        if ($scope.selectedLogLines.length >= 5) {
            markMaxLogLineLimitation();
            return;
        }

        log.selected = true;
        $scope.selectedLogLines.push({
            id: log.id,
            source: log.source,
            parsedMessage: [{value: _.get(log, 'source.message')}]
        });
    };

    $scope.logtype = DataParsingService.formData.logType;

    var limitationTimer;
    var markMaxLogLineLimitation = function () {
        if ($scope.limitationReached) {
            $timeout.cancel(limitationTimer);
        }

        $scope.limitationReached = true;
        limitationTimer = $timeout(function () {
            $scope.limitationReached = false;
        }, 2000);
    };

    $scope.unselectLog = function (id) {
        _.remove($scope.selectedLogLines, { id: id });

        var log = _.find($scope.lastLogLines, { id: id });
        if (!log) {
            return;
        }

        log.selected = false;
    };

    $scope.collapseExpandLog = function (log) {
        if (!log.selectLogToggleAvailable) {
            return;
        }

        log.selectLogsToggle = !log.selectLogsToggle;
    };

    var fetchPreviouslySelectedLogLines = function () {
        _.forEach($scope.lastLogLines, function (log) {
            var match = _.find($scope.selectedLogLines, { id: log.id });
            log.selected = match !== undefined;
        });
    };

    $scope.loading = true;
    DataParsingService.getSampleLogs().then(function (sampleLogLines) {
        $scope.lastLogLines = sampleLogLines;
        $scope.loading = false;

        if ($scope.selectedLogLines) {
            fetchPreviouslySelectedLogLines();
        }
    });

    $scope.loadingMessage = 'Searching...';
    $timeout(function () {
        if (!$scope.loading) {
            return;
        }

        $scope.loadingMessage = 'Since we couldn\'t find any data from the last 24 hours, we\'re going further back in time. This may take a few minutes...';
    }, 15000);

    var saving = false;
    $scope.saveChanges = function () {
        if (saving) {
            return;
        }

        saving = true;
        DataParsingService.initialSelectedLogLines($scope.selectedLogLines);
        DataParsingService.saveConfig();
        $scope.closeThisDialog();
    };

    var selectedLogLinesCopy = _.cloneDeep($scope.selectedLogLines);
    $scope.cancelChanges = function () {
        _.remove($scope.selectedLogLines, function () { return true; });
        _.forEach(selectedLogLinesCopy, function (log) {
            $scope.selectedLogLines.push(log);
        });

        $scope.closeThisDialog();
    };
});
/* origin: public/webapp/app/dashboard/data-parsing/step3/data-parsing-step3-controller.js */
angular.module('webApp').controller('DataParsingStep3Controller', function ($scope, DataParsingService) {
    var vmStep3 = this;
    vmStep3.formData = DataParsingService.formData;
    vmStep3.config = DataParsingService.config;
    vmStep3.staticValues = DataParsingService.staticValues;

    vmStep3.optionalGeoIPEnrichmentFields = vmStep3.staticValues.geoip.optional.sort();
    vmStep3.mandatoryGeoIPEnrichmentFields = vmStep3.staticValues.geoip.mandatory.sort();
    vmStep3.timeZones = vmStep3.staticValues.datetime.timeZones.sort();
    vmStep3.dateFormats = _.orderBy(vmStep3.staticValues.datetime.formats, function (format) {
        return format.toLowerCase();
    });
    vmStep3.changeOptionalGeoIPEnrichmentField = function (option) {
        if (option) {
            option = option === 'all';
            _.forEach(vmStep3.optionalGeoIPEnrichmentFields, function (val) {
                _.set(vmStep3.formData, ['geoip.optional', val].join('.'), option);
            });
        }
        var optionalArray = [];
        _.forEach(vmStep3.formData.geoip.optional, function (val, key) {
            if (!val) return;

            optionalArray.push(key);
        });
        _.set(DataParsingService.config, 'geoip.defaultConfig.properties', optionalArray);
        vmStep3.formChange();
        DataParsingService.reportAnalytics('change-optional-geoip-enrichment-field');
    };

    vmStep3.formChange = function () {
        DataParsingService.saveConfig();
    };

    vmStep3.changeLeadingTimestamp = function () {
        if (vmStep3.formData.useShippedTimestamp) {
            vmStep3.config.leadingTimestamp = '@timestamp';
        }
        else if (vmStep3.config.leadingTimestamp === '@timestamp' || !vmStep3.config.leadingTimestamp) {
            vmStep3.config.leadingTimestamp = vmStep3.totalTimestampFields[0];
        }

        vmStep3.changeDefaultDateTimeConfig();
        DataParsingService.reportAnalytics('change-leading-timestamp');
    };

    vmStep3.changeDefaultDateTimeConfig = function () {
        var timeZone = _.get(vmStep3.config, 'datetime.defaultConfig.timeZone');
        var format = _.get(vmStep3.config, 'datetime.defaultConfig.formats[0]');
        var previewTimestampField = _.get(vmStep3.config, 'leadingTimestamp');

        if (previewTimestampField === '@timestamp') {
            previewTimestampField = _.get(vmStep3.formData, 'timestampFields[0]') || previewTimestampField;
        }
        if (previewTimestampField !== '@timestamp') {
            vmStep3.formData.leadingTimestampPreview.originalValues = vmStep3.getTimestampFieldValue(previewTimestampField);

        }
        if (timeZone && format && previewTimestampField !== '@timestamp') {
            vmStep3.previewTimestamp(timeZone, format, previewTimestampField).then(function (previewData) {
                vmStep3.formData.leadingTimestampPreview = previewData;
            });
        }
        vmStep3.formChange();
        DataParsingService.reportAnalytics('change-default-timestamp');
    };

    vmStep3.changeCustomTimeField = function () {
        if (vmStep3.formData.customTimeField && !vmStep3.additionalTimestampConfigs.length) {
            vmStep3.additionalTimestampConfigs.push({
                timeZone: 'Automatic'
            });
        }
    };

    vmStep3.addAdditionalTimestampConfig = function () {
        angular.forEach(vmStep3.customTimestampsForm.$error, function (error) {
            angular.forEach(error, function (errorField) {
                errorField.$setTouched();
            });
        });
        if (!vmStep3.customTimestampsForm.$valid) return;

        vmStep3.additionalTimestampConfigs.push({
            timeZone: 'Automatic'
        });
        DataParsingService.reportAnalytics('add-additional-timestamp-field');
    };

    vmStep3.removeTimestampConfig = function (index) {
        var fieldName = vmStep3.additionalTimestampConfigs[index].field;
        if (fieldName) {
            _.unset(vmStep3.config, ['datetime.fieldsConfig', fieldName].join('.'));
        }
        vmStep3.additionalTimestampConfigs.splice(index, 1);
        if (!vmStep3.additionalTimestampConfigs.length) {
            vmStep3.formData.customTimeField = false;
        }
        applyAvailableTimestampFields();
        vmStep3.formChange();
        DataParsingService.reportAnalytics('remove-timestamp-config');
    };
    vmStep3.applyAdditionalTimestampToConfig = function (additionalConfig) {
        if (additionalConfig.field)
            additionalConfig.originalValues = vmStep3.getTimestampFieldValue(additionalConfig.field);
        if (additionalConfig.field && additionalConfig.format && additionalConfig.timeZone) {
            vmStep3.previewTimestamp(additionalConfig.timeZone, additionalConfig.format, additionalConfig.field).then(function (previewData) {
                additionalConfig = _.merge(additionalConfig, previewData);
            });
            _.set(vmStep3.config, ['datetime.fieldsConfig', additionalConfig.field].join('.'), {
                formats: [additionalConfig.format],
                timeZone: additionalConfig.timeZone || 'Automatic'
            });
        }
        applyAvailableTimestampFields();
        vmStep3.formChange();
    };

    vmStep3.previewTimestamp = function (timeZone, format, timestampField) {
        var originalValues = vmStep3.getTimestampFieldValue(timestampField);
        var reqData = getPreviewConfig(timeZone, format, originalValues);
        return DataParsingService.previewTimestamp(reqData).then(function (res) {
            var results = res.data;
            var succeededResults = _.filter(results, function (result) {
                return result !== null;
            });
            return {
                succeed: succeededResults.length === results.length,
                preview: results[0],
                originalValues: originalValues
            };
        });
    };

    vmStep3.getTimestampFieldValue = function (fieldName) {
        var timestampOriginalValues = [];
        _.forEach(vmStep3.formData.parsedLogsLines, function (logLine) {
            var timestampField = _.find(logLine, {field: fieldName});
            if (timestampField && timestampField.value)
                timestampOriginalValues.push(timestampField.value);
        });
        return timestampOriginalValues;
    };

    vmStep3.useCustomTimeDateField = function () {
        vmStep3.formData.customTimeField = true;
        vmStep3.changeCustomTimeField();
        DataParsingService.reportAnalytics('use-custom-timestamp-field');
    };

    function getPreviewConfig(timeZone, format, values) {
        var reqData = {
            'config': {'formats': [format]},
            'samples': values
        };
        if (timeZone !== 'Automatic')
            _.set(reqData, 'config.timeZone', timeZone);
        return reqData;
    }

    var usedTimestampFields = [];

    function applyAvailableTimestampFields() {
        usedTimestampFields = _.map(vmStep3.additionalTimestampConfigs, function (additionalTimestampConfig) {
            if (additionalTimestampConfig.field)
                return additionalTimestampConfig.field;
        });
        vmStep3.availableTimestampFields = _.difference(vmStep3.formData.timestampFields, usedTimestampFields);
        vmStep3.availableTimestampFields = vmStep3.availableTimestampFields.sort();
        vmStep3.totalTimestampFields = _.concat(usedTimestampFields, vmStep3.availableTimestampFields);
    }

    function handleDefaultTimestampConfig() {
        if (!vmStep3.totalTimestampFields.length) {
            vmStep3.formData.useShippedTimestamp = true;
        }
        else if (vmStep3.formData.timestampFields) {
            vmStep3.formData.useShippedTimestamp = false;
            vmStep3.config.leadingTimestamp = vmStep3.totalTimestampFields[0];
        }

        if (!_.get(vmStep3.config, 'datetime.defaultConfig.timeZone')) {
            _.set(vmStep3.config, 'datetime.defaultConfig.timeZone', 'Automatic');
        }

        if (!_.get(vmStep3.config, 'datetime.defaultConfig.formats[0]')) {
            _.set(vmStep3.config, 'datetime.defaultConfig.formats', []);
        }
    }

    function initialAdditionalTimestampConfig() {
        vmStep3.additionalTimestampConfigs = _.map(_.get(vmStep3.config, 'datetime.fieldsConfig'), function (val, key) {
            return {field: key, format: _.get(val, 'formats[0]'), timeZone: val.timeZone};
        }) || [];
        vmStep3.formData.customTimeField = vmStep3.additionalTimestampConfigs.length > 0;

        var timestampFieldsCollection = _.map(_.get(vmStep3.config, 'fieldTypes'), function (val, key) {
            return {fieldName: key, fieldType: val};
        });
        vmStep3.formData.timestampFields = _.map(_.filter(timestampFieldsCollection, {fieldType: 'date'}), function (val) {
            return val.fieldName;
        });

        _.forEach(vmStep3.additionalTimestampConfigs, function (additionalConfig) {
            vmStep3.previewTimestamp(additionalConfig.timeZone, additionalConfig.format, additionalConfig.field).then(function (previewData) {
                additionalConfig = _.merge(additionalConfig, previewData);
            });
        });
    }

    initialAdditionalTimestampConfig();
    applyAvailableTimestampFields();
    handleDefaultTimestampConfig();
    DataParsingService.applyGeoTimeData();
    vmStep3.changeLeadingTimestamp();

});
/* origin: public/webapp/app/dashboard/data-parsing/step4/data-parsing-step4-controller.js */
angular.module('webApp').controller('DataParsingStep4Controller', function (DataParsingService, AuthService) {
    var vmStep4 = this;
    vmStep4.formData = DataParsingService.formData;
    DataParsingService.getValidateData().then(function (res) {
        vmStep4.validateData = {};

        // Very ugly (and useful) code taken from '_flatten_hit.js' (Kibana)
        _.forEach(Object.keys(res.data), function (key) {
            vmStep4.validateData[key] = {
                unparsed: [],
                logs: [],
                suffix: '',
            };
            _.forEach(res.data[key], function (log) {
                var flattenedLog = {};

                (function flatten(obj, keyPrefix) {
                    keyPrefix = keyPrefix
                        ? [ keyPrefix, '.' ].join('')
                        : '';

                    _.forOwn(obj, function (val, key) {
                        key = keyPrefix + key;

                        if (flattenedLog[key] !== void 0) return;

                        if (!_.isPlainObject(val)) {
                            flattenedLog[key] = Array.isArray(val) ? val.join(', ') : val;
                            return;
                        }

                        flatten(val, key);
                    });
                }(log.result.source));

                var logData = {
                    succeeded: log.succeeded,
                    result: {
                        source: flattenedLog
                    }
                };
                vmStep4.validateData[key].logs.push(logData);

                if (!log.succeeded) {
                    vmStep4.validateData[key].unparsed.push(logData);
                }
            });

            if (vmStep4.validateData[key].unparsed.length) {
                vmStep4.validateData[key].suffix = [ vmStep4.validateData[key].unparsed.length, 'unparsed' ].join(' ');
            }
        });

        vmStep4.finishLoading = true;
        DataParsingService.reportAnalytics('get-validate-data');
    }).catch(function (err) {
        //TODO handle errors
        vmStep4.finishLoading = true;
        DataParsingService.reportAnalytics('get-validate-data', { error: err });
    });

    vmStep4.mapping = {'@timestamp': 'timestamp'};
    var fieldsConfig = _.get(DataParsingService.config, 'fieldTypes');
    if (fieldsConfig) {
        _.forEach(Object.keys(fieldsConfig), function (key) {
            vmStep4.mapping[key] = fieldsConfig[key];
        });
    }

    if (AuthService.isAdmin()) {
        vmStep4.tabsManagerOptionalActionText = 'Export Sawmill Config';
        vmStep4.tabsManagerOptionalActionFunc = function () {
            alert('JOSH = TRUE');
            // TODO get config from backend and download as sawmill.conf
            DataParsingService.reportAnalytics('export-sawmill-config');
        };
    }
});
/* origin: public/webapp/app/dashboard/data-sources/cloudtrail.js */
angular.module('webApp').controller('CloudtrailSettingsController', function ($scope, AuthService, Backend, UserService) {
    UserService.getSummary().then(function (res) {
        $scope.accountId = res.data.accountId;
    });

    if (!$scope.settings)
        $scope.settings = {};

    $scope.addCloudtrailSettings = function () {
        if (!$scope.settings)
            $scope.settings = [];
        $scope.settings.push({id: 0, active: true});
    };

    AuthService.getUser().then(function (res) {
        $scope.accountId = res.data.accountId;
    });

    Backend.GET('/account-cloudtrails').then(function (cloudtrailSettingsList) {
        if (!cloudtrailSettingsList.data || cloudtrailSettingsList.data.cloudTrails === undefined) {
            alert('There was an error retrieving your cloudtrail settings.\nPlease refresh the page to retry again.');
        }

        $scope.settings = cloudtrailSettingsList.data.cloudTrails;
        _.forEach($scope.settings, function (cloudtrailSettings) {
            cloudtrailSettings.s3secretKey = cloudtrailSettings.encryptedSecretKey; // For the dots in the html dom
        });
    });

});
/* origin: public/webapp/app/dashboard/data-sources/data-sources.js */
angular.module('webApp').controller('DataSourcesCtrl', function($rootScope, $scope, $state, $stateParams, $compile, $timeout, $injector, AuthService, UserService, Backend, $location, AnalyticsService) {

    $rootScope.bodyClass = '';
    $scope.menuLoading = true;

    if (AuthService.isAuthenticated()) {
        UserService.getSummary().then(function (res) {
            $scope.summary = res.data;
        });
    }
    else {
        $scope.summary = {
            accountId: 0
        };
    }

    var getDocumentSlug = function(documentName) {
        return documentName.replace(' ', '-').replace(/[^\-A-z0-9]+/g, '');
    };

    Backend.GET('/cms/menu').then(function(res) {
        if ($state.current.name !== 'dashboard.dataSources') {
            return; // Annoying bug fix where the CMS menu took a few seconds and the user already moved to another page
        }

        $scope.menuLoading = false;

        var menu = res.data;
        menu.categories.forEach(function(category) {
            category.hidden = true;
        });
        menu.categories[0].hidden = false;
        $scope.menu = menu;

        if (!$stateParams.doc) {
            var entry = $scope.menu.categories[0].entries[0];
            $scope.displayDoc(entry.id, entry.name);
        }
        else {
            menu.categories.forEach(function(category) {
                category.entries.forEach(function(entry) {
                    var fixedEntryName = getDocumentSlug(entry.name);
                    if ($stateParams.doc.toLowerCase() === fixedEntryName.toLowerCase()) {
                        $scope.displayDoc(entry.id, entry.name);
                        category.hidden = false;
                    }
                });
            });
        }
    });

    $scope.displayDoc = function(docId, docName) {

        var fixedEntryName = getDocumentSlug(docName);
        var params = { notify: false };
        if (!$stateParams.doc) {
            params.location = 'replace';
        }
        $stateParams.doc = fixedEntryName;
        $state.go('dashboard.dataSources', { doc: fixedEntryName }, params);

        $('#device-instructions-page').html('');
        $timeout(function() {
            $scope.loadingDoc = true;
        }, 0);

        $('body').animate({ scrollTop: 0 });

        Backend.GET('/cms/docs/' + docId).then(function(res) {
            $timeout(function() {
                $scope.loadingDoc = false;
            }, 0);
            AnalyticsService.report('pageview', {
                page: 'dashboard.dataSources',
                url: window.location.href,
                category: 'pageview',
                subPage: docName,
                docId:docId,
                docName:docName,
                title: $state.current.name
            });

            var content = res.data.content;
            $scope.selectedEntry = res.data.name;

            var md = window.markdownit();
            var parsedContent = md.render(content);

            var isAuthenticated = AuthService.isAuthenticated();

            var cloudtrailBlock = isAuthenticated ? '<section id="cloudtrail-settings-section" ng-controller="CloudtrailSettingsController"><logz-cloudtrail-settings ng-repeat="cloudtrailSettings in settings" account-id="accountId" settings="cloudtrailSettings"></logz-cloudtrail-settings><logz-cloudtrail-settings account-id="accountId" settings="{active:true}"></logz-cloudtrail-settings></section>' : '';
            var elbBlock = isAuthenticated ? '<section id="elb-settings-section" ng-controller="ElbSettingsController"><logz-elb-settings ng-repeat="elbSettings in settings" account-id="accountId" settings="elbSettings"></logz-elb-settings><logz-elb-settings account-id="accountId" settings="{active:true}"></logz-elb-settings></section>' : '';
            var readS3Block = isAuthenticated ? '<section id="s3-settings-section" ng-controller="S3SettingsController"><logz-s3-settings ng-repeat="s3Settings in settings" account-id="accountId" settings="s3Settings"></logz-s3-settings><logz-s3-settings account-id="accountId" settings="{active:true}"></logz-s3-settings></section>' : '';

            parsedContent = parsedContent
                .replace(new RegExp('<code>', 'g'), '<logz-code-section>')
                .replace(new RegExp('</code>', 'g'), '</logz-code-section>')
                .replace(new RegExp('\\[\\[', 'g'), '<span class=\"step-header\">')
                .replace(new RegExp('\\]\\]', 'g'), '</span>');

            parsedContent = parsedContent.replace(new RegExp('\\{\\{CLOUDTRAIL\\}\\}', 'g'), cloudtrailBlock);
            parsedContent = parsedContent.replace(new RegExp('\\{\\{ELB\\}\\}', 'g'), elbBlock);
            parsedContent = parsedContent.replace(new RegExp('\\{\\{READS3\\}\\}', 'g'), readS3Block);

            var s3Regex = new RegExp('\\{\\{READS3:[0-9a-zA-Z]{1,20}\\}\\}', 'g');
            var s3Buckets = s3Regex.exec(parsedContent);
            if (s3Buckets && s3Buckets.length) {
                var bucketType = s3Buckets[0].substr(s3Buckets[0].indexOf(':') + 1).replace('}}', '');
                var genericBucket = '<generic-bucket account-id="' + $scope.summary.accountId + '" log-type="' + bucketType + '"></generic-bucket>';
                parsedContent = parsedContent.replace(s3Regex, isAuthenticated ? genericBucket : '');
            }

            var token = '<span class=\"parameter token\">' + (($scope.summary && $scope.summary.accountToken) ? $scope.summary.accountToken : '{{API_TOKEN}}') + '</span>';
            parsedContent = parsedContent.replace(new RegExp('\\{\\{API_TOKEN\\}\\}', 'g'), isAuthenticated ? token : '{{API_TOKEN}}');

            parsedContent = parsedContent.replace(new RegExp('\\{\\{LOGZ_LISTENER\\}\\}', 'g'), $scope.summary.listenerAddress || '{{LOGZ_LISTENER}}');
            var logzioZone = '{{LOGZIO_ZONE}}';
            if ($scope.summary.accountRegion) {
                logzioZone = $scope.summary.accountRegion.toLowerCase().indexOf('us') === -1
                    ? 'eu'
                    : 'us';
            }
            parsedContent = parsedContent.replace(new RegExp('\\{\\{LOGZIO_ZONE\\}\\}', 'g'), logzioZone);

            parsedContent = handleCustomDirectives(parsedContent);

            var compiled = $compile(parsedContent)($scope);
            compiled.find('logz-code-section').each(function() {
                $(this).html($(this).html().replace(new RegExp('\n\n', 'g'), '\n'));
            });

            $('#device-instructions-page').append(compiled);


            // make sure all links are opened in a new tab
            $('#device-instructions-page a').attr('target', '_blank');
        });
    };

    var handleCustomDirectives = function(content) {
        var logzDirectiveRegex = /\{\{logzDirective:(.*?)(:.*)?\}\}/g;
        var match = logzDirectiveRegex.exec(content);
        while (match) {
            var contentName = match[0];
            var directiveName = match[1];
            var arguments = match[2]
                ? [ ' ', match[2].slice(1) ].join('') // Add a leading space and remove :
                : '';
            var directiveKebabCaseName = convertCamelCaseToKebabCase(directiveName);
            var contentReplace = $injector.has([ directiveName, 'Directive' ].join(''))
                ? [ '<', directiveKebabCaseName, arguments, '></', directiveKebabCaseName, '>' ].join('')
                : '';

            content = content.replace(contentName, contentReplace);

            match = logzDirectiveRegex.exec(content);
        }

        return content;
    };

    var convertCamelCaseToKebabCase = function(str) {
        return str.split(/(?=[A-Z])/).map(function(s) {
            return s.toLowerCase();
        }).join('-');
    };
});

/* origin: public/webapp/app/dashboard/data-sources/elb.js */
angular.module('webApp').controller('ElbSettingsController', function ($scope, AuthService, Backend, UserService) {

    UserService.getSummary().then(function (res) {
        $scope.accountId = res.data.accountId;
    });

    if (!$scope.settings)
        $scope.settings = {};

    $scope.addElbSettings = function () {
        if (!$scope.settings)
            $scope.settings = [];
        $scope.settings.push({id: 0, active: true});
    };

    AuthService.getUser().then(function (res) {
        $scope.accountId = res.data.accountId;
    });

    Backend.GET('/s3buckets').then(function (elbSettingsList) {
        if (!elbSettingsList || !elbSettingsList.data)
            alert('There was an error retrieving your elb settings.\nPlease refresh the page to retry again.');

        $scope.settings = _.filter(elbSettingsList.data, function (elbSettings) {
            return elbSettings.logsType.toLowerCase() === 'elb';
        });

        _.forEach($scope.settings, function (s3Settings) {
            s3Settings.secretKey = s3Settings.encryptedSecretKey; // For the dots in the html dom
        });
    });

});
/* origin: public/webapp/app/dashboard/data-sources/markdown/markdown-it.min.js */
/*! markdown-it 4.2.1 https://github.com//markdown-it/markdown-it @license MIT */
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var r;r="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,r.markdownit=e()}}(function(){var e;return function r(e,t,n){function s(o,a){if(!t[o]){if(!e[o]){var c="function"==typeof require&&require;if(!a&&c)return c(o,!0);if(i)return i(o,!0);var l=new Error("Cannot find module '"+o+"'");throw l.code="MODULE_NOT_FOUND",l}var u=t[o]={exports:{}};e[o][0].call(u.exports,function(r){var t=e[o][1][r];return s(t?t:r)},u,u.exports,r,e,t,n)}return t[o].exports}for(var i="function"==typeof require&&require,o=0;o<n.length;o++)s(n[o]);return s}({1:[function(e,r,t){"use strict";r.exports=e("entities/maps/entities.json")},{"entities/maps/entities.json":52}],2:[function(e,r,t){"use strict";var n={};["article","aside","button","blockquote","body","canvas","caption","col","colgroup","dd","div","dl","dt","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","iframe","li","map","object","ol","output","p","pre","progress","script","section","style","table","tbody","td","textarea","tfoot","th","tr","thead","ul","video"].forEach(function(e){n[e]=!0}),r.exports=n},{}],3:[function(e,r,t){"use strict";var n="[a-zA-Z_:][a-zA-Z0-9:._-]*",s="[^\"'=<>`\\x00-\\x20]+",i="'[^']*'",o='"[^"]*"',a="(?:"+s+"|"+i+"|"+o+")",c="(?:\\s+"+n+"(?:\\s*=\\s*"+a+")?)",l="<[A-Za-z][A-Za-z0-9\\-]*"+c+"*\\s*\\/?>",u="<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>",p="<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->",h="<[?].*?[?]>",f="<![A-Z]+\\s+[^>]*>",d="<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",m=new RegExp("^(?:"+l+"|"+u+"|"+p+"|"+h+"|"+f+"|"+d+")");r.exports.HTML_TAG_RE=m},{}],4:[function(e,r,t){"use strict";r.exports=["coap","doi","javascript","aaa","aaas","about","acap","cap","cid","crid","data","dav","dict","dns","file","ftp","geo","go","gopher","h323","http","https","iax","icap","im","imap","info","ipp","iris","iris.beep","iris.xpc","iris.xpcs","iris.lwz","ldap","mailto","mid","msrp","msrps","mtqp","mupdate","news","nfs","ni","nih","nntp","opaquelocktoken","pop","pres","rtsp","service","session","shttp","sieve","sip","sips","sms","snmp","soap.beep","soap.beeps","tag","tel","telnet","tftp","thismessage","tn3270","tip","tv","urn","vemmi","ws","wss","xcon","xcon-userid","xmlrpc.beep","xmlrpc.beeps","xmpp","z39.50r","z39.50s","adiumxtra","afp","afs","aim","apt","attachment","aw","beshare","bitcoin","bolo","callto","chrome","chrome-extension","com-eventbrite-attendee","content","cvs","dlna-playsingle","dlna-playcontainer","dtn","dvb","ed2k","facetime","feed","finger","fish","gg","git","gizmoproject","gtalk","hcp","icon","ipn","irc","irc6","ircs","itms","jar","jms","keyparc","lastfm","ldaps","magnet","maps","market","message","mms","ms-help","msnim","mumble","mvn","notes","oid","palm","paparazzi","platform","proxy","psyc","query","res","resource","rmi","rsync","rtmp","secondlife","sftp","sgn","skype","smb","soldat","spotify","ssh","steam","svn","teamspeak","things","udp","unreal","ut2004","ventrilo","view-source","webcal","wtai","wyciwyg","xfire","xri","ymsgr"]},{}],5:[function(e,r,t){"use strict";function n(e){return Object.prototype.toString.call(e)}function s(e){return"[object String]"===n(e)}function i(e,r){return v.call(e,r)}function o(e){var r=Array.prototype.slice.call(arguments,1);return r.forEach(function(r){if(r){if("object"!=typeof r)throw new TypeError(r+"must be object");Object.keys(r).forEach(function(t){e[t]=r[t]})}}),e}function a(e,r,t){return[].concat(e.slice(0,r),t,e.slice(r+1))}function c(e){return e>=55296&&57343>=e?!1:e>=64976&&65007>=e?!1:65535===(65535&e)||65534===(65535&e)?!1:e>=0&&8>=e?!1:11===e?!1:e>=14&&31>=e?!1:e>=127&&159>=e?!1:e>1114111?!1:!0}function l(e){if(e>65535){e-=65536;var r=55296+(e>>10),t=56320+(1023&e);return String.fromCharCode(r,t)}return String.fromCharCode(e)}function u(e,r){var t=0;return i(w,r)?w[r]:35===r.charCodeAt(0)&&C.test(r)&&(t="x"===r[1].toLowerCase()?parseInt(r.slice(2),16):parseInt(r.slice(1),10),c(t))?l(t):e}function p(e){return e.indexOf("\\")<0?e:e.replace(x,"$1")}function h(e){return e.indexOf("\\")<0&&e.indexOf("&")<0?e:e.replace(A,function(e,r,t){return r?r:u(e,t)})}function f(e){return E[e]}function d(e){return q.test(e)?e.replace(D,f):e}function m(e){return e.replace(S,"\\$&")}function g(e){if(e>=8192&&8202>=e)return!0;switch(e){case 9:case 10:case 11:case 12:case 13:case 32:case 160:case 5760:case 8239:case 8287:case 12288:return!0}return!1}function _(e){return F.test(e)}function b(e){switch(e){case 33:case 34:case 35:case 36:case 37:case 38:case 39:case 40:case 41:case 42:case 43:case 44:case 45:case 46:case 47:case 58:case 59:case 60:case 61:case 62:case 63:case 64:case 91:case 92:case 93:case 94:case 95:case 96:case 123:case 124:case 125:case 126:return!0;default:return!1}}function k(e){return e.trim().replace(/\s+/g," ").toUpperCase()}var v=Object.prototype.hasOwnProperty,x=/\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g,y=/&([a-z#][a-z0-9]{1,31});/gi,A=new RegExp(x.source+"|"+y.source,"gi"),C=/^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i,w=e("./entities"),q=/[&<>"]/,D=/[&<>"]/g,E={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},S=/[.?*+^$[\]\\(){}|-]/g,F=e("uc.micro/categories/P/regex");t.lib={},t.lib.mdurl=e("mdurl"),t.lib.ucmicro=e("uc.micro"),t.assign=o,t.isString=s,t.has=i,t.unescapeMd=p,t.unescapeAll=h,t.isValidEntityCode=c,t.fromCodePoint=l,t.escapeHtml=d,t.arrayReplaceAt=a,t.isWhiteSpace=g,t.isMdAsciiPunct=b,t.isPunctChar=_,t.escapeRE=m,t.normalizeReference=k},{"./entities":1,mdurl:58,"uc.micro":64,"uc.micro/categories/P/regex":62}],6:[function(e,r,t){"use strict";t.parseLinkLabel=e("./parse_link_label"),t.parseLinkDestination=e("./parse_link_destination"),t.parseLinkTitle=e("./parse_link_title")},{"./parse_link_destination":7,"./parse_link_label":8,"./parse_link_title":9}],7:[function(e,r,t){"use strict";var n=e("../common/utils").unescapeAll;r.exports=function(e,r,t){var s,i,o=0,a=r,c={ok:!1,pos:0,lines:0,str:""};if(60===e.charCodeAt(r)){for(r++;t>r;){if(s=e.charCodeAt(r),10===s)return c;if(62===s)return c.pos=r+1,c.str=n(e.slice(a+1,r)),c.ok=!0,c;92===s&&t>r+1?r+=2:r++}return c}for(i=0;t>r&&(s=e.charCodeAt(r),32!==s)&&!(32>s||127===s);)if(92===s&&t>r+1)r+=2;else{if(40===s&&(i++,i>1))break;if(41===s&&(i--,0>i))break;r++}return a===r?c:(c.str=n(e.slice(a,r)),c.lines=o,c.pos=r,c.ok=!0,c)}},{"../common/utils":5}],8:[function(e,r,t){"use strict";r.exports=function(e,r,t){var n,s,i,o,a=-1,c=e.posMax,l=e.pos;for(e.pos=r+1,n=1;e.pos<c;){if(i=e.src.charCodeAt(e.pos),93===i&&(n--,0===n)){s=!0;break}if(o=e.pos,e.md.inline.skipToken(e),91===i)if(o===e.pos-1)n++;else if(t)return e.pos=l,-1}return s&&(a=e.pos),e.pos=l,a}},{}],9:[function(e,r,t){"use strict";var n=e("../common/utils").unescapeAll;r.exports=function(e,r,t){var s,i,o=0,a=r,c={ok:!1,pos:0,lines:0,str:""};if(r>=t)return c;if(i=e.charCodeAt(r),34!==i&&39!==i&&40!==i)return c;for(r++,40===i&&(i=41);t>r;){if(s=e.charCodeAt(r),s===i)return c.pos=r+1,c.lines=o,c.str=n(e.slice(a+1,r)),c.ok=!0,c;10===s?o++:92===s&&t>r+1&&(r++,10===e.charCodeAt(r)&&o++),r++}return c}},{"../common/utils":5}],10:[function(e,r,t){"use strict";function n(e){var r=e.trim().toLowerCase();return _.test(r)?b.test(r)?!0:!1:!0}function s(e){var r=d.parse(e,!0);if(r.hostname&&(!r.protocol||k.indexOf(r.protocol)>=0))try{r.hostname=m.toASCII(r.hostname)}catch(t){}return d.encode(d.format(r))}function i(e){var r=d.parse(e,!0);if(r.hostname&&(!r.protocol||k.indexOf(r.protocol)>=0))try{r.hostname=m.toUnicode(r.hostname)}catch(t){}return d.decode(d.format(r))}function o(e,r){return this instanceof o?(r||a.isString(e)||(r=e||{},e="default"),this.inline=new h,this.block=new p,this.core=new u,this.renderer=new l,this.linkify=new f,this.validateLink=n,this.normalizeLink=s,this.normalizeLinkText=i,this.utils=a,this.helpers=c,this.options={},this.configure(e),void(r&&this.set(r))):new o(e,r)}var a=e("./common/utils"),c=e("./helpers"),l=e("./renderer"),u=e("./parser_core"),p=e("./parser_block"),h=e("./parser_inline"),f=e("linkify-it"),d=e("mdurl"),m=e("punycode"),g={"default":e("./presets/default"),zero:e("./presets/zero"),commonmark:e("./presets/commonmark")},_=/^(vbscript|javascript|file|data):/,b=/^data:image\/(gif|png|jpeg|webp);/,k=["http:","https:","mailto:"];o.prototype.set=function(e){return a.assign(this.options,e),this},o.prototype.configure=function(e){var r,t=this;if(a.isString(e)&&(r=e,e=g[r],!e))throw new Error('Wrong `markdown-it` preset "'+r+'", check name');if(!e)throw new Error("Wrong `markdown-it` preset, can't be empty");return e.options&&t.set(e.options),e.components&&Object.keys(e.components).forEach(function(r){e.components[r].rules&&t[r].ruler.enableOnly(e.components[r].rules)}),this},o.prototype.enable=function(e,r){var t=[];Array.isArray(e)||(e=[e]),["core","block","inline"].forEach(function(r){t=t.concat(this[r].ruler.enable(e,!0))},this);var n=e.filter(function(e){return t.indexOf(e)<0});if(n.length&&!r)throw new Error("MarkdownIt. Failed to enable unknown rule(s): "+n);return this},o.prototype.disable=function(e,r){var t=[];Array.isArray(e)||(e=[e]),["core","block","inline"].forEach(function(r){t=t.concat(this[r].ruler.disable(e,!0))},this);var n=e.filter(function(e){return t.indexOf(e)<0});if(n.length&&!r)throw new Error("MarkdownIt. Failed to disable unknown rule(s): "+n);return this},o.prototype.use=function(e){var r=[this].concat(Array.prototype.slice.call(arguments,1));return e.apply(e,r),this},o.prototype.parse=function(e,r){var t=new this.core.State(e,this,r);return this.core.process(t),t.tokens},o.prototype.render=function(e,r){return r=r||{},this.renderer.render(this.parse(e,r),this.options,r)},o.prototype.parseInline=function(e,r){var t=new this.core.State(e,this,r);return t.inlineMode=!0,this.core.process(t),t.tokens},o.prototype.renderInline=function(e,r){return r=r||{},this.renderer.render(this.parseInline(e,r),this.options,r)},r.exports=o},{"./common/utils":5,"./helpers":6,"./parser_block":11,"./parser_core":12,"./parser_inline":13,"./presets/commonmark":14,"./presets/default":15,"./presets/zero":16,"./renderer":17,"linkify-it":53,mdurl:58,punycode:51}],11:[function(e,r,t){"use strict";function n(){this.ruler=new s;for(var e=0;e<i.length;e++)this.ruler.push(i[e][0],i[e][1],{alt:(i[e][2]||[]).slice()})}var s=e("./ruler"),i=[["code",e("./rules_block/code")],["fence",e("./rules_block/fence"),["paragraph","reference","blockquote","list"]],["blockquote",e("./rules_block/blockquote"),["paragraph","reference","list"]],["hr",e("./rules_block/hr"),["paragraph","reference","blockquote","list"]],["list",e("./rules_block/list"),["paragraph","reference","blockquote"]],["reference",e("./rules_block/reference")],["heading",e("./rules_block/heading"),["paragraph","reference","blockquote"]],["lheading",e("./rules_block/lheading")],["html_block",e("./rules_block/html_block"),["paragraph","reference","blockquote"]],["table",e("./rules_block/table"),["paragraph","reference"]],["paragraph",e("./rules_block/paragraph")]];n.prototype.tokenize=function(e,r,t){for(var n,s,i=this.ruler.getRules(""),o=i.length,a=r,c=!1,l=e.md.options.maxNesting;t>a&&(e.line=a=e.skipEmptyLines(a),!(a>=t))&&!(e.tShift[a]<e.blkIndent);){if(e.level>=l){e.line=t;break}for(s=0;o>s&&!(n=i[s](e,a,t,!1));s++);if(e.tight=!c,e.isEmpty(e.line-1)&&(c=!0),a=e.line,t>a&&e.isEmpty(a)){if(c=!0,a++,t>a&&"list"===e.parentType&&e.isEmpty(a))break;e.line=a}}},n.prototype.parse=function(e,r,t,n){var s;return e?(s=new this.State(e,r,t,n),void this.tokenize(s,s.line,s.lineMax)):[]},n.prototype.State=e("./rules_block/state_block"),r.exports=n},{"./ruler":18,"./rules_block/blockquote":19,"./rules_block/code":20,"./rules_block/fence":21,"./rules_block/heading":22,"./rules_block/hr":23,"./rules_block/html_block":24,"./rules_block/lheading":25,"./rules_block/list":26,"./rules_block/paragraph":27,"./rules_block/reference":28,"./rules_block/state_block":29,"./rules_block/table":30}],12:[function(e,r,t){"use strict";function n(){this.ruler=new s;for(var e=0;e<i.length;e++)this.ruler.push(i[e][0],i[e][1])}var s=e("./ruler"),i=[["normalize",e("./rules_core/normalize")],["block",e("./rules_core/block")],["inline",e("./rules_core/inline")],["linkify",e("./rules_core/linkify")],["replacements",e("./rules_core/replacements")],["smartquotes",e("./rules_core/smartquotes")]];n.prototype.process=function(e){var r,t,n;for(n=this.ruler.getRules(""),r=0,t=n.length;t>r;r++)n[r](e)},n.prototype.State=e("./rules_core/state_core"),r.exports=n},{"./ruler":18,"./rules_core/block":31,"./rules_core/inline":32,"./rules_core/linkify":33,"./rules_core/normalize":34,"./rules_core/replacements":35,"./rules_core/smartquotes":36,"./rules_core/state_core":37}],13:[function(e,r,t){"use strict";function n(){this.ruler=new s;for(var e=0;e<i.length;e++)this.ruler.push(i[e][0],i[e][1])}var s=e("./ruler"),i=[["text",e("./rules_inline/text")],["newline",e("./rules_inline/newline")],["escape",e("./rules_inline/escape")],["backticks",e("./rules_inline/backticks")],["strikethrough",e("./rules_inline/strikethrough")],["emphasis",e("./rules_inline/emphasis")],["link",e("./rules_inline/link")],["image",e("./rules_inline/image")],["autolink",e("./rules_inline/autolink")],["html_inline",e("./rules_inline/html_inline")],["entity",e("./rules_inline/entity")]];n.prototype.skipToken=function(e){var r,t=e.pos,n=this.ruler.getRules(""),s=n.length,i=e.md.options.maxNesting,o=e.cache;if("undefined"!=typeof o[t])return void(e.pos=o[t]);if(e.level<i)for(r=0;s>r;r++)if(n[r](e,!0))return void(o[t]=e.pos);e.pos++,o[t]=e.pos},n.prototype.tokenize=function(e){for(var r,t,n=this.ruler.getRules(""),s=n.length,i=e.posMax,o=e.md.options.maxNesting;e.pos<i;){if(e.level<o)for(t=0;s>t&&!(r=n[t](e,!1));t++);if(r){if(e.pos>=i)break}else e.pending+=e.src[e.pos++]}e.pending&&e.pushPending()},n.prototype.parse=function(e,r,t,n){var s=new this.State(e,r,t,n);this.tokenize(s)},n.prototype.State=e("./rules_inline/state_inline"),r.exports=n},{"./ruler":18,"./rules_inline/autolink":38,"./rules_inline/backticks":39,"./rules_inline/emphasis":40,"./rules_inline/entity":41,"./rules_inline/escape":42,"./rules_inline/html_inline":43,"./rules_inline/image":44,"./rules_inline/link":45,"./rules_inline/newline":46,"./rules_inline/state_inline":47,"./rules_inline/strikethrough":48,"./rules_inline/text":49}],14:[function(e,r,t){"use strict";r.exports={options:{html:!0,xhtmlOut:!0,breaks:!1,langPrefix:"language-",linkify:!1,typographer:!1,quotes:"\u201c\u201d\u2018\u2019",highlight:null,maxNesting:20},components:{core:{rules:["normalize","block","inline"]},block:{rules:["blockquote","code","fence","heading","hr","html_block","lheading","list","reference","paragraph"]},inline:{rules:["autolink","backticks","emphasis","entity","escape","html_inline","image","link","newline","text"]}}}},{}],15:[function(e,r,t){"use strict";r.exports={options:{html:!1,xhtmlOut:!1,breaks:!1,langPrefix:"language-",linkify:!1,typographer:!1,quotes:"\u201c\u201d\u2018\u2019",highlight:null,maxNesting:20},components:{core:{},block:{},inline:{}}}},{}],16:[function(e,r,t){"use strict";r.exports={options:{html:!1,xhtmlOut:!1,breaks:!1,langPrefix:"language-",linkify:!1,typographer:!1,quotes:"\u201c\u201d\u2018\u2019",highlight:null,maxNesting:20},components:{core:{rules:["normalize","block","inline"]},block:{rules:["paragraph"]},inline:{rules:["text"]}}}},{}],17:[function(e,r,t){"use strict";function n(){this.rules=s({},a)}var s=e("./common/utils").assign,i=e("./common/utils").unescapeAll,o=e("./common/utils").escapeHtml,a={};a.code_inline=function(e,r){return"<code>"+o(e[r].content)+"</code>"},a.code_block=function(e,r){return"<pre><code>"+o(e[r].content)+"</code></pre>\n"},a.fence=function(e,r,t,n,s){var a,c=e[r],l="";return c.info&&(l=i(c.info.trim().split(/\s+/g)[0]),c.attrPush(["class",t.langPrefix+l])),a=t.highlight?t.highlight(c.content,l)||o(c.content):o(c.content),"<pre><code"+s.renderAttrs(c)+">"+a+"</code></pre>\n"},a.image=function(e,r,t,n,s){var i=e[r];return i.attrs[i.attrIndex("alt")][1]=s.renderInlineAsText(i.children,t,n),s.renderToken(e,r,t)},a.hardbreak=function(e,r,t){return t.xhtmlOut?"<br />\n":"<br>\n"},a.softbreak=function(e,r,t){return t.breaks?t.xhtmlOut?"<br />\n":"<br>\n":"\n"},a.text=function(e,r){return o(e[r].content)},a.html_block=function(e,r){return e[r].content},a.html_inline=function(e,r){return e[r].content},n.prototype.renderAttrs=function(e){var r,t,n;if(!e.attrs)return"";for(n="",r=0,t=e.attrs.length;t>r;r++)n+=" "+o(e.attrs[r][0])+'="'+o(e.attrs[r][1])+'"';return n},n.prototype.renderToken=function(e,r,t){var n,s="",i=!1,o=e[r];return o.hidden?"":(o.block&&-1!==o.nesting&&r&&e[r-1].hidden&&(s+="\n"),s+=(-1===o.nesting?"</":"<")+o.tag,s+=this.renderAttrs(o),0===o.nesting&&t.xhtmlOut&&(s+=" /"),o.block&&(i=!0,1===o.nesting&&r+1<e.length&&(n=e[r+1],"inline"===n.type||n.hidden?i=!1:-1===n.nesting&&n.tag===o.tag&&(i=!1))),s+=i?">\n":">")},n.prototype.renderInline=function(e,r,t){for(var n,s="",i=this.rules,o=0,a=e.length;a>o;o++)n=e[o].type,s+="undefined"!=typeof i[n]?i[n](e,o,r,t,this):this.renderToken(e,o,r);return s},n.prototype.renderInlineAsText=function(e,r,t){for(var n="",s=this.rules,i=0,o=e.length;o>i;i++)"text"===e[i].type?n+=s.text(e,i,r,t,this):"image"===e[i].type&&(n+=this.renderInlineAsText(e[i].children,r,t));return n},n.prototype.render=function(e,r,t){var n,s,i,o="",a=this.rules;for(n=0,s=e.length;s>n;n++)i=e[n].type,o+="inline"===i?this.renderInline(e[n].children,r,t):"undefined"!=typeof a[i]?a[e[n].type](e,n,r,t,this):this.renderToken(e,n,r,t);return o},r.exports=n},{"./common/utils":5}],18:[function(e,r,t){"use strict";function n(){this.__rules__=[],this.__cache__=null}n.prototype.__find__=function(e){for(var r=0;r<this.__rules__.length;r++)if(this.__rules__[r].name===e)return r;return-1},n.prototype.__compile__=function(){var e=this,r=[""];e.__rules__.forEach(function(e){e.enabled&&e.alt.forEach(function(e){r.indexOf(e)<0&&r.push(e)})}),e.__cache__={},r.forEach(function(r){e.__cache__[r]=[],e.__rules__.forEach(function(t){t.enabled&&(r&&t.alt.indexOf(r)<0||e.__cache__[r].push(t.fn))})})},n.prototype.at=function(e,r,t){var n=this.__find__(e),s=t||{};if(-1===n)throw new Error("Parser rule not found: "+e);this.__rules__[n].fn=r,this.__rules__[n].alt=s.alt||[],this.__cache__=null},n.prototype.before=function(e,r,t,n){var s=this.__find__(e),i=n||{};if(-1===s)throw new Error("Parser rule not found: "+e);this.__rules__.splice(s,0,{name:r,enabled:!0,fn:t,alt:i.alt||[]}),this.__cache__=null},n.prototype.after=function(e,r,t,n){var s=this.__find__(e),i=n||{};if(-1===s)throw new Error("Parser rule not found: "+e);this.__rules__.splice(s+1,0,{name:r,enabled:!0,fn:t,alt:i.alt||[]}),this.__cache__=null},n.prototype.push=function(e,r,t){var n=t||{};this.__rules__.push({name:e,enabled:!0,fn:r,alt:n.alt||[]}),this.__cache__=null},n.prototype.enable=function(e,r){Array.isArray(e)||(e=[e]);var t=[];return e.forEach(function(e){var n=this.__find__(e);if(0>n){if(r)return;throw new Error("Rules manager: invalid rule name "+e)}this.__rules__[n].enabled=!0,t.push(e)},this),this.__cache__=null,t},n.prototype.enableOnly=function(e,r){Array.isArray(e)||(e=[e]),this.__rules__.forEach(function(e){e.enabled=!1}),this.enable(e,r)},n.prototype.disable=function(e,r){Array.isArray(e)||(e=[e]);var t=[];return e.forEach(function(e){var n=this.__find__(e);if(0>n){if(r)return;throw new Error("Rules manager: invalid rule name "+e)}this.__rules__[n].enabled=!1,t.push(e)},this),this.__cache__=null,t},n.prototype.getRules=function(e){return null===this.__cache__&&this.__compile__(),this.__cache__[e]||[]},r.exports=n},{}],19:[function(e,r,t){"use strict";r.exports=function(e,r,t,n){var s,i,o,a,c,l,u,p,h,f,d,m,g=e.bMarks[r]+e.tShift[r],_=e.eMarks[r];if(62!==e.src.charCodeAt(g++))return!1;if(n)return!0;for(32===e.src.charCodeAt(g)&&g++,c=e.blkIndent,e.blkIndent=0,a=[e.bMarks[r]],e.bMarks[r]=g,g=_>g?e.skipSpaces(g):g,i=g>=_,o=[e.tShift[r]],e.tShift[r]=g-e.bMarks[r],p=e.md.block.ruler.getRules("blockquote"),s=r+1;t>s&&(g=e.bMarks[s]+e.tShift[s],_=e.eMarks[s],!(g>=_));s++)if(62!==e.src.charCodeAt(g++)){if(i)break;for(m=!1,f=0,d=p.length;d>f;f++)if(p[f](e,s,t,!0)){m=!0;break}if(m)break;a.push(e.bMarks[s]),o.push(e.tShift[s]),e.tShift[s]=-1337}else 32===e.src.charCodeAt(g)&&g++,a.push(e.bMarks[s]),e.bMarks[s]=g,g=_>g?e.skipSpaces(g):g,i=g>=_,o.push(e.tShift[s]),e.tShift[s]=g-e.bMarks[s];for(l=e.parentType,e.parentType="blockquote",h=e.push("blockquote_open","blockquote",1),h.markup=">",h.map=u=[r,0],e.md.block.tokenize(e,r,s),h=e.push("blockquote_close","blockquote",-1),h.markup=">",e.parentType=l,u[1]=e.line,f=0;f<o.length;f++)e.bMarks[f+r]=a[f],e.tShift[f+r]=o[f];return e.blkIndent=c,!0}},{}],20:[function(e,r,t){"use strict";r.exports=function(e,r,t){var n,s,i;if(e.tShift[r]-e.blkIndent<4)return!1;for(s=n=r+1;t>n;)if(e.isEmpty(n))n++;else{if(!(e.tShift[n]-e.blkIndent>=4))break;n++,s=n}return e.line=n,i=e.push("code_block","code",0),i.content=e.getLines(r,s,4+e.blkIndent,!0),i.map=[r,e.line],!0}},{}],21:[function(e,r,t){"use strict";r.exports=function(e,r,t,n){var s,i,o,a,c,l,u,p=!1,h=e.bMarks[r]+e.tShift[r],f=e.eMarks[r];if(h+3>f)return!1;if(s=e.src.charCodeAt(h),126!==s&&96!==s)return!1;if(c=h,h=e.skipChars(h,s),i=h-c,3>i)return!1;if(u=e.src.slice(c,h),o=e.src.slice(h,f),o.indexOf("`")>=0)return!1;if(n)return!0;for(a=r;(a++,!(a>=t))&&(h=c=e.bMarks[a]+e.tShift[a],f=e.eMarks[a],!(f>h&&e.tShift[a]<e.blkIndent));)if(e.src.charCodeAt(h)===s&&!(e.tShift[a]-e.blkIndent>=4||(h=e.skipChars(h,s),i>h-c||(h=e.skipSpaces(h),f>h)))){p=!0;break}return i=e.tShift[r],e.line=a+(p?1:0),l=e.push("fence","code",0),l.info=o,l.content=e.getLines(r+1,a,i,!0),l.markup=u,l.map=[r,e.line],!0}},{}],22:[function(e,r,t){"use strict";r.exports=function(e,r,t,n){var s,i,o,a,c=e.bMarks[r]+e.tShift[r],l=e.eMarks[r];if(s=e.src.charCodeAt(c),35!==s||c>=l)return!1;for(i=1,s=e.src.charCodeAt(++c);35===s&&l>c&&6>=i;)i++,s=e.src.charCodeAt(++c);return i>6||l>c&&32!==s?!1:n?!0:(l=e.skipCharsBack(l,32,c),o=e.skipCharsBack(l,35,c),o>c&&32===e.src.charCodeAt(o-1)&&(l=o),e.line=r+1,a=e.push("heading_open","h"+String(i),1),a.markup="########".slice(0,i),a.map=[r,e.line],a=e.push("inline","",0),a.content=e.src.slice(c,l).trim(),a.map=[r,e.line],a.children=[],a=e.push("heading_close","h"+String(i),-1),a.markup="########".slice(0,i),!0)}},{}],23:[function(e,r,t){"use strict";r.exports=function(e,r,t,n){var s,i,o,a,c=e.bMarks[r]+e.tShift[r],l=e.eMarks[r];if(s=e.src.charCodeAt(c++),42!==s&&45!==s&&95!==s)return!1;for(i=1;l>c;){if(o=e.src.charCodeAt(c++),o!==s&&32!==o)return!1;o===s&&i++}return 3>i?!1:n?!0:(e.line=r+1,a=e.push("hr","hr",0),a.map=[r,e.line],a.markup=Array(i+1).join(String.fromCharCode(s)),!0)}},{}],24:[function(e,r,t){"use strict";function n(e){var r=32|e;return r>=97&&122>=r}var s=e("../common/html_blocks"),i=/^<([a-zA-Z][a-zA-Z0-9]{0,14})[\s\/>]/,o=/^<\/([a-zA-Z][a-zA-Z0-9]{0,14})[\s>]/;r.exports=function(e,r,t,a){var c,l,u,p,h=e.bMarks[r],f=e.eMarks[r],d=e.tShift[r];if(h+=d,!e.md.options.html)return!1;if(d>3||h+2>=f)return!1;if(60!==e.src.charCodeAt(h))return!1;if(c=e.src.charCodeAt(h+1),33===c||63===c){if(a)return!0}else{if(47!==c&&!n(c))return!1;if(47===c){if(l=e.src.slice(h,f).match(o),!l)return!1}else if(l=e.src.slice(h,f).match(i),!l)return!1;if(s[l[1].toLowerCase()]!==!0)return!1;if(a)return!0}for(u=r+1;u<e.lineMax&&!e.isEmpty(u);)u++;return e.line=u,p=e.push("html_block","",0),p.map=[r,e.line],p.content=e.getLines(r,u,0,!0),!0}},{"../common/html_blocks":2}],25:[function(e,r,t){"use strict";r.exports=function(e,r,t){var n,s,i,o,a,c=r+1;return c>=t?!1:e.tShift[c]<e.blkIndent?!1:e.tShift[c]-e.blkIndent>3?!1:(s=e.bMarks[c]+e.tShift[c],i=e.eMarks[c],s>=i?!1:(n=e.src.charCodeAt(s),45!==n&&61!==n?!1:(s=e.skipChars(s,n),s=e.skipSpaces(s),i>s?!1:(s=e.bMarks[r]+e.tShift[r],e.line=c+1,a=61===n?1:2,o=e.push("heading_open","h"+String(a),1),o.markup=String.fromCharCode(n),o.map=[r,e.line],o=e.push("inline","",0),o.content=e.src.slice(s,e.eMarks[r]).trim(),o.map=[r,e.line-1],o.children=[],o=e.push("heading_close","h"+String(a),-1),o.markup=String.fromCharCode(n),!0))))}},{}],26:[function(e,r,t){"use strict";function n(e,r){var t,n,s;return n=e.bMarks[r]+e.tShift[r],s=e.eMarks[r],t=e.src.charCodeAt(n++),42!==t&&45!==t&&43!==t?-1:s>n&&32!==e.src.charCodeAt(n)?-1:n}function s(e,r){var t,n=e.bMarks[r]+e.tShift[r],s=e.eMarks[r];if(n+1>=s)return-1;if(t=e.src.charCodeAt(n++),48>t||t>57)return-1;for(;;){if(n>=s)return-1;if(t=e.src.charCodeAt(n++),!(t>=48&&57>=t)){if(41===t||46===t)break;return-1}}return s>n&&32!==e.src.charCodeAt(n)?-1:n}function i(e,r){var t,n,s=e.level+2;for(t=r+2,n=e.tokens.length-2;n>t;t++)e.tokens[t].level===s&&"paragraph_open"===e.tokens[t].type&&(e.tokens[t+2].hidden=!0,e.tokens[t].hidden=!0,t+=2)}r.exports=function(e,r,t,o){var a,c,l,u,p,h,f,d,m,g,_,b,k,v,x,y,A,C,w,q,D,E,S,F=!0;if((d=s(e,r))>=0)k=!0;else{if(!((d=n(e,r))>=0))return!1;k=!1}if(b=e.src.charCodeAt(d-1),o)return!0;for(x=e.tokens.length,k?(f=e.bMarks[r]+e.tShift[r],_=Number(e.src.substr(f,d-f-1)),q=e.push("ordered_list_open","ol",1),_>1&&(q.attrs=[["start",_]])):q=e.push("bullet_list_open","ul",1),q.map=A=[r,0],q.markup=String.fromCharCode(b),a=r,y=!1,w=e.md.block.ruler.getRules("list");!(!(t>a)||(v=e.skipSpaces(d),m=e.eMarks[a],g=v>=m?1:v-d,g>4&&(g=1),c=d-e.bMarks[a]+g,q=e.push("list_item_open","li",1),q.markup=String.fromCharCode(b),q.map=C=[r,0],u=e.blkIndent,p=e.tight,l=e.tShift[r],h=e.parentType,e.tShift[r]=v-e.bMarks[r],e.blkIndent=c,e.tight=!0,e.parentType="list",e.md.block.tokenize(e,r,t,!0),(!e.tight||y)&&(F=!1),y=e.line-r>1&&e.isEmpty(e.line-1),e.blkIndent=u,e.tShift[r]=l,e.tight=p,e.parentType=h,q=e.push("list_item_close","li",-1),q.markup=String.fromCharCode(b),a=r=e.line,C[1]=a,v=e.bMarks[r],a>=t)||e.isEmpty(a)||e.tShift[a]<e.blkIndent);){for(S=!1,D=0,E=w.length;E>D;D++)if(w[D](e,a,t,!0)){S=!0;break}if(S)break;if(k){if(d=s(e,a),0>d)break}else if(d=n(e,a),0>d)break;if(b!==e.src.charCodeAt(d-1))break}return q=k?e.push("ordered_list_close","ol",-1):e.push("bullet_list_close","ul",-1),q.markup=String.fromCharCode(b),A[1]=a,e.line=a,F&&i(e,x),!0}},{}],27:[function(e,r,t){"use strict";r.exports=function(e,r){for(var t,n,s,i,o,a=r+1,c=e.md.block.ruler.getRules("paragraph"),l=e.lineMax;l>a&&!e.isEmpty(a);a++)if(!(e.tShift[a]-e.blkIndent>3)){for(n=!1,s=0,i=c.length;i>s;s++)if(c[s](e,a,l,!0)){n=!0;break}if(n)break}return t=e.getLines(r,a,e.blkIndent,!1).trim(),e.line=a,o=e.push("paragraph_open","p",1),o.map=[r,e.line],o=e.push("inline","",0),o.content=t,o.map=[r,e.line],o.children=[],o=e.push("paragraph_close","p",-1),!0}},{}],28:[function(e,r,t){"use strict";var n=e("../helpers/parse_link_destination"),s=e("../helpers/parse_link_title"),i=e("../common/utils").normalizeReference;r.exports=function(e,r,t,o){var a,c,l,u,p,h,f,d,m,g,_,b,k,v,x,y=0,A=e.bMarks[r]+e.tShift[r],C=e.eMarks[r],w=r+1;if(91!==e.src.charCodeAt(A))return!1;for(;++A<C;)if(93===e.src.charCodeAt(A)&&92!==e.src.charCodeAt(A-1)){if(A+1===C)return!1;if(58!==e.src.charCodeAt(A+1))return!1;break}for(u=e.lineMax,v=e.md.block.ruler.getRules("reference");u>w&&!e.isEmpty(w);w++)if(!(e.tShift[w]-e.blkIndent>3)){for(k=!1,h=0,f=v.length;f>h;h++)if(v[h](e,w,u,!0)){k=!0;break}if(k)break}for(b=e.getLines(r,w,e.blkIndent,!1).trim(),C=b.length,A=1;C>A;A++){if(a=b.charCodeAt(A),91===a)return!1;if(93===a){m=A;break}10===a?y++:92===a&&(A++,C>A&&10===b.charCodeAt(A)&&y++)}if(0>m||58!==b.charCodeAt(m+1))return!1;for(A=m+2;C>A;A++)if(a=b.charCodeAt(A),10===a)y++;else if(32!==a)break;if(g=n(b,A,C),!g.ok)return!1;if(p=e.md.normalizeLink(g.str),!e.md.validateLink(p))return!1;for(A=g.pos,y+=g.lines,c=A,l=y,_=A;C>A;A++)if(a=b.charCodeAt(A),10===a)y++;else if(32!==a)break;for(g=s(b,A,C),C>A&&_!==A&&g.ok?(x=g.str,A=g.pos,y+=g.lines):(x="",A=c,y=l);C>A&&32===b.charCodeAt(A);)A++;return C>A&&10!==b.charCodeAt(A)?!1:o?!0:(d=i(b.slice(1,m)),"undefined"==typeof e.env.references&&(e.env.references={}),"undefined"==typeof e.env.references[d]&&(e.env.references[d]={title:x,href:p}),e.line=r+y+1,!0)}},{"../common/utils":5,"../helpers/parse_link_destination":7,"../helpers/parse_link_title":9}],29:[function(e,r,t){"use strict";function n(e,r,t,n){var s,i,o,a,c,l,u;for(this.src=e,this.md=r,this.env=t,this.tokens=n,this.bMarks=[],this.eMarks=[],this.tShift=[],this.blkIndent=0,this.line=0,this.lineMax=0,this.tight=!1,this.parentType="root",this.ddIndent=-1,this.level=0,this.result="",i=this.src,l=0,u=!1,o=a=l=0,c=i.length;c>a;a++){if(s=i.charCodeAt(a),!u){if(32===s){l++;continue}u=!0}(10===s||a===c-1)&&(10!==s&&a++,this.bMarks.push(o),this.eMarks.push(a),this.tShift.push(l),u=!1,l=0,o=a+1)}this.bMarks.push(i.length),this.eMarks.push(i.length),this.tShift.push(0),this.lineMax=this.bMarks.length-1}var s=e("../token");n.prototype.push=function(e,r,t){var n=new s(e,r,t);return n.block=!0,0>t&&this.level--,n.level=this.level,t>0&&this.level++,this.tokens.push(n),n},n.prototype.isEmpty=function(e){return this.bMarks[e]+this.tShift[e]>=this.eMarks[e]},n.prototype.skipEmptyLines=function(e){for(var r=this.lineMax;r>e&&!(this.bMarks[e]+this.tShift[e]<this.eMarks[e]);e++);return e},n.prototype.skipSpaces=function(e){for(var r=this.src.length;r>e&&32===this.src.charCodeAt(e);e++);return e},n.prototype.skipChars=function(e,r){for(var t=this.src.length;t>e&&this.src.charCodeAt(e)===r;e++);return e},n.prototype.skipCharsBack=function(e,r,t){if(t>=e)return e;for(;e>t;)if(r!==this.src.charCodeAt(--e))return e+1;return e},n.prototype.getLines=function(e,r,t,n){var s,i,o,a,c,l=e;if(e>=r)return"";if(l+1===r)return i=this.bMarks[l]+Math.min(this.tShift[l],t),o=n?this.bMarks[r]:this.eMarks[r-1],this.src.slice(i,o);for(a=new Array(r-e),s=0;r>l;l++,s++)c=this.tShift[l],c>t&&(c=t),0>c&&(c=0),i=this.bMarks[l]+c,o=r>l+1||n?this.eMarks[l]+1:this.eMarks[l],a[s]=this.src.slice(i,o);return a.join("")},n.prototype.Token=s,r.exports=n},{"../token":50}],30:[function(e,r,t){"use strict";function n(e,r){var t=e.bMarks[r]+e.blkIndent,n=e.eMarks[r];return e.src.substr(t,n-t)}function s(e){var r,t=[],n=0,s=e.length,i=0,o=0,a=!1,c=0;for(r=e.charCodeAt(n);s>n;)96===r&&i%2===0?(a=!a,c=n):124!==r||i%2!==0||a?92===r?i++:i=0:(t.push(e.substring(o,n)),o=n+1),n++,n===s&&a&&(a=!1,n=c+1),r=e.charCodeAt(n);return t.push(e.substring(o)),t}r.exports=function(e,r,t,i){var o,a,c,l,u,p,h,f,d,m,g;if(r+2>t)return!1;if(u=r+1,e.tShift[u]<e.blkIndent)return!1;if(c=e.bMarks[u]+e.tShift[u],c>=e.eMarks[u])return!1;if(o=e.src.charCodeAt(c),124!==o&&45!==o&&58!==o)return!1;if(a=n(e,r+1),!/^[-:| ]+$/.test(a))return!1;if(p=a.split("|"),p.length<2)return!1;for(f=[],l=0;l<p.length;l++){if(d=p[l].trim(),!d){if(0===l||l===p.length-1)continue;return!1}if(!/^:?-+:?$/.test(d))return!1;f.push(58===d.charCodeAt(d.length-1)?58===d.charCodeAt(0)?"center":"right":58===d.charCodeAt(0)?"left":"")}if(a=n(e,r).trim(),-1===a.indexOf("|"))return!1;if(p=s(a.replace(/^\||\|$/g,"")),f.length!==p.length)return!1;if(i)return!0;for(h=e.push("table_open","table",1),h.map=m=[r,0],h=e.push("thead_open","thead",1),h.map=[r,r+1],h=e.push("tr_open","tr",1),h.map=[r,r+1],l=0;l<p.length;l++)h=e.push("th_open","th",1),h.map=[r,r+1],f[l]&&(h.attrs=[["style","text-align:"+f[l]]]),h=e.push("inline","",0),h.content=p[l].trim(),h.map=[r,r+1],h.children=[],h=e.push("th_close","th",-1);for(h=e.push("tr_close","tr",-1),h=e.push("thead_close","thead",-1),h=e.push("tbody_open","tbody",1),h.map=g=[r+2,0],u=r+2;t>u&&!(e.tShift[u]<e.blkIndent)&&(a=n(e,u).trim(),-1!==a.indexOf("|"));u++){for(p=s(a.replace(/^\||\|$/g,"")),p.length=f.length,h=e.push("tr_open","tr",1),l=0;l<p.length;l++)h=e.push("td_open","td",1),f[l]&&(h.attrs=[["style","text-align:"+f[l]]]),h=e.push("inline","",0),h.content=p[l]?p[l].trim():"",h.children=[],h=e.push("td_close","td",-1);h=e.push("tr_close","tr",-1)}return h=e.push("tbody_close","tbody",-1),h=e.push("table_close","table",-1),m[1]=g[1]=u,e.line=u,!0}},{}],31:[function(e,r,t){"use strict";r.exports=function(e){
    var r;e.inlineMode?(r=new e.Token("inline","",0),r.content=e.src,r.map=[0,1],r.children=[],e.tokens.push(r)):e.md.block.parse(e.src,e.md,e.env,e.tokens)}},{}],32:[function(e,r,t){"use strict";r.exports=function(e){var r,t,n,s=e.tokens;for(t=0,n=s.length;n>t;t++)r=s[t],"inline"===r.type&&e.md.inline.parse(r.content,e.md,e.env,r.children)}},{}],33:[function(e,r,t){"use strict";function n(e){return/^<a[>\s]/i.test(e)}function s(e){return/^<\/a\s*>/i.test(e)}var i=e("../common/utils").arrayReplaceAt;r.exports=function(e){var r,t,o,a,c,l,u,p,h,f,d,m,g,_,b,k,v,x=e.tokens;if(e.md.options.linkify)for(t=0,o=x.length;o>t;t++)if("inline"===x[t].type&&e.md.linkify.pretest(x[t].content))for(a=x[t].children,g=0,r=a.length-1;r>=0;r--)if(l=a[r],"link_close"!==l.type){if("html_inline"===l.type&&(n(l.content)&&g>0&&g--,s(l.content)&&g++),!(g>0)&&"text"===l.type&&e.md.linkify.test(l.content)){for(h=l.content,v=e.md.linkify.match(h),u=[],m=l.level,d=0,p=0;p<v.length;p++)_=v[p].url,b=e.md.normalizeLink(_),e.md.validateLink(b)&&(k=v[p].text,k=v[p].schema?"mailto:"!==v[p].schema||/^mailto:/i.test(k)?e.md.normalizeLinkText(k):e.md.normalizeLinkText("mailto:"+k).replace(/^mailto:/,""):e.md.normalizeLinkText("http://"+k).replace(/^http:\/\//,""),f=v[p].index,f>d&&(c=new e.Token("text","",0),c.content=h.slice(d,f),c.level=m,u.push(c)),c=new e.Token("link_open","a",1),c.attrs=[["href",b]],c.level=m++,c.markup="linkify",c.info="auto",u.push(c),c=new e.Token("text","",0),c.content=k,c.level=m,u.push(c),c=new e.Token("link_close","a",-1),c.level=--m,c.markup="linkify",c.info="auto",u.push(c),d=v[p].lastIndex);d<h.length&&(c=new e.Token("text","",0),c.content=h.slice(d),c.level=m,u.push(c)),x[t].children=a=i(a,r,u)}}else for(r--;a[r].level!==l.level&&"link_open"!==a[r].type;)r--}},{"../common/utils":5}],34:[function(e,r,t){"use strict";var n=/[\n\t]/g,s=/\r[\n\u0085]|[\u2424\u2028\u0085]/g,i=/\u0000/g;r.exports=function(e){var r,t,o;r=e.src.replace(s,"\n"),r=r.replace(i,"\ufffd"),r.indexOf("	")>=0&&(t=0,o=0,r=r.replace(n,function(e,n){var s;return 10===r.charCodeAt(n)?(t=n+1,o=0,e):(s="    ".slice((n-t-o)%4),o=n-t+1,s)})),e.src=r}},{}],35:[function(e,r,t){"use strict";function n(e,r){return l[r.toLowerCase()]}function s(e){var r,t;for(r=e.length-1;r>=0;r--)t=e[r],"text"===t.type&&(t.content=t.content.replace(c,n))}function i(e){var r,t;for(r=e.length-1;r>=0;r--)t=e[r],"text"===t.type&&o.test(t.content)&&(t.content=t.content.replace(/\+-/g,"\xb1").replace(/\.{2,}/g,"\u2026").replace(/([?!])\u2026/g,"$1..").replace(/([?!]){4,}/g,"$1$1$1").replace(/,{2,}/g,",").replace(/(^|[^-])---([^-]|$)/gm,"$1\u2014$2").replace(/(^|\s)--(\s|$)/gm,"$1\u2013$2").replace(/(^|[^-\s])--([^-\s]|$)/gm,"$1\u2013$2"))}var o=/\+-|\.\.|\?\?\?\?|!!!!|,,|--/,a=/\((c|tm|r|p)\)/i,c=/\((c|tm|r|p)\)/gi,l={c:"\xa9",r:"\xae",p:"\xa7",tm:"\u2122"};r.exports=function(e){var r;if(e.md.options.typographer)for(r=e.tokens.length-1;r>=0;r--)"inline"===e.tokens[r].type&&(a.test(e.tokens[r].content)&&s(e.tokens[r].children),o.test(e.tokens[r].content)&&i(e.tokens[r].children))}},{}],36:[function(e,r,t){"use strict";function n(e,r,t){return e.substr(0,r)+t+e.substr(r+1)}function s(e,r){var t,s,c,p,h,f,d,m,g,_,b,k,v,x,y,A,C,w,q;for(q=[],t=0;t<e.length;t++){for(s=e[t],d=e[t].level,C=q.length-1;C>=0&&!(q[C].level<=d);C--);if(q.length=C+1,"text"===s.type){c=s.content,h=0,f=c.length;e:for(;f>h&&(l.lastIndex=h,p=l.exec(c));)if(y=A=!0,h=p.index+1,w="'"===p[0],g=p.index-1>=0?c.charCodeAt(p.index-1):32,_=f>h?c.charCodeAt(h):32,b=a(g)||o(String.fromCharCode(g)),k=a(_)||o(String.fromCharCode(_)),v=i(g),x=i(_),x?y=!1:k&&(v||b||(y=!1)),v?A=!1:b&&(x||k||(A=!1)),34===_&&'"'===p[0]&&g>=48&&57>=g&&(A=y=!1),y&&A&&(y=!1,A=k),y||A){if(A)for(C=q.length-1;C>=0&&(m=q[C],!(q[C].level<d));C--)if(m.single===w&&q[C].level===d){m=q[C],w?(e[m.token].content=n(e[m.token].content,m.pos,r.md.options.quotes[2]),s.content=n(s.content,p.index,r.md.options.quotes[3])):(e[m.token].content=n(e[m.token].content,m.pos,r.md.options.quotes[0]),s.content=n(s.content,p.index,r.md.options.quotes[1])),q.length=C;continue e}y?q.push({token:t,pos:p.index,single:w,level:d}):A&&w&&(s.content=n(s.content,p.index,u))}else w&&(s.content=n(s.content,p.index,u))}}}var i=e("../common/utils").isWhiteSpace,o=e("../common/utils").isPunctChar,a=e("../common/utils").isMdAsciiPunct,c=/['"]/,l=/['"]/g,u="\u2019";r.exports=function(e){var r;if(e.md.options.typographer)for(r=e.tokens.length-1;r>=0;r--)"inline"===e.tokens[r].type&&c.test(e.tokens[r].content)&&s(e.tokens[r].children,e)}},{"../common/utils":5}],37:[function(e,r,t){"use strict";function n(e,r,t){this.src=e,this.env=t,this.tokens=[],this.inlineMode=!1,this.md=r}var s=e("../token");n.prototype.Token=s,r.exports=n},{"../token":50}],38:[function(e,r,t){"use strict";var n=e("../common/url_schemas"),s=/^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/,i=/^<([a-zA-Z.\-]{1,25}):([^<>\x00-\x20]*)>/;r.exports=function(e,r){var t,o,a,c,l,u,p=e.pos;return 60!==e.src.charCodeAt(p)?!1:(t=e.src.slice(p),t.indexOf(">")<0?!1:i.test(t)?(o=t.match(i),n.indexOf(o[1].toLowerCase())<0?!1:(c=o[0].slice(1,-1),l=e.md.normalizeLink(c),e.md.validateLink(l)?(r||(u=e.push("link_open","a",1),u.attrs=[["href",l]],u=e.push("text","",0),u.content=e.md.normalizeLinkText(c),u=e.push("link_close","a",-1)),e.pos+=o[0].length,!0):!1)):s.test(t)?(a=t.match(s),c=a[0].slice(1,-1),l=e.md.normalizeLink("mailto:"+c),e.md.validateLink(l)?(r||(u=e.push("link_open","a",1),u.attrs=[["href",l]],u.markup="autolink",u.info="auto",u=e.push("text","",0),u.content=e.md.normalizeLinkText(c),u=e.push("link_close","a",-1),u.markup="autolink",u.info="auto"),e.pos+=a[0].length,!0):!1):!1)}},{"../common/url_schemas":4}],39:[function(e,r,t){"use strict";r.exports=function(e,r){var t,n,s,i,o,a,c=e.pos,l=e.src.charCodeAt(c);if(96!==l)return!1;for(t=c,c++,n=e.posMax;n>c&&96===e.src.charCodeAt(c);)c++;for(s=e.src.slice(t,c),i=o=c;-1!==(i=e.src.indexOf("`",o));){for(o=i+1;n>o&&96===e.src.charCodeAt(o);)o++;if(o-i===s.length)return r||(a=e.push("code_inline","code",0),a.markup=s,a.content=e.src.slice(c,i).replace(/[ \n]+/g," ").trim()),e.pos=o,!0}return r||(e.pending+=s),e.pos+=s.length,!0}},{}],40:[function(e,r,t){"use strict";function n(e,r){var t,n,a,c,l,u,p,h,f,d=r,m=!0,g=!0,_=e.posMax,b=e.src.charCodeAt(r);for(t=r>0?e.src.charCodeAt(r-1):32;_>d&&e.src.charCodeAt(d)===b;)d++;return a=d-r,n=_>d?e.src.charCodeAt(d):32,p=o(t)||i(String.fromCharCode(t)),f=o(n)||i(String.fromCharCode(n)),u=s(t),h=s(n),h?m=!1:f&&(u||p||(m=!1)),u?g=!1:p&&(h||f||(g=!1)),95===b?(c=m&&(!g||p),l=g&&(!m||f)):(c=m,l=g),{can_open:c,can_close:l,delims:a}}var s=e("../common/utils").isWhiteSpace,i=e("../common/utils").isPunctChar,o=e("../common/utils").isMdAsciiPunct;r.exports=function(e,r){var t,s,i,o,a,c,l,u,p=e.posMax,h=e.pos,f=e.src.charCodeAt(h);if(95!==f&&42!==f)return!1;if(r)return!1;if(l=n(e,h),t=l.delims,!l.can_open)return e.pos+=t,e.pending+=e.src.slice(h,e.pos),!0;for(e.pos=h+t,c=[t];e.pos<p;)if(e.src.charCodeAt(e.pos)!==f)e.md.inline.skipToken(e);else{if(l=n(e,e.pos),s=l.delims,l.can_close){for(o=c.pop(),a=s;o!==a;){if(o>a){c.push(o-a);break}if(a-=o,0===c.length)break;e.pos+=o,o=c.pop()}if(0===c.length){t=o,i=!0;break}e.pos+=s;continue}l.can_open&&c.push(s),e.pos+=s}if(!i)return e.pos=h,!1;for(e.posMax=e.pos,e.pos=h+t,s=t;s>1;s-=2)u=e.push("strong_open","strong",1),u.markup=String.fromCharCode(f)+String.fromCharCode(f);for(s%2&&(u=e.push("em_open","em",1),u.markup=String.fromCharCode(f)),e.md.inline.tokenize(e),s%2&&(u=e.push("em_close","em",-1),u.markup=String.fromCharCode(f)),s=t;s>1;s-=2)u=e.push("strong_close","strong",-1),u.markup=String.fromCharCode(f)+String.fromCharCode(f);return e.pos=e.posMax+t,e.posMax=p,!0}},{"../common/utils":5}],41:[function(e,r,t){"use strict";var n=e("../common/entities"),s=e("../common/utils").has,i=e("../common/utils").isValidEntityCode,o=e("../common/utils").fromCodePoint,a=/^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i,c=/^&([a-z][a-z0-9]{1,31});/i;r.exports=function(e,r){var t,l,u,p=e.pos,h=e.posMax;if(38!==e.src.charCodeAt(p))return!1;if(h>p+1)if(t=e.src.charCodeAt(p+1),35===t){if(u=e.src.slice(p).match(a))return r||(l="x"===u[1][0].toLowerCase()?parseInt(u[1].slice(1),16):parseInt(u[1],10),e.pending+=o(i(l)?l:65533)),e.pos+=u[0].length,!0}else if(u=e.src.slice(p).match(c),u&&s(n,u[1]))return r||(e.pending+=n[u[1]]),e.pos+=u[0].length,!0;return r||(e.pending+="&"),e.pos++,!0}},{"../common/entities":1,"../common/utils":5}],42:[function(e,r,t){"use strict";for(var n=[],s=0;256>s;s++)n.push(0);"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(e){n[e.charCodeAt(0)]=1}),r.exports=function(e,r){var t,s=e.pos,i=e.posMax;if(92!==e.src.charCodeAt(s))return!1;if(s++,i>s){if(t=e.src.charCodeAt(s),256>t&&0!==n[t])return r||(e.pending+=e.src[s]),e.pos+=2,!0;if(10===t){for(r||e.push("hardbreak","br",0),s++;i>s&&32===e.src.charCodeAt(s);)s++;return e.pos=s,!0}}return r||(e.pending+="\\"),e.pos++,!0}},{}],43:[function(e,r,t){"use strict";function n(e){var r=32|e;return r>=97&&122>=r}var s=e("../common/html_re").HTML_TAG_RE;r.exports=function(e,r){var t,i,o,a,c=e.pos;return e.md.options.html?(o=e.posMax,60!==e.src.charCodeAt(c)||c+2>=o?!1:(t=e.src.charCodeAt(c+1),(33===t||63===t||47===t||n(t))&&(i=e.src.slice(c).match(s))?(r||(a=e.push("html_inline","",0),a.content=e.src.slice(c,c+i[0].length)),e.pos+=i[0].length,!0):!1)):!1}},{"../common/html_re":3}],44:[function(e,r,t){"use strict";var n=e("../helpers/parse_link_label"),s=e("../helpers/parse_link_destination"),i=e("../helpers/parse_link_title"),o=e("../common/utils").normalizeReference;r.exports=function(e,r){var t,a,c,l,u,p,h,f,d,m,g,_,b="",k=e.pos,v=e.posMax;if(33!==e.src.charCodeAt(e.pos))return!1;if(91!==e.src.charCodeAt(e.pos+1))return!1;if(u=e.pos+2,l=n(e,e.pos+1,!1),0>l)return!1;if(p=l+1,v>p&&40===e.src.charCodeAt(p)){for(p++;v>p&&(a=e.src.charCodeAt(p),32===a||10===a);p++);if(p>=v)return!1;for(_=p,f=s(e.src,p,e.posMax),f.ok&&(b=e.md.normalizeLink(f.str),e.md.validateLink(b)?p=f.pos:b=""),_=p;v>p&&(a=e.src.charCodeAt(p),32===a||10===a);p++);if(f=i(e.src,p,e.posMax),v>p&&_!==p&&f.ok)for(d=f.str,p=f.pos;v>p&&(a=e.src.charCodeAt(p),32===a||10===a);p++);else d="";if(p>=v||41!==e.src.charCodeAt(p))return e.pos=k,!1;p++}else{if("undefined"==typeof e.env.references)return!1;for(;v>p&&(a=e.src.charCodeAt(p),32===a||10===a);p++);if(v>p&&91===e.src.charCodeAt(p)?(_=p+1,p=n(e,p),p>=0?c=e.src.slice(_,p++):p=l+1):p=l+1,c||(c=e.src.slice(u,l)),h=e.env.references[o(c)],!h)return e.pos=k,!1;b=h.href,d=h.title}if(!r){e.pos=u,e.posMax=l;var x=new e.md.inline.State(e.src.slice(u,l),e.md,e.env,g=[]);x.md.inline.tokenize(x),m=e.push("image","img",0),m.attrs=t=[["src",b],["alt",""]],m.children=g,d&&t.push(["title",d])}return e.pos=p,e.posMax=v,!0}},{"../common/utils":5,"../helpers/parse_link_destination":7,"../helpers/parse_link_label":8,"../helpers/parse_link_title":9}],45:[function(e,r,t){"use strict";var n=e("../helpers/parse_link_label"),s=e("../helpers/parse_link_destination"),i=e("../helpers/parse_link_title"),o=e("../common/utils").normalizeReference;r.exports=function(e,r){var t,a,c,l,u,p,h,f,d,m,g="",_=e.pos,b=e.posMax,k=e.pos;if(91!==e.src.charCodeAt(e.pos))return!1;if(u=e.pos+1,l=n(e,e.pos,!0),0>l)return!1;if(p=l+1,b>p&&40===e.src.charCodeAt(p)){for(p++;b>p&&(a=e.src.charCodeAt(p),32===a||10===a);p++);if(p>=b)return!1;for(k=p,h=s(e.src,p,e.posMax),h.ok&&(g=e.md.normalizeLink(h.str),e.md.validateLink(g)?p=h.pos:g=""),k=p;b>p&&(a=e.src.charCodeAt(p),32===a||10===a);p++);if(h=i(e.src,p,e.posMax),b>p&&k!==p&&h.ok)for(d=h.str,p=h.pos;b>p&&(a=e.src.charCodeAt(p),32===a||10===a);p++);else d="";if(p>=b||41!==e.src.charCodeAt(p))return e.pos=_,!1;p++}else{if("undefined"==typeof e.env.references)return!1;for(;b>p&&(a=e.src.charCodeAt(p),32===a||10===a);p++);if(b>p&&91===e.src.charCodeAt(p)?(k=p+1,p=n(e,p),p>=0?c=e.src.slice(k,p++):p=l+1):p=l+1,c||(c=e.src.slice(u,l)),f=e.env.references[o(c)],!f)return e.pos=_,!1;g=f.href,d=f.title}return r||(e.pos=u,e.posMax=l,m=e.push("link_open","a",1),m.attrs=t=[["href",g]],d&&t.push(["title",d]),e.md.inline.tokenize(e),m=e.push("link_close","a",-1)),e.pos=p,e.posMax=b,!0}},{"../common/utils":5,"../helpers/parse_link_destination":7,"../helpers/parse_link_label":8,"../helpers/parse_link_title":9}],46:[function(e,r,t){"use strict";r.exports=function(e,r){var t,n,s=e.pos;if(10!==e.src.charCodeAt(s))return!1;for(t=e.pending.length-1,n=e.posMax,r||(t>=0&&32===e.pending.charCodeAt(t)?t>=1&&32===e.pending.charCodeAt(t-1)?(e.pending=e.pending.replace(/ +$/,""),e.push("hardbreak","br",0)):(e.pending=e.pending.slice(0,-1),e.push("softbreak","br",0)):e.push("softbreak","br",0)),s++;n>s&&32===e.src.charCodeAt(s);)s++;return e.pos=s,!0}},{}],47:[function(e,r,t){"use strict";function n(e,r,t,n){this.src=e,this.env=t,this.md=r,this.tokens=n,this.pos=0,this.posMax=this.src.length,this.level=0,this.pending="",this.pendingLevel=0,this.cache={}}var s=e("../token");n.prototype.pushPending=function(){var e=new s("text","",0);return e.content=this.pending,e.level=this.pendingLevel,this.tokens.push(e),this.pending="",e},n.prototype.push=function(e,r,t){this.pending&&this.pushPending();var n=new s(e,r,t);return 0>t&&this.level--,n.level=this.level,t>0&&this.level++,this.pendingLevel=this.level,this.tokens.push(n),n},n.prototype.Token=s,r.exports=n},{"../token":50}],48:[function(e,r,t){"use strict";function n(e,r){var t,n,a,c,l,u,p,h=r,f=!0,d=!0,m=e.posMax,g=e.src.charCodeAt(r);for(t=r>0?e.src.charCodeAt(r-1):32;m>h&&e.src.charCodeAt(h)===g;)h++;return h>=m&&(f=!1),a=h-r,n=m>h?e.src.charCodeAt(h):32,l=o(t)||i(String.fromCharCode(t)),p=o(n)||i(String.fromCharCode(n)),c=s(t),u=s(n),u?f=!1:p&&(c||l||(f=!1)),c?d=!1:l&&(u||p||(d=!1)),{can_open:f,can_close:d,delims:a}}var s=e("../common/utils").isWhiteSpace,i=e("../common/utils").isPunctChar,o=e("../common/utils").isMdAsciiPunct;r.exports=function(e,r){var t,s,i,o,a,c,l,u=e.posMax,p=e.pos,h=e.src.charCodeAt(p);if(126!==h)return!1;if(r)return!1;if(c=n(e,p),t=c.delims,!c.can_open)return e.pos+=t,e.pending+=e.src.slice(p,e.pos),!0;if(a=Math.floor(t/2),0>=a)return!1;for(e.pos=p+t;e.pos<u;)if(e.src.charCodeAt(e.pos)!==h)e.md.inline.skipToken(e);else{if(c=n(e,e.pos),s=c.delims,i=Math.floor(s/2),c.can_close){if(i>=a){e.pos+=s-2,o=!0;break}a-=i,e.pos+=s;continue}c.can_open&&(a+=i),e.pos+=s}return o?(e.posMax=e.pos,e.pos=p+2,l=e.push("s_open","s",1),l.markup="~~",e.md.inline.tokenize(e),l=e.push("s_close","s",-1),l.markup="~~",e.pos=e.posMax+2,e.posMax=u,!0):(e.pos=p,!1)}},{"../common/utils":5}],49:[function(e,r,t){"use strict";function n(e){switch(e){case 10:case 33:case 35:case 36:case 37:case 38:case 42:case 43:case 45:case 58:case 60:case 61:case 62:case 64:case 91:case 92:case 93:case 94:case 95:case 96:case 123:case 125:case 126:return!0;default:return!1}}r.exports=function(e,r){for(var t=e.pos;t<e.posMax&&!n(e.src.charCodeAt(t));)t++;return t===e.pos?!1:(r||(e.pending+=e.src.slice(e.pos,t)),e.pos=t,!0)}},{}],50:[function(e,r,t){"use strict";function n(e,r,t){this.type=e,this.tag=r,this.attrs=null,this.map=null,this.nesting=t,this.level=0,this.children=null,this.content="",this.markup="",this.info="",this.meta=null,this.block=!1,this.hidden=!1}n.prototype.attrIndex=function(e){var r,t,n;if(!this.attrs)return-1;for(r=this.attrs,t=0,n=r.length;n>t;t++)if(r[t][0]===e)return t;return-1},n.prototype.attrPush=function(e){this.attrs?this.attrs.push(e):this.attrs=[e]},r.exports=n},{}],51:[function(r,t,n){(function(r){!function(s){function i(e){throw RangeError(M[e])}function o(e,r){for(var t=e.length;t--;)e[t]=r(e[t]);return e}function a(e,r){return o(e.split(T),r).join(".")}function c(e){for(var r,t,n=[],s=0,i=e.length;i>s;)r=e.charCodeAt(s++),r>=55296&&56319>=r&&i>s?(t=e.charCodeAt(s++),56320==(64512&t)?n.push(((1023&r)<<10)+(1023&t)+65536):(n.push(r),s--)):n.push(r);return n}function l(e){return o(e,function(e){var r="";return e>65535&&(e-=65536,r+=B(e>>>10&1023|55296),e=56320|1023&e),r+=B(e)}).join("")}function u(e){return 10>e-48?e-22:26>e-65?e-65:26>e-97?e-97:A}function p(e,r){return e+22+75*(26>e)-((0!=r)<<5)}function h(e,r,t){var n=0;for(e=t?I(e/D):e>>1,e+=I(e/r);e>R*w>>1;n+=A)e=I(e/R);return I(n+(R+1)*e/(e+q))}function f(e){var r,t,n,s,o,a,c,p,f,d,m=[],g=e.length,_=0,b=S,k=E;for(t=e.lastIndexOf(F),0>t&&(t=0),n=0;t>n;++n)e.charCodeAt(n)>=128&&i("not-basic"),m.push(e.charCodeAt(n));for(s=t>0?t+1:0;g>s;){for(o=_,a=1,c=A;s>=g&&i("invalid-input"),p=u(e.charCodeAt(s++)),(p>=A||p>I((y-_)/a))&&i("overflow"),_+=p*a,f=k>=c?C:c>=k+w?w:c-k,!(f>p);c+=A)d=A-f,a>I(y/d)&&i("overflow"),a*=d;r=m.length+1,k=h(_-o,r,0==o),I(_/r)>y-b&&i("overflow"),b+=I(_/r),_%=r,m.splice(_++,0,b)}return l(m)}function d(e){var r,t,n,s,o,a,l,u,f,d,m,g,_,b,k,v=[];for(e=c(e),g=e.length,r=S,t=0,o=E,a=0;g>a;++a)m=e[a],128>m&&v.push(B(m));for(n=s=v.length,s&&v.push(F);g>n;){for(l=y,a=0;g>a;++a)m=e[a],m>=r&&l>m&&(l=m);for(_=n+1,l-r>I((y-t)/_)&&i("overflow"),t+=(l-r)*_,r=l,a=0;g>a;++a)if(m=e[a],r>m&&++t>y&&i("overflow"),m==r){for(u=t,f=A;d=o>=f?C:f>=o+w?w:f-o,!(d>u);f+=A)k=u-d,b=A-d,v.push(B(p(d+k%b,0))),u=I(k/b);v.push(B(p(u,0))),o=h(t,_,n==s),t=0,++n}++t,++r}return v.join("")}function m(e){return a(e,function(e){return z.test(e)?f(e.slice(4).toLowerCase()):e})}function g(e){return a(e,function(e){return L.test(e)?"xn--"+d(e):e})}var _="object"==typeof n&&n,b="object"==typeof t&&t&&t.exports==_&&t,k="object"==typeof r&&r;(k.global===k||k.window===k)&&(s=k);var v,x,y=2147483647,A=36,C=1,w=26,q=38,D=700,E=72,S=128,F="-",z=/^xn--/,L=/[^ -~]/,T=/\x2E|\u3002|\uFF0E|\uFF61/g,M={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},R=A-C,I=Math.floor,B=String.fromCharCode;if(v={version:"1.2.4",ucs2:{decode:c,encode:l},decode:f,encode:d,toASCII:g,toUnicode:m},"function"==typeof e&&"object"==typeof e.amd&&e.amd)e("punycode",function(){return v});else if(_&&!_.nodeType)if(b)b.exports=v;else for(x in v)v.hasOwnProperty(x)&&(_[x]=v[x]);else s.punycode=v}(this)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],52:[function(e,r,t){r.exports={Aacute:"\xc1",aacute:"\xe1",Abreve:"\u0102",abreve:"\u0103",ac:"\u223e",acd:"\u223f",acE:"\u223e\u0333",Acirc:"\xc2",acirc:"\xe2",acute:"\xb4",Acy:"\u0410",acy:"\u0430",AElig:"\xc6",aelig:"\xe6",af:"\u2061",Afr:"\ud835\udd04",afr:"\ud835\udd1e",Agrave:"\xc0",agrave:"\xe0",alefsym:"\u2135",aleph:"\u2135",Alpha:"\u0391",alpha:"\u03b1",Amacr:"\u0100",amacr:"\u0101",amalg:"\u2a3f",amp:"&",AMP:"&",andand:"\u2a55",And:"\u2a53",and:"\u2227",andd:"\u2a5c",andslope:"\u2a58",andv:"\u2a5a",ang:"\u2220",ange:"\u29a4",angle:"\u2220",angmsdaa:"\u29a8",angmsdab:"\u29a9",angmsdac:"\u29aa",angmsdad:"\u29ab",angmsdae:"\u29ac",angmsdaf:"\u29ad",angmsdag:"\u29ae",angmsdah:"\u29af",angmsd:"\u2221",angrt:"\u221f",angrtvb:"\u22be",angrtvbd:"\u299d",angsph:"\u2222",angst:"\xc5",angzarr:"\u237c",Aogon:"\u0104",aogon:"\u0105",Aopf:"\ud835\udd38",aopf:"\ud835\udd52",apacir:"\u2a6f",ap:"\u2248",apE:"\u2a70",ape:"\u224a",apid:"\u224b",apos:"'",ApplyFunction:"\u2061",approx:"\u2248",approxeq:"\u224a",Aring:"\xc5",aring:"\xe5",Ascr:"\ud835\udc9c",ascr:"\ud835\udcb6",Assign:"\u2254",ast:"*",asymp:"\u2248",asympeq:"\u224d",Atilde:"\xc3",atilde:"\xe3",Auml:"\xc4",auml:"\xe4",awconint:"\u2233",awint:"\u2a11",backcong:"\u224c",backepsilon:"\u03f6",backprime:"\u2035",backsim:"\u223d",backsimeq:"\u22cd",Backslash:"\u2216",Barv:"\u2ae7",barvee:"\u22bd",barwed:"\u2305",Barwed:"\u2306",barwedge:"\u2305",bbrk:"\u23b5",bbrktbrk:"\u23b6",bcong:"\u224c",Bcy:"\u0411",bcy:"\u0431",bdquo:"\u201e",becaus:"\u2235",because:"\u2235",Because:"\u2235",bemptyv:"\u29b0",bepsi:"\u03f6",bernou:"\u212c",Bernoullis:"\u212c",Beta:"\u0392",beta:"\u03b2",beth:"\u2136",between:"\u226c",Bfr:"\ud835\udd05",bfr:"\ud835\udd1f",bigcap:"\u22c2",bigcirc:"\u25ef",bigcup:"\u22c3",bigodot:"\u2a00",bigoplus:"\u2a01",bigotimes:"\u2a02",bigsqcup:"\u2a06",bigstar:"\u2605",bigtriangledown:"\u25bd",bigtriangleup:"\u25b3",biguplus:"\u2a04",bigvee:"\u22c1",bigwedge:"\u22c0",bkarow:"\u290d",blacklozenge:"\u29eb",blacksquare:"\u25aa",blacktriangle:"\u25b4",blacktriangledown:"\u25be",blacktriangleleft:"\u25c2",blacktriangleright:"\u25b8",blank:"\u2423",blk12:"\u2592",blk14:"\u2591",blk34:"\u2593",block:"\u2588",bne:"=\u20e5",bnequiv:"\u2261\u20e5",bNot:"\u2aed",bnot:"\u2310",Bopf:"\ud835\udd39",bopf:"\ud835\udd53",bot:"\u22a5",bottom:"\u22a5",bowtie:"\u22c8",boxbox:"\u29c9",boxdl:"\u2510",boxdL:"\u2555",boxDl:"\u2556",boxDL:"\u2557",boxdr:"\u250c",boxdR:"\u2552",boxDr:"\u2553",boxDR:"\u2554",boxh:"\u2500",boxH:"\u2550",boxhd:"\u252c",boxHd:"\u2564",boxhD:"\u2565",boxHD:"\u2566",boxhu:"\u2534",boxHu:"\u2567",boxhU:"\u2568",boxHU:"\u2569",boxminus:"\u229f",boxplus:"\u229e",boxtimes:"\u22a0",boxul:"\u2518",boxuL:"\u255b",boxUl:"\u255c",boxUL:"\u255d",boxur:"\u2514",boxuR:"\u2558",boxUr:"\u2559",boxUR:"\u255a",boxv:"\u2502",boxV:"\u2551",boxvh:"\u253c",boxvH:"\u256a",boxVh:"\u256b",boxVH:"\u256c",boxvl:"\u2524",boxvL:"\u2561",boxVl:"\u2562",boxVL:"\u2563",boxvr:"\u251c",boxvR:"\u255e",boxVr:"\u255f",boxVR:"\u2560",bprime:"\u2035",breve:"\u02d8",Breve:"\u02d8",brvbar:"\xa6",bscr:"\ud835\udcb7",Bscr:"\u212c",bsemi:"\u204f",bsim:"\u223d",bsime:"\u22cd",bsolb:"\u29c5",bsol:"\\",bsolhsub:"\u27c8",bull:"\u2022",bullet:"\u2022",bump:"\u224e",bumpE:"\u2aae",bumpe:"\u224f",Bumpeq:"\u224e",bumpeq:"\u224f",Cacute:"\u0106",cacute:"\u0107",capand:"\u2a44",capbrcup:"\u2a49",capcap:"\u2a4b",cap:"\u2229",Cap:"\u22d2",capcup:"\u2a47",capdot:"\u2a40",CapitalDifferentialD:"\u2145",caps:"\u2229\ufe00",caret:"\u2041",caron:"\u02c7",Cayleys:"\u212d",ccaps:"\u2a4d",Ccaron:"\u010c",ccaron:"\u010d",Ccedil:"\xc7",ccedil:"\xe7",Ccirc:"\u0108",ccirc:"\u0109",Cconint:"\u2230",ccups:"\u2a4c",ccupssm:"\u2a50",Cdot:"\u010a",cdot:"\u010b",cedil:"\xb8",Cedilla:"\xb8",cemptyv:"\u29b2",cent:"\xa2",centerdot:"\xb7",CenterDot:"\xb7",cfr:"\ud835\udd20",Cfr:"\u212d",CHcy:"\u0427",chcy:"\u0447",check:"\u2713",checkmark:"\u2713",Chi:"\u03a7",chi:"\u03c7",circ:"\u02c6",circeq:"\u2257",circlearrowleft:"\u21ba",circlearrowright:"\u21bb",circledast:"\u229b",circledcirc:"\u229a",circleddash:"\u229d",CircleDot:"\u2299",circledR:"\xae",circledS:"\u24c8",CircleMinus:"\u2296",CirclePlus:"\u2295",CircleTimes:"\u2297",cir:"\u25cb",cirE:"\u29c3",cire:"\u2257",cirfnint:"\u2a10",cirmid:"\u2aef",cirscir:"\u29c2",ClockwiseContourIntegral:"\u2232",CloseCurlyDoubleQuote:"\u201d",CloseCurlyQuote:"\u2019",clubs:"\u2663",clubsuit:"\u2663",colon:":",Colon:"\u2237",Colone:"\u2a74",colone:"\u2254",coloneq:"\u2254",comma:",",commat:"@",comp:"\u2201",compfn:"\u2218",complement:"\u2201",complexes:"\u2102",cong:"\u2245",congdot:"\u2a6d",Congruent:"\u2261",conint:"\u222e",Conint:"\u222f",ContourIntegral:"\u222e",copf:"\ud835\udd54",Copf:"\u2102",coprod:"\u2210",Coproduct:"\u2210",copy:"\xa9",COPY:"\xa9",copysr:"\u2117",CounterClockwiseContourIntegral:"\u2233",crarr:"\u21b5",cross:"\u2717",Cross:"\u2a2f",Cscr:"\ud835\udc9e",cscr:"\ud835\udcb8",csub:"\u2acf",csube:"\u2ad1",csup:"\u2ad0",csupe:"\u2ad2",ctdot:"\u22ef",cudarrl:"\u2938",cudarrr:"\u2935",cuepr:"\u22de",cuesc:"\u22df",cularr:"\u21b6",cularrp:"\u293d",cupbrcap:"\u2a48",cupcap:"\u2a46",CupCap:"\u224d",cup:"\u222a",Cup:"\u22d3",cupcup:"\u2a4a",cupdot:"\u228d",cupor:"\u2a45",cups:"\u222a\ufe00",curarr:"\u21b7",curarrm:"\u293c",curlyeqprec:"\u22de",curlyeqsucc:"\u22df",curlyvee:"\u22ce",curlywedge:"\u22cf",curren:"\xa4",curvearrowleft:"\u21b6",curvearrowright:"\u21b7",cuvee:"\u22ce",cuwed:"\u22cf",cwconint:"\u2232",cwint:"\u2231",cylcty:"\u232d",dagger:"\u2020",Dagger:"\u2021",daleth:"\u2138",darr:"\u2193",Darr:"\u21a1",dArr:"\u21d3",dash:"\u2010",Dashv:"\u2ae4",dashv:"\u22a3",dbkarow:"\u290f",dblac:"\u02dd",Dcaron:"\u010e",dcaron:"\u010f",Dcy:"\u0414",dcy:"\u0434",ddagger:"\u2021",ddarr:"\u21ca",DD:"\u2145",dd:"\u2146",DDotrahd:"\u2911",ddotseq:"\u2a77",deg:"\xb0",Del:"\u2207",Delta:"\u0394",delta:"\u03b4",demptyv:"\u29b1",dfisht:"\u297f",Dfr:"\ud835\udd07",dfr:"\ud835\udd21",dHar:"\u2965",dharl:"\u21c3",dharr:"\u21c2",DiacriticalAcute:"\xb4",DiacriticalDot:"\u02d9",DiacriticalDoubleAcute:"\u02dd",DiacriticalGrave:"`",DiacriticalTilde:"\u02dc",diam:"\u22c4",diamond:"\u22c4",Diamond:"\u22c4",diamondsuit:"\u2666",diams:"\u2666",die:"\xa8",DifferentialD:"\u2146",digamma:"\u03dd",disin:"\u22f2",div:"\xf7",divide:"\xf7",divideontimes:"\u22c7",divonx:"\u22c7",DJcy:"\u0402",djcy:"\u0452",dlcorn:"\u231e",dlcrop:"\u230d",dollar:"$",Dopf:"\ud835\udd3b",dopf:"\ud835\udd55",Dot:"\xa8",dot:"\u02d9",DotDot:"\u20dc",doteq:"\u2250",doteqdot:"\u2251",DotEqual:"\u2250",dotminus:"\u2238",dotplus:"\u2214",dotsquare:"\u22a1",doublebarwedge:"\u2306",DoubleContourIntegral:"\u222f",DoubleDot:"\xa8",DoubleDownArrow:"\u21d3",DoubleLeftArrow:"\u21d0",DoubleLeftRightArrow:"\u21d4",DoubleLeftTee:"\u2ae4",DoubleLongLeftArrow:"\u27f8",DoubleLongLeftRightArrow:"\u27fa",DoubleLongRightArrow:"\u27f9",DoubleRightArrow:"\u21d2",DoubleRightTee:"\u22a8",DoubleUpArrow:"\u21d1",DoubleUpDownArrow:"\u21d5",DoubleVerticalBar:"\u2225",DownArrowBar:"\u2913",downarrow:"\u2193",DownArrow:"\u2193",Downarrow:"\u21d3",DownArrowUpArrow:"\u21f5",DownBreve:"\u0311",downdownarrows:"\u21ca",downharpoonleft:"\u21c3",downharpoonright:"\u21c2",DownLeftRightVector:"\u2950",DownLeftTeeVector:"\u295e",DownLeftVectorBar:"\u2956",DownLeftVector:"\u21bd",DownRightTeeVector:"\u295f",DownRightVectorBar:"\u2957",DownRightVector:"\u21c1",DownTeeArrow:"\u21a7",DownTee:"\u22a4",drbkarow:"\u2910",drcorn:"\u231f",drcrop:"\u230c",Dscr:"\ud835\udc9f",dscr:"\ud835\udcb9",DScy:"\u0405",dscy:"\u0455",dsol:"\u29f6",Dstrok:"\u0110",dstrok:"\u0111",dtdot:"\u22f1",dtri:"\u25bf",dtrif:"\u25be",duarr:"\u21f5",duhar:"\u296f",dwangle:"\u29a6",DZcy:"\u040f",dzcy:"\u045f",dzigrarr:"\u27ff",Eacute:"\xc9",eacute:"\xe9",easter:"\u2a6e",Ecaron:"\u011a",ecaron:"\u011b",Ecirc:"\xca",ecirc:"\xea",ecir:"\u2256",ecolon:"\u2255",Ecy:"\u042d",ecy:"\u044d",eDDot:"\u2a77",Edot:"\u0116",edot:"\u0117",eDot:"\u2251",ee:"\u2147",efDot:"\u2252",Efr:"\ud835\udd08",efr:"\ud835\udd22",eg:"\u2a9a",Egrave:"\xc8",egrave:"\xe8",egs:"\u2a96",egsdot:"\u2a98",el:"\u2a99",Element:"\u2208",elinters:"\u23e7",ell:"\u2113",els:"\u2a95",elsdot:"\u2a97",Emacr:"\u0112",emacr:"\u0113",empty:"\u2205",emptyset:"\u2205",EmptySmallSquare:"\u25fb",emptyv:"\u2205",EmptyVerySmallSquare:"\u25ab",emsp13:"\u2004",emsp14:"\u2005",emsp:"\u2003",ENG:"\u014a",eng:"\u014b",ensp:"\u2002",Eogon:"\u0118",eogon:"\u0119",Eopf:"\ud835\udd3c",eopf:"\ud835\udd56",epar:"\u22d5",eparsl:"\u29e3",eplus:"\u2a71",epsi:"\u03b5",Epsilon:"\u0395",epsilon:"\u03b5",epsiv:"\u03f5",eqcirc:"\u2256",eqcolon:"\u2255",eqsim:"\u2242",eqslantgtr:"\u2a96",eqslantless:"\u2a95",Equal:"\u2a75",equals:"=",EqualTilde:"\u2242",equest:"\u225f",Equilibrium:"\u21cc",equiv:"\u2261",equivDD:"\u2a78",eqvparsl:"\u29e5",erarr:"\u2971",erDot:"\u2253",escr:"\u212f",Escr:"\u2130",esdot:"\u2250",Esim:"\u2a73",esim:"\u2242",Eta:"\u0397",eta:"\u03b7",ETH:"\xd0",eth:"\xf0",Euml:"\xcb",euml:"\xeb",euro:"\u20ac",excl:"!",exist:"\u2203",Exists:"\u2203",expectation:"\u2130",exponentiale:"\u2147",ExponentialE:"\u2147",fallingdotseq:"\u2252",Fcy:"\u0424",fcy:"\u0444",female:"\u2640",ffilig:"\ufb03",fflig:"\ufb00",ffllig:"\ufb04",Ffr:"\ud835\udd09",ffr:"\ud835\udd23",filig:"\ufb01",FilledSmallSquare:"\u25fc",FilledVerySmallSquare:"\u25aa",fjlig:"fj",flat:"\u266d",fllig:"\ufb02",fltns:"\u25b1",fnof:"\u0192",Fopf:"\ud835\udd3d",fopf:"\ud835\udd57",forall:"\u2200",ForAll:"\u2200",fork:"\u22d4",forkv:"\u2ad9",Fouriertrf:"\u2131",fpartint:"\u2a0d",frac12:"\xbd",frac13:"\u2153",frac14:"\xbc",frac15:"\u2155",frac16:"\u2159",frac18:"\u215b",frac23:"\u2154",frac25:"\u2156",frac34:"\xbe",frac35:"\u2157",frac38:"\u215c",frac45:"\u2158",frac56:"\u215a",frac58:"\u215d",frac78:"\u215e",frasl:"\u2044",frown:"\u2322",fscr:"\ud835\udcbb",Fscr:"\u2131",gacute:"\u01f5",Gamma:"\u0393",gamma:"\u03b3",Gammad:"\u03dc",gammad:"\u03dd",gap:"\u2a86",Gbreve:"\u011e",gbreve:"\u011f",Gcedil:"\u0122",Gcirc:"\u011c",gcirc:"\u011d",Gcy:"\u0413",gcy:"\u0433",Gdot:"\u0120",gdot:"\u0121",ge:"\u2265",gE:"\u2267",gEl:"\u2a8c",gel:"\u22db",geq:"\u2265",geqq:"\u2267",geqslant:"\u2a7e",gescc:"\u2aa9",ges:"\u2a7e",gesdot:"\u2a80",gesdoto:"\u2a82",gesdotol:"\u2a84",gesl:"\u22db\ufe00",gesles:"\u2a94",Gfr:"\ud835\udd0a",gfr:"\ud835\udd24",gg:"\u226b",Gg:"\u22d9",ggg:"\u22d9",gimel:"\u2137",GJcy:"\u0403",gjcy:"\u0453",gla:"\u2aa5",gl:"\u2277",glE:"\u2a92",glj:"\u2aa4",gnap:"\u2a8a",gnapprox:"\u2a8a",gne:"\u2a88",gnE:"\u2269",gneq:"\u2a88",gneqq:"\u2269",gnsim:"\u22e7",Gopf:"\ud835\udd3e",gopf:"\ud835\udd58",grave:"`",GreaterEqual:"\u2265",GreaterEqualLess:"\u22db",GreaterFullEqual:"\u2267",GreaterGreater:"\u2aa2",GreaterLess:"\u2277",GreaterSlantEqual:"\u2a7e",GreaterTilde:"\u2273",Gscr:"\ud835\udca2",gscr:"\u210a",gsim:"\u2273",gsime:"\u2a8e",gsiml:"\u2a90",gtcc:"\u2aa7",gtcir:"\u2a7a",gt:">",GT:">",Gt:"\u226b",gtdot:"\u22d7",gtlPar:"\u2995",gtquest:"\u2a7c",gtrapprox:"\u2a86",gtrarr:"\u2978",gtrdot:"\u22d7",gtreqless:"\u22db",gtreqqless:"\u2a8c",gtrless:"\u2277",gtrsim:"\u2273",gvertneqq:"\u2269\ufe00",gvnE:"\u2269\ufe00",Hacek:"\u02c7",hairsp:"\u200a",half:"\xbd",hamilt:"\u210b",HARDcy:"\u042a",hardcy:"\u044a",harrcir:"\u2948",harr:"\u2194",hArr:"\u21d4",harrw:"\u21ad",Hat:"^",hbar:"\u210f",Hcirc:"\u0124",hcirc:"\u0125",hearts:"\u2665",heartsuit:"\u2665",hellip:"\u2026",hercon:"\u22b9",hfr:"\ud835\udd25",Hfr:"\u210c",HilbertSpace:"\u210b",hksearow:"\u2925",hkswarow:"\u2926",hoarr:"\u21ff",homtht:"\u223b",hookleftarrow:"\u21a9",hookrightarrow:"\u21aa",hopf:"\ud835\udd59",Hopf:"\u210d",horbar:"\u2015",HorizontalLine:"\u2500",hscr:"\ud835\udcbd",Hscr:"\u210b",hslash:"\u210f",Hstrok:"\u0126",hstrok:"\u0127",HumpDownHump:"\u224e",HumpEqual:"\u224f",hybull:"\u2043",hyphen:"\u2010",Iacute:"\xcd",iacute:"\xed",ic:"\u2063",Icirc:"\xce",icirc:"\xee",Icy:"\u0418",icy:"\u0438",Idot:"\u0130",IEcy:"\u0415",iecy:"\u0435",iexcl:"\xa1",iff:"\u21d4",ifr:"\ud835\udd26",Ifr:"\u2111",Igrave:"\xcc",igrave:"\xec",ii:"\u2148",iiiint:"\u2a0c",iiint:"\u222d",iinfin:"\u29dc",iiota:"\u2129",IJlig:"\u0132",ijlig:"\u0133",Imacr:"\u012a",imacr:"\u012b",image:"\u2111",ImaginaryI:"\u2148",imagline:"\u2110",imagpart:"\u2111",imath:"\u0131",Im:"\u2111",imof:"\u22b7",imped:"\u01b5",Implies:"\u21d2",incare:"\u2105","in":"\u2208",infin:"\u221e",infintie:"\u29dd",inodot:"\u0131",intcal:"\u22ba","int":"\u222b",Int:"\u222c",integers:"\u2124",Integral:"\u222b",intercal:"\u22ba",Intersection:"\u22c2",intlarhk:"\u2a17",intprod:"\u2a3c",InvisibleComma:"\u2063",InvisibleTimes:"\u2062",IOcy:"\u0401",iocy:"\u0451",Iogon:"\u012e",iogon:"\u012f",Iopf:"\ud835\udd40",iopf:"\ud835\udd5a",Iota:"\u0399",iota:"\u03b9",iprod:"\u2a3c",iquest:"\xbf",iscr:"\ud835\udcbe",Iscr:"\u2110",isin:"\u2208",isindot:"\u22f5",isinE:"\u22f9",isins:"\u22f4",isinsv:"\u22f3",isinv:"\u2208",it:"\u2062",Itilde:"\u0128",itilde:"\u0129",Iukcy:"\u0406",iukcy:"\u0456",Iuml:"\xcf",iuml:"\xef",Jcirc:"\u0134",jcirc:"\u0135",Jcy:"\u0419",jcy:"\u0439",Jfr:"\ud835\udd0d",jfr:"\ud835\udd27",jmath:"\u0237",Jopf:"\ud835\udd41",jopf:"\ud835\udd5b",Jscr:"\ud835\udca5",jscr:"\ud835\udcbf",Jsercy:"\u0408",jsercy:"\u0458",Jukcy:"\u0404",jukcy:"\u0454",Kappa:"\u039a",kappa:"\u03ba",kappav:"\u03f0",Kcedil:"\u0136",kcedil:"\u0137",Kcy:"\u041a",kcy:"\u043a",Kfr:"\ud835\udd0e",kfr:"\ud835\udd28",kgreen:"\u0138",KHcy:"\u0425",khcy:"\u0445",KJcy:"\u040c",kjcy:"\u045c",Kopf:"\ud835\udd42",kopf:"\ud835\udd5c",Kscr:"\ud835\udca6",kscr:"\ud835\udcc0",lAarr:"\u21da",Lacute:"\u0139",lacute:"\u013a",laemptyv:"\u29b4",lagran:"\u2112",Lambda:"\u039b",lambda:"\u03bb",lang:"\u27e8",Lang:"\u27ea",langd:"\u2991",langle:"\u27e8",lap:"\u2a85",Laplacetrf:"\u2112",laquo:"\xab",larrb:"\u21e4",larrbfs:"\u291f",larr:"\u2190",Larr:"\u219e",lArr:"\u21d0",larrfs:"\u291d",larrhk:"\u21a9",larrlp:"\u21ab",larrpl:"\u2939",larrsim:"\u2973",larrtl:"\u21a2",
    latail:"\u2919",lAtail:"\u291b",lat:"\u2aab",late:"\u2aad",lates:"\u2aad\ufe00",lbarr:"\u290c",lBarr:"\u290e",lbbrk:"\u2772",lbrace:"{",lbrack:"[",lbrke:"\u298b",lbrksld:"\u298f",lbrkslu:"\u298d",Lcaron:"\u013d",lcaron:"\u013e",Lcedil:"\u013b",lcedil:"\u013c",lceil:"\u2308",lcub:"{",Lcy:"\u041b",lcy:"\u043b",ldca:"\u2936",ldquo:"\u201c",ldquor:"\u201e",ldrdhar:"\u2967",ldrushar:"\u294b",ldsh:"\u21b2",le:"\u2264",lE:"\u2266",LeftAngleBracket:"\u27e8",LeftArrowBar:"\u21e4",leftarrow:"\u2190",LeftArrow:"\u2190",Leftarrow:"\u21d0",LeftArrowRightArrow:"\u21c6",leftarrowtail:"\u21a2",LeftCeiling:"\u2308",LeftDoubleBracket:"\u27e6",LeftDownTeeVector:"\u2961",LeftDownVectorBar:"\u2959",LeftDownVector:"\u21c3",LeftFloor:"\u230a",leftharpoondown:"\u21bd",leftharpoonup:"\u21bc",leftleftarrows:"\u21c7",leftrightarrow:"\u2194",LeftRightArrow:"\u2194",Leftrightarrow:"\u21d4",leftrightarrows:"\u21c6",leftrightharpoons:"\u21cb",leftrightsquigarrow:"\u21ad",LeftRightVector:"\u294e",LeftTeeArrow:"\u21a4",LeftTee:"\u22a3",LeftTeeVector:"\u295a",leftthreetimes:"\u22cb",LeftTriangleBar:"\u29cf",LeftTriangle:"\u22b2",LeftTriangleEqual:"\u22b4",LeftUpDownVector:"\u2951",LeftUpTeeVector:"\u2960",LeftUpVectorBar:"\u2958",LeftUpVector:"\u21bf",LeftVectorBar:"\u2952",LeftVector:"\u21bc",lEg:"\u2a8b",leg:"\u22da",leq:"\u2264",leqq:"\u2266",leqslant:"\u2a7d",lescc:"\u2aa8",les:"\u2a7d",lesdot:"\u2a7f",lesdoto:"\u2a81",lesdotor:"\u2a83",lesg:"\u22da\ufe00",lesges:"\u2a93",lessapprox:"\u2a85",lessdot:"\u22d6",lesseqgtr:"\u22da",lesseqqgtr:"\u2a8b",LessEqualGreater:"\u22da",LessFullEqual:"\u2266",LessGreater:"\u2276",lessgtr:"\u2276",LessLess:"\u2aa1",lesssim:"\u2272",LessSlantEqual:"\u2a7d",LessTilde:"\u2272",lfisht:"\u297c",lfloor:"\u230a",Lfr:"\ud835\udd0f",lfr:"\ud835\udd29",lg:"\u2276",lgE:"\u2a91",lHar:"\u2962",lhard:"\u21bd",lharu:"\u21bc",lharul:"\u296a",lhblk:"\u2584",LJcy:"\u0409",ljcy:"\u0459",llarr:"\u21c7",ll:"\u226a",Ll:"\u22d8",llcorner:"\u231e",Lleftarrow:"\u21da",llhard:"\u296b",lltri:"\u25fa",Lmidot:"\u013f",lmidot:"\u0140",lmoustache:"\u23b0",lmoust:"\u23b0",lnap:"\u2a89",lnapprox:"\u2a89",lne:"\u2a87",lnE:"\u2268",lneq:"\u2a87",lneqq:"\u2268",lnsim:"\u22e6",loang:"\u27ec",loarr:"\u21fd",lobrk:"\u27e6",longleftarrow:"\u27f5",LongLeftArrow:"\u27f5",Longleftarrow:"\u27f8",longleftrightarrow:"\u27f7",LongLeftRightArrow:"\u27f7",Longleftrightarrow:"\u27fa",longmapsto:"\u27fc",longrightarrow:"\u27f6",LongRightArrow:"\u27f6",Longrightarrow:"\u27f9",looparrowleft:"\u21ab",looparrowright:"\u21ac",lopar:"\u2985",Lopf:"\ud835\udd43",lopf:"\ud835\udd5d",loplus:"\u2a2d",lotimes:"\u2a34",lowast:"\u2217",lowbar:"_",LowerLeftArrow:"\u2199",LowerRightArrow:"\u2198",loz:"\u25ca",lozenge:"\u25ca",lozf:"\u29eb",lpar:"(",lparlt:"\u2993",lrarr:"\u21c6",lrcorner:"\u231f",lrhar:"\u21cb",lrhard:"\u296d",lrm:"\u200e",lrtri:"\u22bf",lsaquo:"\u2039",lscr:"\ud835\udcc1",Lscr:"\u2112",lsh:"\u21b0",Lsh:"\u21b0",lsim:"\u2272",lsime:"\u2a8d",lsimg:"\u2a8f",lsqb:"[",lsquo:"\u2018",lsquor:"\u201a",Lstrok:"\u0141",lstrok:"\u0142",ltcc:"\u2aa6",ltcir:"\u2a79",lt:"<",LT:"<",Lt:"\u226a",ltdot:"\u22d6",lthree:"\u22cb",ltimes:"\u22c9",ltlarr:"\u2976",ltquest:"\u2a7b",ltri:"\u25c3",ltrie:"\u22b4",ltrif:"\u25c2",ltrPar:"\u2996",lurdshar:"\u294a",luruhar:"\u2966",lvertneqq:"\u2268\ufe00",lvnE:"\u2268\ufe00",macr:"\xaf",male:"\u2642",malt:"\u2720",maltese:"\u2720",Map:"\u2905",map:"\u21a6",mapsto:"\u21a6",mapstodown:"\u21a7",mapstoleft:"\u21a4",mapstoup:"\u21a5",marker:"\u25ae",mcomma:"\u2a29",Mcy:"\u041c",mcy:"\u043c",mdash:"\u2014",mDDot:"\u223a",measuredangle:"\u2221",MediumSpace:"\u205f",Mellintrf:"\u2133",Mfr:"\ud835\udd10",mfr:"\ud835\udd2a",mho:"\u2127",micro:"\xb5",midast:"*",midcir:"\u2af0",mid:"\u2223",middot:"\xb7",minusb:"\u229f",minus:"\u2212",minusd:"\u2238",minusdu:"\u2a2a",MinusPlus:"\u2213",mlcp:"\u2adb",mldr:"\u2026",mnplus:"\u2213",models:"\u22a7",Mopf:"\ud835\udd44",mopf:"\ud835\udd5e",mp:"\u2213",mscr:"\ud835\udcc2",Mscr:"\u2133",mstpos:"\u223e",Mu:"\u039c",mu:"\u03bc",multimap:"\u22b8",mumap:"\u22b8",nabla:"\u2207",Nacute:"\u0143",nacute:"\u0144",nang:"\u2220\u20d2",nap:"\u2249",napE:"\u2a70\u0338",napid:"\u224b\u0338",napos:"\u0149",napprox:"\u2249",natural:"\u266e",naturals:"\u2115",natur:"\u266e",nbsp:"\xa0",nbump:"\u224e\u0338",nbumpe:"\u224f\u0338",ncap:"\u2a43",Ncaron:"\u0147",ncaron:"\u0148",Ncedil:"\u0145",ncedil:"\u0146",ncong:"\u2247",ncongdot:"\u2a6d\u0338",ncup:"\u2a42",Ncy:"\u041d",ncy:"\u043d",ndash:"\u2013",nearhk:"\u2924",nearr:"\u2197",neArr:"\u21d7",nearrow:"\u2197",ne:"\u2260",nedot:"\u2250\u0338",NegativeMediumSpace:"\u200b",NegativeThickSpace:"\u200b",NegativeThinSpace:"\u200b",NegativeVeryThinSpace:"\u200b",nequiv:"\u2262",nesear:"\u2928",nesim:"\u2242\u0338",NestedGreaterGreater:"\u226b",NestedLessLess:"\u226a",NewLine:"\n",nexist:"\u2204",nexists:"\u2204",Nfr:"\ud835\udd11",nfr:"\ud835\udd2b",ngE:"\u2267\u0338",nge:"\u2271",ngeq:"\u2271",ngeqq:"\u2267\u0338",ngeqslant:"\u2a7e\u0338",nges:"\u2a7e\u0338",nGg:"\u22d9\u0338",ngsim:"\u2275",nGt:"\u226b\u20d2",ngt:"\u226f",ngtr:"\u226f",nGtv:"\u226b\u0338",nharr:"\u21ae",nhArr:"\u21ce",nhpar:"\u2af2",ni:"\u220b",nis:"\u22fc",nisd:"\u22fa",niv:"\u220b",NJcy:"\u040a",njcy:"\u045a",nlarr:"\u219a",nlArr:"\u21cd",nldr:"\u2025",nlE:"\u2266\u0338",nle:"\u2270",nleftarrow:"\u219a",nLeftarrow:"\u21cd",nleftrightarrow:"\u21ae",nLeftrightarrow:"\u21ce",nleq:"\u2270",nleqq:"\u2266\u0338",nleqslant:"\u2a7d\u0338",nles:"\u2a7d\u0338",nless:"\u226e",nLl:"\u22d8\u0338",nlsim:"\u2274",nLt:"\u226a\u20d2",nlt:"\u226e",nltri:"\u22ea",nltrie:"\u22ec",nLtv:"\u226a\u0338",nmid:"\u2224",NoBreak:"\u2060",NonBreakingSpace:"\xa0",nopf:"\ud835\udd5f",Nopf:"\u2115",Not:"\u2aec",not:"\xac",NotCongruent:"\u2262",NotCupCap:"\u226d",NotDoubleVerticalBar:"\u2226",NotElement:"\u2209",NotEqual:"\u2260",NotEqualTilde:"\u2242\u0338",NotExists:"\u2204",NotGreater:"\u226f",NotGreaterEqual:"\u2271",NotGreaterFullEqual:"\u2267\u0338",NotGreaterGreater:"\u226b\u0338",NotGreaterLess:"\u2279",NotGreaterSlantEqual:"\u2a7e\u0338",NotGreaterTilde:"\u2275",NotHumpDownHump:"\u224e\u0338",NotHumpEqual:"\u224f\u0338",notin:"\u2209",notindot:"\u22f5\u0338",notinE:"\u22f9\u0338",notinva:"\u2209",notinvb:"\u22f7",notinvc:"\u22f6",NotLeftTriangleBar:"\u29cf\u0338",NotLeftTriangle:"\u22ea",NotLeftTriangleEqual:"\u22ec",NotLess:"\u226e",NotLessEqual:"\u2270",NotLessGreater:"\u2278",NotLessLess:"\u226a\u0338",NotLessSlantEqual:"\u2a7d\u0338",NotLessTilde:"\u2274",NotNestedGreaterGreater:"\u2aa2\u0338",NotNestedLessLess:"\u2aa1\u0338",notni:"\u220c",notniva:"\u220c",notnivb:"\u22fe",notnivc:"\u22fd",NotPrecedes:"\u2280",NotPrecedesEqual:"\u2aaf\u0338",NotPrecedesSlantEqual:"\u22e0",NotReverseElement:"\u220c",NotRightTriangleBar:"\u29d0\u0338",NotRightTriangle:"\u22eb",NotRightTriangleEqual:"\u22ed",NotSquareSubset:"\u228f\u0338",NotSquareSubsetEqual:"\u22e2",NotSquareSuperset:"\u2290\u0338",NotSquareSupersetEqual:"\u22e3",NotSubset:"\u2282\u20d2",NotSubsetEqual:"\u2288",NotSucceeds:"\u2281",NotSucceedsEqual:"\u2ab0\u0338",NotSucceedsSlantEqual:"\u22e1",NotSucceedsTilde:"\u227f\u0338",NotSuperset:"\u2283\u20d2",NotSupersetEqual:"\u2289",NotTilde:"\u2241",NotTildeEqual:"\u2244",NotTildeFullEqual:"\u2247",NotTildeTilde:"\u2249",NotVerticalBar:"\u2224",nparallel:"\u2226",npar:"\u2226",nparsl:"\u2afd\u20e5",npart:"\u2202\u0338",npolint:"\u2a14",npr:"\u2280",nprcue:"\u22e0",nprec:"\u2280",npreceq:"\u2aaf\u0338",npre:"\u2aaf\u0338",nrarrc:"\u2933\u0338",nrarr:"\u219b",nrArr:"\u21cf",nrarrw:"\u219d\u0338",nrightarrow:"\u219b",nRightarrow:"\u21cf",nrtri:"\u22eb",nrtrie:"\u22ed",nsc:"\u2281",nsccue:"\u22e1",nsce:"\u2ab0\u0338",Nscr:"\ud835\udca9",nscr:"\ud835\udcc3",nshortmid:"\u2224",nshortparallel:"\u2226",nsim:"\u2241",nsime:"\u2244",nsimeq:"\u2244",nsmid:"\u2224",nspar:"\u2226",nsqsube:"\u22e2",nsqsupe:"\u22e3",nsub:"\u2284",nsubE:"\u2ac5\u0338",nsube:"\u2288",nsubset:"\u2282\u20d2",nsubseteq:"\u2288",nsubseteqq:"\u2ac5\u0338",nsucc:"\u2281",nsucceq:"\u2ab0\u0338",nsup:"\u2285",nsupE:"\u2ac6\u0338",nsupe:"\u2289",nsupset:"\u2283\u20d2",nsupseteq:"\u2289",nsupseteqq:"\u2ac6\u0338",ntgl:"\u2279",Ntilde:"\xd1",ntilde:"\xf1",ntlg:"\u2278",ntriangleleft:"\u22ea",ntrianglelefteq:"\u22ec",ntriangleright:"\u22eb",ntrianglerighteq:"\u22ed",Nu:"\u039d",nu:"\u03bd",num:"#",numero:"\u2116",numsp:"\u2007",nvap:"\u224d\u20d2",nvdash:"\u22ac",nvDash:"\u22ad",nVdash:"\u22ae",nVDash:"\u22af",nvge:"\u2265\u20d2",nvgt:">\u20d2",nvHarr:"\u2904",nvinfin:"\u29de",nvlArr:"\u2902",nvle:"\u2264\u20d2",nvlt:"<\u20d2",nvltrie:"\u22b4\u20d2",nvrArr:"\u2903",nvrtrie:"\u22b5\u20d2",nvsim:"\u223c\u20d2",nwarhk:"\u2923",nwarr:"\u2196",nwArr:"\u21d6",nwarrow:"\u2196",nwnear:"\u2927",Oacute:"\xd3",oacute:"\xf3",oast:"\u229b",Ocirc:"\xd4",ocirc:"\xf4",ocir:"\u229a",Ocy:"\u041e",ocy:"\u043e",odash:"\u229d",Odblac:"\u0150",odblac:"\u0151",odiv:"\u2a38",odot:"\u2299",odsold:"\u29bc",OElig:"\u0152",oelig:"\u0153",ofcir:"\u29bf",Ofr:"\ud835\udd12",ofr:"\ud835\udd2c",ogon:"\u02db",Ograve:"\xd2",ograve:"\xf2",ogt:"\u29c1",ohbar:"\u29b5",ohm:"\u03a9",oint:"\u222e",olarr:"\u21ba",olcir:"\u29be",olcross:"\u29bb",oline:"\u203e",olt:"\u29c0",Omacr:"\u014c",omacr:"\u014d",Omega:"\u03a9",omega:"\u03c9",Omicron:"\u039f",omicron:"\u03bf",omid:"\u29b6",ominus:"\u2296",Oopf:"\ud835\udd46",oopf:"\ud835\udd60",opar:"\u29b7",OpenCurlyDoubleQuote:"\u201c",OpenCurlyQuote:"\u2018",operp:"\u29b9",oplus:"\u2295",orarr:"\u21bb",Or:"\u2a54",or:"\u2228",ord:"\u2a5d",order:"\u2134",orderof:"\u2134",ordf:"\xaa",ordm:"\xba",origof:"\u22b6",oror:"\u2a56",orslope:"\u2a57",orv:"\u2a5b",oS:"\u24c8",Oscr:"\ud835\udcaa",oscr:"\u2134",Oslash:"\xd8",oslash:"\xf8",osol:"\u2298",Otilde:"\xd5",otilde:"\xf5",otimesas:"\u2a36",Otimes:"\u2a37",otimes:"\u2297",Ouml:"\xd6",ouml:"\xf6",ovbar:"\u233d",OverBar:"\u203e",OverBrace:"\u23de",OverBracket:"\u23b4",OverParenthesis:"\u23dc",para:"\xb6",parallel:"\u2225",par:"\u2225",parsim:"\u2af3",parsl:"\u2afd",part:"\u2202",PartialD:"\u2202",Pcy:"\u041f",pcy:"\u043f",percnt:"%",period:".",permil:"\u2030",perp:"\u22a5",pertenk:"\u2031",Pfr:"\ud835\udd13",pfr:"\ud835\udd2d",Phi:"\u03a6",phi:"\u03c6",phiv:"\u03d5",phmmat:"\u2133",phone:"\u260e",Pi:"\u03a0",pi:"\u03c0",pitchfork:"\u22d4",piv:"\u03d6",planck:"\u210f",planckh:"\u210e",plankv:"\u210f",plusacir:"\u2a23",plusb:"\u229e",pluscir:"\u2a22",plus:"+",plusdo:"\u2214",plusdu:"\u2a25",pluse:"\u2a72",PlusMinus:"\xb1",plusmn:"\xb1",plussim:"\u2a26",plustwo:"\u2a27",pm:"\xb1",Poincareplane:"\u210c",pointint:"\u2a15",popf:"\ud835\udd61",Popf:"\u2119",pound:"\xa3",prap:"\u2ab7",Pr:"\u2abb",pr:"\u227a",prcue:"\u227c",precapprox:"\u2ab7",prec:"\u227a",preccurlyeq:"\u227c",Precedes:"\u227a",PrecedesEqual:"\u2aaf",PrecedesSlantEqual:"\u227c",PrecedesTilde:"\u227e",preceq:"\u2aaf",precnapprox:"\u2ab9",precneqq:"\u2ab5",precnsim:"\u22e8",pre:"\u2aaf",prE:"\u2ab3",precsim:"\u227e",prime:"\u2032",Prime:"\u2033",primes:"\u2119",prnap:"\u2ab9",prnE:"\u2ab5",prnsim:"\u22e8",prod:"\u220f",Product:"\u220f",profalar:"\u232e",profline:"\u2312",profsurf:"\u2313",prop:"\u221d",Proportional:"\u221d",Proportion:"\u2237",propto:"\u221d",prsim:"\u227e",prurel:"\u22b0",Pscr:"\ud835\udcab",pscr:"\ud835\udcc5",Psi:"\u03a8",psi:"\u03c8",puncsp:"\u2008",Qfr:"\ud835\udd14",qfr:"\ud835\udd2e",qint:"\u2a0c",qopf:"\ud835\udd62",Qopf:"\u211a",qprime:"\u2057",Qscr:"\ud835\udcac",qscr:"\ud835\udcc6",quaternions:"\u210d",quatint:"\u2a16",quest:"?",questeq:"\u225f",quot:'"',QUOT:'"',rAarr:"\u21db",race:"\u223d\u0331",Racute:"\u0154",racute:"\u0155",radic:"\u221a",raemptyv:"\u29b3",rang:"\u27e9",Rang:"\u27eb",rangd:"\u2992",range:"\u29a5",rangle:"\u27e9",raquo:"\xbb",rarrap:"\u2975",rarrb:"\u21e5",rarrbfs:"\u2920",rarrc:"\u2933",rarr:"\u2192",Rarr:"\u21a0",rArr:"\u21d2",rarrfs:"\u291e",rarrhk:"\u21aa",rarrlp:"\u21ac",rarrpl:"\u2945",rarrsim:"\u2974",Rarrtl:"\u2916",rarrtl:"\u21a3",rarrw:"\u219d",ratail:"\u291a",rAtail:"\u291c",ratio:"\u2236",rationals:"\u211a",rbarr:"\u290d",rBarr:"\u290f",RBarr:"\u2910",rbbrk:"\u2773",rbrace:"}",rbrack:"]",rbrke:"\u298c",rbrksld:"\u298e",rbrkslu:"\u2990",Rcaron:"\u0158",rcaron:"\u0159",Rcedil:"\u0156",rcedil:"\u0157",rceil:"\u2309",rcub:"}",Rcy:"\u0420",rcy:"\u0440",rdca:"\u2937",rdldhar:"\u2969",rdquo:"\u201d",rdquor:"\u201d",rdsh:"\u21b3",real:"\u211c",realine:"\u211b",realpart:"\u211c",reals:"\u211d",Re:"\u211c",rect:"\u25ad",reg:"\xae",REG:"\xae",ReverseElement:"\u220b",ReverseEquilibrium:"\u21cb",ReverseUpEquilibrium:"\u296f",rfisht:"\u297d",rfloor:"\u230b",rfr:"\ud835\udd2f",Rfr:"\u211c",rHar:"\u2964",rhard:"\u21c1",rharu:"\u21c0",rharul:"\u296c",Rho:"\u03a1",rho:"\u03c1",rhov:"\u03f1",RightAngleBracket:"\u27e9",RightArrowBar:"\u21e5",rightarrow:"\u2192",RightArrow:"\u2192",Rightarrow:"\u21d2",RightArrowLeftArrow:"\u21c4",rightarrowtail:"\u21a3",RightCeiling:"\u2309",RightDoubleBracket:"\u27e7",RightDownTeeVector:"\u295d",RightDownVectorBar:"\u2955",RightDownVector:"\u21c2",RightFloor:"\u230b",rightharpoondown:"\u21c1",rightharpoonup:"\u21c0",rightleftarrows:"\u21c4",rightleftharpoons:"\u21cc",rightrightarrows:"\u21c9",rightsquigarrow:"\u219d",RightTeeArrow:"\u21a6",RightTee:"\u22a2",RightTeeVector:"\u295b",rightthreetimes:"\u22cc",RightTriangleBar:"\u29d0",RightTriangle:"\u22b3",RightTriangleEqual:"\u22b5",RightUpDownVector:"\u294f",RightUpTeeVector:"\u295c",RightUpVectorBar:"\u2954",RightUpVector:"\u21be",RightVectorBar:"\u2953",RightVector:"\u21c0",ring:"\u02da",risingdotseq:"\u2253",rlarr:"\u21c4",rlhar:"\u21cc",rlm:"\u200f",rmoustache:"\u23b1",rmoust:"\u23b1",rnmid:"\u2aee",roang:"\u27ed",roarr:"\u21fe",robrk:"\u27e7",ropar:"\u2986",ropf:"\ud835\udd63",Ropf:"\u211d",roplus:"\u2a2e",rotimes:"\u2a35",RoundImplies:"\u2970",rpar:")",rpargt:"\u2994",rppolint:"\u2a12",rrarr:"\u21c9",Rrightarrow:"\u21db",rsaquo:"\u203a",rscr:"\ud835\udcc7",Rscr:"\u211b",rsh:"\u21b1",Rsh:"\u21b1",rsqb:"]",rsquo:"\u2019",rsquor:"\u2019",rthree:"\u22cc",rtimes:"\u22ca",rtri:"\u25b9",rtrie:"\u22b5",rtrif:"\u25b8",rtriltri:"\u29ce",RuleDelayed:"\u29f4",ruluhar:"\u2968",rx:"\u211e",Sacute:"\u015a",sacute:"\u015b",sbquo:"\u201a",scap:"\u2ab8",Scaron:"\u0160",scaron:"\u0161",Sc:"\u2abc",sc:"\u227b",sccue:"\u227d",sce:"\u2ab0",scE:"\u2ab4",Scedil:"\u015e",scedil:"\u015f",Scirc:"\u015c",scirc:"\u015d",scnap:"\u2aba",scnE:"\u2ab6",scnsim:"\u22e9",scpolint:"\u2a13",scsim:"\u227f",Scy:"\u0421",scy:"\u0441",sdotb:"\u22a1",sdot:"\u22c5",sdote:"\u2a66",searhk:"\u2925",searr:"\u2198",seArr:"\u21d8",searrow:"\u2198",sect:"\xa7",semi:";",seswar:"\u2929",setminus:"\u2216",setmn:"\u2216",sext:"\u2736",Sfr:"\ud835\udd16",sfr:"\ud835\udd30",sfrown:"\u2322",sharp:"\u266f",SHCHcy:"\u0429",shchcy:"\u0449",SHcy:"\u0428",shcy:"\u0448",ShortDownArrow:"\u2193",ShortLeftArrow:"\u2190",shortmid:"\u2223",shortparallel:"\u2225",ShortRightArrow:"\u2192",ShortUpArrow:"\u2191",shy:"\xad",Sigma:"\u03a3",sigma:"\u03c3",sigmaf:"\u03c2",sigmav:"\u03c2",sim:"\u223c",simdot:"\u2a6a",sime:"\u2243",simeq:"\u2243",simg:"\u2a9e",simgE:"\u2aa0",siml:"\u2a9d",simlE:"\u2a9f",simne:"\u2246",simplus:"\u2a24",simrarr:"\u2972",slarr:"\u2190",SmallCircle:"\u2218",smallsetminus:"\u2216",smashp:"\u2a33",smeparsl:"\u29e4",smid:"\u2223",smile:"\u2323",smt:"\u2aaa",smte:"\u2aac",smtes:"\u2aac\ufe00",SOFTcy:"\u042c",softcy:"\u044c",solbar:"\u233f",solb:"\u29c4",sol:"/",Sopf:"\ud835\udd4a",sopf:"\ud835\udd64",spades:"\u2660",spadesuit:"\u2660",spar:"\u2225",sqcap:"\u2293",sqcaps:"\u2293\ufe00",sqcup:"\u2294",sqcups:"\u2294\ufe00",Sqrt:"\u221a",sqsub:"\u228f",sqsube:"\u2291",sqsubset:"\u228f",sqsubseteq:"\u2291",sqsup:"\u2290",sqsupe:"\u2292",sqsupset:"\u2290",sqsupseteq:"\u2292",square:"\u25a1",Square:"\u25a1",SquareIntersection:"\u2293",SquareSubset:"\u228f",SquareSubsetEqual:"\u2291",SquareSuperset:"\u2290",SquareSupersetEqual:"\u2292",SquareUnion:"\u2294",squarf:"\u25aa",squ:"\u25a1",squf:"\u25aa",srarr:"\u2192",Sscr:"\ud835\udcae",sscr:"\ud835\udcc8",ssetmn:"\u2216",ssmile:"\u2323",sstarf:"\u22c6",Star:"\u22c6",star:"\u2606",starf:"\u2605",straightepsilon:"\u03f5",straightphi:"\u03d5",strns:"\xaf",sub:"\u2282",Sub:"\u22d0",subdot:"\u2abd",subE:"\u2ac5",sube:"\u2286",subedot:"\u2ac3",submult:"\u2ac1",subnE:"\u2acb",subne:"\u228a",subplus:"\u2abf",subrarr:"\u2979",subset:"\u2282",Subset:"\u22d0",subseteq:"\u2286",subseteqq:"\u2ac5",SubsetEqual:"\u2286",subsetneq:"\u228a",subsetneqq:"\u2acb",subsim:"\u2ac7",subsub:"\u2ad5",subsup:"\u2ad3",succapprox:"\u2ab8",succ:"\u227b",succcurlyeq:"\u227d",Succeeds:"\u227b",SucceedsEqual:"\u2ab0",SucceedsSlantEqual:"\u227d",SucceedsTilde:"\u227f",succeq:"\u2ab0",succnapprox:"\u2aba",succneqq:"\u2ab6",succnsim:"\u22e9",succsim:"\u227f",SuchThat:"\u220b",sum:"\u2211",Sum:"\u2211",sung:"\u266a",sup1:"\xb9",sup2:"\xb2",sup3:"\xb3",sup:"\u2283",Sup:"\u22d1",supdot:"\u2abe",supdsub:"\u2ad8",supE:"\u2ac6",supe:"\u2287",supedot:"\u2ac4",Superset:"\u2283",SupersetEqual:"\u2287",suphsol:"\u27c9",suphsub:"\u2ad7",suplarr:"\u297b",supmult:"\u2ac2",supnE:"\u2acc",supne:"\u228b",supplus:"\u2ac0",supset:"\u2283",Supset:"\u22d1",supseteq:"\u2287",supseteqq:"\u2ac6",supsetneq:"\u228b",supsetneqq:"\u2acc",supsim:"\u2ac8",supsub:"\u2ad4",supsup:"\u2ad6",swarhk:"\u2926",swarr:"\u2199",swArr:"\u21d9",swarrow:"\u2199",swnwar:"\u292a",szlig:"\xdf",Tab:"	",target:"\u2316",Tau:"\u03a4",tau:"\u03c4",tbrk:"\u23b4",Tcaron:"\u0164",tcaron:"\u0165",Tcedil:"\u0162",tcedil:"\u0163",Tcy:"\u0422",tcy:"\u0442",tdot:"\u20db",telrec:"\u2315",Tfr:"\ud835\udd17",tfr:"\ud835\udd31",there4:"\u2234",therefore:"\u2234",Therefore:"\u2234",Theta:"\u0398",theta:"\u03b8",thetasym:"\u03d1",thetav:"\u03d1",thickapprox:"\u2248",thicksim:"\u223c",ThickSpace:"\u205f\u200a",ThinSpace:"\u2009",thinsp:"\u2009",thkap:"\u2248",thksim:"\u223c",THORN:"\xde",thorn:"\xfe",tilde:"\u02dc",Tilde:"\u223c",TildeEqual:"\u2243",TildeFullEqual:"\u2245",TildeTilde:"\u2248",timesbar:"\u2a31",timesb:"\u22a0",times:"\xd7",timesd:"\u2a30",tint:"\u222d",toea:"\u2928",topbot:"\u2336",topcir:"\u2af1",top:"\u22a4",Topf:"\ud835\udd4b",topf:"\ud835\udd65",topfork:"\u2ada",tosa:"\u2929",tprime:"\u2034",trade:"\u2122",TRADE:"\u2122",triangle:"\u25b5",triangledown:"\u25bf",triangleleft:"\u25c3",trianglelefteq:"\u22b4",triangleq:"\u225c",triangleright:"\u25b9",trianglerighteq:"\u22b5",tridot:"\u25ec",trie:"\u225c",triminus:"\u2a3a",TripleDot:"\u20db",triplus:"\u2a39",trisb:"\u29cd",tritime:"\u2a3b",trpezium:"\u23e2",Tscr:"\ud835\udcaf",tscr:"\ud835\udcc9",TScy:"\u0426",tscy:"\u0446",TSHcy:"\u040b",tshcy:"\u045b",Tstrok:"\u0166",tstrok:"\u0167",twixt:"\u226c",twoheadleftarrow:"\u219e",twoheadrightarrow:"\u21a0",Uacute:"\xda",uacute:"\xfa",uarr:"\u2191",Uarr:"\u219f",uArr:"\u21d1",Uarrocir:"\u2949",Ubrcy:"\u040e",ubrcy:"\u045e",Ubreve:"\u016c",ubreve:"\u016d",Ucirc:"\xdb",ucirc:"\xfb",Ucy:"\u0423",ucy:"\u0443",udarr:"\u21c5",Udblac:"\u0170",udblac:"\u0171",udhar:"\u296e",ufisht:"\u297e",Ufr:"\ud835\udd18",ufr:"\ud835\udd32",Ugrave:"\xd9",ugrave:"\xf9",uHar:"\u2963",uharl:"\u21bf",uharr:"\u21be",uhblk:"\u2580",ulcorn:"\u231c",ulcorner:"\u231c",ulcrop:"\u230f",ultri:"\u25f8",Umacr:"\u016a",umacr:"\u016b",uml:"\xa8",UnderBar:"_",UnderBrace:"\u23df",UnderBracket:"\u23b5",UnderParenthesis:"\u23dd",Union:"\u22c3",UnionPlus:"\u228e",Uogon:"\u0172",uogon:"\u0173",Uopf:"\ud835\udd4c",uopf:"\ud835\udd66",UpArrowBar:"\u2912",uparrow:"\u2191",UpArrow:"\u2191",Uparrow:"\u21d1",UpArrowDownArrow:"\u21c5",updownarrow:"\u2195",UpDownArrow:"\u2195",Updownarrow:"\u21d5",UpEquilibrium:"\u296e",upharpoonleft:"\u21bf",upharpoonright:"\u21be",uplus:"\u228e",UpperLeftArrow:"\u2196",UpperRightArrow:"\u2197",upsi:"\u03c5",Upsi:"\u03d2",upsih:"\u03d2",Upsilon:"\u03a5",upsilon:"\u03c5",UpTeeArrow:"\u21a5",UpTee:"\u22a5",upuparrows:"\u21c8",urcorn:"\u231d",urcorner:"\u231d",urcrop:"\u230e",Uring:"\u016e",uring:"\u016f",urtri:"\u25f9",Uscr:"\ud835\udcb0",uscr:"\ud835\udcca",utdot:"\u22f0",Utilde:"\u0168",utilde:"\u0169",utri:"\u25b5",utrif:"\u25b4",uuarr:"\u21c8",Uuml:"\xdc",uuml:"\xfc",uwangle:"\u29a7",vangrt:"\u299c",varepsilon:"\u03f5",varkappa:"\u03f0",varnothing:"\u2205",varphi:"\u03d5",varpi:"\u03d6",varpropto:"\u221d",varr:"\u2195",vArr:"\u21d5",varrho:"\u03f1",varsigma:"\u03c2",varsubsetneq:"\u228a\ufe00",varsubsetneqq:"\u2acb\ufe00",varsupsetneq:"\u228b\ufe00",varsupsetneqq:"\u2acc\ufe00",vartheta:"\u03d1",vartriangleleft:"\u22b2",vartriangleright:"\u22b3",vBar:"\u2ae8",Vbar:"\u2aeb",vBarv:"\u2ae9",Vcy:"\u0412",vcy:"\u0432",vdash:"\u22a2",vDash:"\u22a8",Vdash:"\u22a9",VDash:"\u22ab",Vdashl:"\u2ae6",veebar:"\u22bb",vee:"\u2228",Vee:"\u22c1",veeeq:"\u225a",vellip:"\u22ee",verbar:"|",Verbar:"\u2016",vert:"|",Vert:"\u2016",VerticalBar:"\u2223",VerticalLine:"|",VerticalSeparator:"\u2758",VerticalTilde:"\u2240",VeryThinSpace:"\u200a",Vfr:"\ud835\udd19",vfr:"\ud835\udd33",vltri:"\u22b2",vnsub:"\u2282\u20d2",vnsup:"\u2283\u20d2",Vopf:"\ud835\udd4d",vopf:"\ud835\udd67",vprop:"\u221d",vrtri:"\u22b3",Vscr:"\ud835\udcb1",vscr:"\ud835\udccb",vsubnE:"\u2acb\ufe00",vsubne:"\u228a\ufe00",vsupnE:"\u2acc\ufe00",vsupne:"\u228b\ufe00",Vvdash:"\u22aa",vzigzag:"\u299a",Wcirc:"\u0174",wcirc:"\u0175",wedbar:"\u2a5f",wedge:"\u2227",Wedge:"\u22c0",wedgeq:"\u2259",weierp:"\u2118",Wfr:"\ud835\udd1a",wfr:"\ud835\udd34",Wopf:"\ud835\udd4e",wopf:"\ud835\udd68",wp:"\u2118",wr:"\u2240",wreath:"\u2240",Wscr:"\ud835\udcb2",wscr:"\ud835\udccc",xcap:"\u22c2",xcirc:"\u25ef",xcup:"\u22c3",xdtri:"\u25bd",Xfr:"\ud835\udd1b",xfr:"\ud835\udd35",xharr:"\u27f7",xhArr:"\u27fa",Xi:"\u039e",xi:"\u03be",xlarr:"\u27f5",xlArr:"\u27f8",xmap:"\u27fc",xnis:"\u22fb",xodot:"\u2a00",Xopf:"\ud835\udd4f",xopf:"\ud835\udd69",xoplus:"\u2a01",xotime:"\u2a02",xrarr:"\u27f6",xrArr:"\u27f9",Xscr:"\ud835\udcb3",xscr:"\ud835\udccd",xsqcup:"\u2a06",xuplus:"\u2a04",xutri:"\u25b3",xvee:"\u22c1",xwedge:"\u22c0",Yacute:"\xdd",yacute:"\xfd",YAcy:"\u042f",yacy:"\u044f",Ycirc:"\u0176",ycirc:"\u0177",Ycy:"\u042b",ycy:"\u044b",yen:"\xa5",Yfr:"\ud835\udd1c",yfr:"\ud835\udd36",YIcy:"\u0407",yicy:"\u0457",Yopf:"\ud835\udd50",yopf:"\ud835\udd6a",Yscr:"\ud835\udcb4",yscr:"\ud835\udcce",YUcy:"\u042e",yucy:"\u044e",yuml:"\xff",Yuml:"\u0178",Zacute:"\u0179",zacute:"\u017a",Zcaron:"\u017d",zcaron:"\u017e",Zcy:"\u0417",zcy:"\u0437",Zdot:"\u017b",zdot:"\u017c",zeetrf:"\u2128",ZeroWidthSpace:"\u200b",Zeta:"\u0396",zeta:"\u03b6",zfr:"\ud835\udd37",Zfr:"\u2128",ZHcy:"\u0416",zhcy:"\u0436",zigrarr:"\u21dd",zopf:"\ud835\udd6b",Zopf:"\u2124",Zscr:"\ud835\udcb5",zscr:"\ud835\udccf",zwj:"\u200d",zwnj:"\u200c"}},{}],53:[function(e,r,t){"use strict";function n(e){var r=Array.prototype.slice.call(arguments,1);return r.forEach(function(r){r&&Object.keys(r).forEach(function(t){e[t]=r[t]})}),e}function s(e){return Object.prototype.toString.call(e)}function i(e){return"[object String]"===s(e)}function o(e){return"[object Object]"===s(e)}function a(e){return"[object RegExp]"===s(e)}function c(e){return"[object Function]"===s(e)}function l(e){return e.replace(/[.?*+^$[\]\\(){}|-]/g,"\\$&")}function u(e){return Object.keys(e||{}).reduce(function(e,r){return e||b.hasOwnProperty(r)},!1)}function p(e){e.__index__=-1,e.__text_cache__=""}function h(e){return function(r,t){var n=r.slice(t);return e.test(n)?n.match(e)[0].length:0}}function f(){return function(e,r){r.normalize(e)}}function d(r){function t(e){return e.replace("%TLDS%",u.src_tlds)}function s(e,r){throw new Error('(LinkifyIt) Invalid schema "'+e+'": '+r)}var u=r.re=n({},e("./lib/re")),d=r.__tlds__.slice();r.__tlds_replaced__||d.push(v),d.push(u.src_xn),u.src_tlds=d.join("|"),u.email_fuzzy=RegExp(t(u.tpl_email_fuzzy),"i"),u.link_fuzzy=RegExp(t(u.tpl_link_fuzzy),"i"),u.link_no_ip_fuzzy=RegExp(t(u.tpl_link_no_ip_fuzzy),"i"),u.host_fuzzy_test=RegExp(t(u.tpl_host_fuzzy_test),"i");var m=[];r.__compiled__={},Object.keys(r.__schemas__).forEach(function(e){var t=r.__schemas__[e];if(null!==t){var n={validate:null,link:null};return r.__compiled__[e]=n,o(t)?(a(t.validate)?n.validate=h(t.validate):c(t.validate)?n.validate=t.validate:s(e,t),void(c(t.normalize)?n.normalize=t.normalize:t.normalize?s(e,t):n.normalize=f())):i(t)?void m.push(e):void s(e,t)}}),m.forEach(function(e){r.__compiled__[r.__schemas__[e]]&&(r.__compiled__[e].validate=r.__compiled__[r.__schemas__[e]].validate,r.__compiled__[e].normalize=r.__compiled__[r.__schemas__[e]].normalize)}),r.__compiled__[""]={validate:null,normalize:f()};var g=Object.keys(r.__compiled__).filter(function(e){return e.length>0&&r.__compiled__[e]}).map(l).join("|");r.re.schema_test=RegExp("(^|(?!_)(?:>|"+u.src_ZPCc+"))("+g+")","i"),r.re.schema_search=RegExp("(^|(?!_)(?:>|"+u.src_ZPCc+"))("+g+")","ig"),r.re.pretest=RegExp("("+r.re.schema_test.source+")|("+r.re.host_fuzzy_test.source+")|@","i"),p(r)}function m(e,r){var t=e.__index__,n=e.__last_index__,s=e.__text_cache__.slice(t,n);this.schema=e.__schema__.toLowerCase(),this.index=t+r,this.lastIndex=n+r,this.raw=s,this.text=s,this.url=s}function g(e,r){var t=new m(e,r);return e.__compiled__[t.schema].normalize(t,e),t}function _(e,r){return this instanceof _?(r||u(e)&&(r=e,e={}),this.__opts__=n({},b,r),this.__index__=-1,this.__last_index__=-1,this.__schema__="",this.__text_cache__="",this.__schemas__=n({},k,e),this.__compiled__={},this.__tlds__=x,this.__tlds_replaced__=!1,this.re={},void d(this)):new _(e,r)}var b={fuzzyLink:!0,fuzzyEmail:!0,fuzzyIP:!1},k={"http:":{validate:function(e,r,t){var n=e.slice(r);return t.re.http||(t.re.http=new RegExp("^\\/\\/"+t.re.src_auth+t.re.src_host_port_strict+t.re.src_path,"i")),t.re.http.test(n)?n.match(t.re.http)[0].length:0}},"https:":"http:","ftp:":"http:","//":{validate:function(e,r,t){var n=e.slice(r);return t.re.no_http||(t.re.no_http=new RegExp("^"+t.re.src_auth+t.re.src_host_port_strict+t.re.src_path,"i")),t.re.no_http.test(n)?r>=3&&":"===e[r-3]?0:n.match(t.re.no_http)[0].length:0}},"mailto:":{validate:function(e,r,t){var n=e.slice(r);return t.re.mailto||(t.re.mailto=new RegExp("^"+t.re.src_email_name+"@"+t.re.src_host_strict,"i")),t.re.mailto.test(n)?n.match(t.re.mailto)[0].length:0}}},v="a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",x="biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");_.prototype.add=function(e,r){return this.__schemas__[e]=r,d(this),this},_.prototype.set=function(e){return this.__opts__=n(this.__opts__,e),this},_.prototype.test=function(e){if(this.__text_cache__=e,this.__index__=-1,!e.length)return!1;var r,t,n,s,i,o,a,c,l;if(this.re.schema_test.test(e))for(a=this.re.schema_search,a.lastIndex=0;null!==(r=a.exec(e));)if(s=this.testSchemaAt(e,r[2],a.lastIndex)){this.__schema__=r[2],this.__index__=r.index+r[1].length,this.__last_index__=r.index+r[0].length+s;break}return this.__opts__.fuzzyLink&&this.__compiled__["http:"]&&(c=e.search(this.re.host_fuzzy_test),c>=0&&(this.__index__<0||c<this.__index__)&&null!==(t=e.match(this.__opts__.fuzzyIP?this.re.link_fuzzy:this.re.link_no_ip_fuzzy))&&(i=t.index+t[1].length,(this.__index__<0||i<this.__index__)&&(this.__schema__="",this.__index__=i,this.__last_index__=t.index+t[0].length))),this.__opts__.fuzzyEmail&&this.__compiled__["mailto:"]&&(l=e.indexOf("@"),l>=0&&null!==(n=e.match(this.re.email_fuzzy))&&(i=n.index+n[1].length,o=n.index+n[0].length,(this.__index__<0||i<this.__index__||i===this.__index__&&o>this.__last_index__)&&(this.__schema__="mailto:",this.__index__=i,this.__last_index__=o))),this.__index__>=0},_.prototype.pretest=function(e){return this.re.pretest.test(e)},_.prototype.testSchemaAt=function(e,r,t){return this.__compiled__[r.toLowerCase()]?this.__compiled__[r.toLowerCase()].validate(e,t,this):0},_.prototype.match=function(e){var r=0,t=[];this.__index__>=0&&this.__text_cache__===e&&(t.push(g(this,r)),r=this.__last_index__);for(var n=r?e.slice(r):e;this.test(n);)t.push(g(this,r)),n=n.slice(this.__last_index__),r+=this.__last_index__;return t.length?t:null},_.prototype.tlds=function(e,r){return e=Array.isArray(e)?e:[e],r?(this.__tlds__=this.__tlds__.concat(e).sort().filter(function(e,r,t){return e!==t[r-1]}).reverse(),d(this),this):(this.__tlds__=e.slice(),this.__tlds_replaced__=!0,d(this),this)},_.prototype.normalize=function(e){e.schema||(e.url="http://"+e.url),"mailto:"!==e.schema||/^mailto:/i.test(e.url)||(e.url="mailto:"+e.url)},r.exports=_},{"./lib/re":54}],54:[function(e,r,t){"use strict";var n=t.src_Any=e("uc.micro/properties/Any/regex").source,s=t.src_Cc=e("uc.micro/categories/Cc/regex").source,i=t.src_Z=e("uc.micro/categories/Z/regex").source,o=t.src_P=e("uc.micro/categories/P/regex").source,a=t.src_ZPCc=[i,o,s].join("|"),c=t.src_ZCc=[i,s].join("|"),l="(?:(?!"+a+")"+n+")",u="(?:(?![0-9]|"+a+")"+n+")",p=t.src_ip4="(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";t.src_auth="(?:(?:(?!"+c+").)+@)?";var h=t.src_port="(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?",f=t.src_host_terminator="(?=$|"+a+")(?!-|_|:\\d|\\.-|\\.(?!$|"+a+"))",d=t.src_path="(?:[/?#](?:(?!"+c+"|[()[\\]{}.,\"'?!\\-]).|\\[(?:(?!"+c+"|\\]).)*\\]|\\((?:(?!"+c+"|[)]).)*\\)|\\{(?:(?!"+c+'|[}]).)*\\}|\\"(?:(?!'+c+'|["]).)+\\"|\\\'(?:(?!'+c+"|[']).)+\\'|\\'(?="+l+").|\\.{2,3}[a-zA-Z0-9%]|\\.(?!"+c+"|[.]).|\\-(?!"+c+"|--(?:[^-]|$))(?:[-]+|.)|\\,(?!"+c+").|\\!(?!"+c+"|[!]).|\\?(?!"+c+"|[?]).)+|\\/)?",m=t.src_email_name='[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+',g=t.src_xn="xn--[a-z0-9\\-]{1,59}",_=t.src_domain_root="(?:"+g+"|"+u+"{1,63})",b=t.src_domain="(?:"+g+"|(?:"+l+")|(?:"+l+"(?:-(?!-)|"+l+"){0,61}"+l+"))",k=t.src_host="(?:"+p+"|(?:(?:(?:"+b+")\\.)*"+_+"))",v=t.tpl_host_fuzzy="(?:"+p+"|(?:(?:(?:"+b+")\\.)+(?:%TLDS%)))",x=t.tpl_host_no_ip_fuzzy="(?:(?:(?:"+b+")\\.)+(?:%TLDS%))";t.src_host_strict=k+f;var y=t.tpl_host_fuzzy_strict=v+f;t.src_host_port_strict=k+h+f;var A=t.tpl_host_port_fuzzy_strict=v+h+f,C=t.tpl_host_port_no_ip_fuzzy_strict=x+h+f;t.tpl_host_fuzzy_test="localhost|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:"+a+"|$))",t.tpl_email_fuzzy="(^|>|"+c+")("+m+"@"+y+")",t.tpl_link_fuzzy="(^|(?![.:/\\-_@])(?:[$+<=>^`|]|"+a+"))((?![$+<=>^`|])"+A+d+")",t.tpl_link_no_ip_fuzzy="(^|(?![.:/\\-_@])(?:[$+<=>^`|]|"+a+"))((?![$+<=>^`|])"+C+d+")"},{"uc.micro/categories/Cc/regex":60,"uc.micro/categories/P/regex":62,"uc.micro/categories/Z/regex":63,"uc.micro/properties/Any/regex":65}],55:[function(e,r,t){"use strict";function n(e){var r,t,n=i[e];if(n)return n;for(n=i[e]=[],r=0;128>r;r++)t=String.fromCharCode(r),n.push(t);for(r=0;r<e.length;r++)t=e.charCodeAt(r),n[t]="%"+("0"+t.toString(16).toUpperCase()).slice(-2);return n}function s(e,r){var t;return"string"!=typeof r&&(r=s.defaultChars),t=n(r),e.replace(/(%[a-f0-9]{2})+/gi,function(e){var r,n,s,i,o,a,c,l="";for(r=0,n=e.length;n>r;r+=3)s=parseInt(e.slice(r+1,r+3),16),128>s?l+=t[s]:192===(224&s)&&n>r+3&&(i=parseInt(e.slice(r+4,r+6),16),128===(192&i))?(c=s<<6&1984|63&i,l+=128>c?"\ufffd\ufffd":String.fromCharCode(c),r+=3):224===(240&s)&&n>r+6&&(i=parseInt(e.slice(r+4,r+6),16),o=parseInt(e.slice(r+7,r+9),16),128===(192&i)&&128===(192&o))?(c=s<<12&61440|i<<6&4032|63&o,l+=2048>c||c>=55296&&57343>=c?"\ufffd\ufffd\ufffd":String.fromCharCode(c),r+=6):240===(248&s)&&n>r+9&&(i=parseInt(e.slice(r+4,r+6),16),o=parseInt(e.slice(r+7,r+9),16),a=parseInt(e.slice(r+10,r+12),16),128===(192&i)&&128===(192&o)&&128===(192&a))?(c=s<<18&1835008|i<<12&258048|o<<6&4032|63&a,65536>c||c>1114111?l+="\ufffd\ufffd\ufffd\ufffd":(c-=65536,l+=String.fromCharCode(55296+(c>>10),56320+(1023&c))),r+=9):l+="\ufffd";return l})}var i={};s.defaultChars=";/?:@&=+$,#",s.componentChars="",r.exports=s},{}],56:[function(e,r,t){"use strict";function n(e){var r,t,n=i[e];if(n)return n;for(n=i[e]=[],r=0;128>r;r++)t=String.fromCharCode(r),n.push(/^[0-9a-z]$/i.test(t)?t:"%"+("0"+r.toString(16).toUpperCase()).slice(-2));for(r=0;r<e.length;r++)n[e.charCodeAt(r)]=e[r];return n}function s(e,r,t){var i,o,a,c,l,u="";for("string"!=typeof r&&(t=r,r=s.defaultChars),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "undefined"==typeof t&&(t=!0),l=n(r),i=0,o=e.length;o>i;i++)if(a=e.charCodeAt(i),t&&37===a&&o>i+2&&/^[0-9a-f]{2}$/i.test(e.slice(i+1,i+3)))u+=e.slice(i,i+3),i+=2;else if(128>a)u+=l[a];else if(a>=55296&&57343>=a){if(a>=55296&&56319>=a&&o>i+1&&(c=e.charCodeAt(i+1),c>=56320&&57343>=c)){u+=encodeURIComponent(e[i]+e[i+1]),i++;continue}u+="%EF%BF%BD"}else u+=encodeURIComponent(e[i]);return u}var i={};s.defaultChars=";/?:@&=+$,-_.!~*'()#",s.componentChars="-_.!~*'()",r.exports=s},{}],57:[function(e,r,t){"use strict";r.exports=function(e){var r="";return r+=e.protocol||"",r+=e.slashes?"//":"",r+=e.auth?e.auth+"@":"",r+=e.hostname&&-1!==e.hostname.indexOf(":")?"["+e.hostname+"]":e.hostname||"",r+=e.port?":"+e.port:"",r+=e.pathname||"",r+=e.search||"",r+=e.hash||""}},{}],58:[function(e,r,t){"use strict";r.exports.encode=e("./encode"),r.exports.decode=e("./decode"),r.exports.format=e("./format"),r.exports.parse=e("./parse")},{"./decode":55,"./encode":56,"./format":57,"./parse":59}],59:[function(e,r,t){"use strict";function n(){this.protocol=null,this.slashes=null,this.auth=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.pathname=null}function s(e,r){if(e&&e instanceof n)return e;var t=new n;return t.parse(e,r),t}var i=/^([a-z0-9.+-]+:)/i,o=/:[0-9]*$/,a=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,c=["<",">",'"',"`"," ","\r","\n","	"],l=["{","}","|","\\","^","`"].concat(c),u=["'"].concat(l),p=["%","/","?",";","#"].concat(u),h=["/","?","#"],f=255,d=/^[+a-z0-9A-Z_-]{0,63}$/,m=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,g={javascript:!0,"javascript:":!0},_={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0};n.prototype.parse=function(e,r){var t,n,s,o,c,l=e;if(l=l.trim(),!r&&1===e.split("#").length){var u=a.exec(l);if(u)return this.pathname=u[1],u[2]&&(this.search=u[2]),this}var b=i.exec(l);if(b&&(b=b[0],s=b.toLowerCase(),this.protocol=b,l=l.substr(b.length)),(r||b||l.match(/^\/\/[^@\/]+@[^@\/]+/))&&(c="//"===l.substr(0,2),!c||b&&g[b]||(l=l.substr(2),this.slashes=!0)),!g[b]&&(c||b&&!_[b])){var k=-1;for(t=0;t<h.length;t++)o=l.indexOf(h[t]),-1!==o&&(-1===k||k>o)&&(k=o);var v,x;for(x=-1===k?l.lastIndexOf("@"):l.lastIndexOf("@",k),-1!==x&&(v=l.slice(0,x),l=l.slice(x+1),this.auth=v),k=-1,t=0;t<p.length;t++)o=l.indexOf(p[t]),-1!==o&&(-1===k||k>o)&&(k=o);-1===k&&(k=l.length),":"===l[k-1]&&k--;var y=l.slice(0,k);l=l.slice(k),this.parseHost(y),this.hostname=this.hostname||"";var A="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!A){var C=this.hostname.split(/\./);for(t=0,n=C.length;n>t;t++){var w=C[t];if(w&&!w.match(d)){for(var q="",D=0,E=w.length;E>D;D++)q+=w.charCodeAt(D)>127?"x":w[D];if(!q.match(d)){var S=C.slice(0,t),F=C.slice(t+1),z=w.match(m);z&&(S.push(z[1]),F.unshift(z[2])),F.length&&(l=F.join(".")+l),this.hostname=S.join(".");break}}}}this.hostname.length>f&&(this.hostname=""),A&&(this.hostname=this.hostname.substr(1,this.hostname.length-2))}var L=l.indexOf("#");-1!==L&&(this.hash=l.substr(L),l=l.slice(0,L));var T=l.indexOf("?");return-1!==T&&(this.search=l.substr(T),l=l.slice(0,T)),l&&(this.pathname=l),_[s]&&this.hostname&&!this.pathname&&(this.pathname=""),this},n.prototype.parseHost=function(e){var r=o.exec(e);r&&(r=r[0],":"!==r&&(this.port=r.substr(1)),e=e.substr(0,e.length-r.length)),e&&(this.hostname=e)},r.exports=s},{}],60:[function(e,r,t){r.exports=/[\0-\x1F\x7F-\x9F]/},{}],61:[function(e,r,t){r.exports=/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/},{}],62:[function(e,r,t){r.exports=/[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDE38-\uDE3D]|\uD805[\uDCC6\uDDC1-\uDDC9\uDE41-\uDE43]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F/},{}],63:[function(e,r,t){r.exports=/[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/},{}],64:[function(e,r,t){r.exports.Any=e("./properties/Any/regex"),r.exports.Cc=e("./categories/Cc/regex"),r.exports.Cf=e("./categories/Cf/regex"),r.exports.P=e("./categories/P/regex"),r.exports.Z=e("./categories/Z/regex")},{"./categories/Cc/regex":60,"./categories/Cf/regex":61,"./categories/P/regex":62,"./categories/Z/regex":63,"./properties/Any/regex":65}],65:[function(e,r,t){r.exports=/[\0-\uD7FF\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF]/},{}],66:[function(e,r,t){"use strict";r.exports=e("./lib/")},{"./lib/":10}]},{},[66])(66)});
/* origin: public/webapp/app/dashboard/data-sources/s3.js */
angular.module('webApp').controller('S3SettingsController', function ($scope, AuthService, Backend, UserService) {

    UserService.getSummary().then(function (res) {
        $scope.accountId = res.data.accountId;
    });

    if (!$scope.settings)
        $scope.settings = {};

    $scope.addS3Settings = function () {
        if (!$scope.settings)
            $scope.settings = [];
        $scope.settings.push({ id: 0, active: true });
    };

    $scope.bucketDeleted = function(bucketIndex) {
        $scope.settings = _.filter($scope.settings, function(s) { return s.id !== bucketIndex; });
    };

    AuthService.getUser().then(function (user) {
        $scope.accountId = user.data.accountId;
    });

    Backend.GET('/s3buckets').then(function (settingsList) {
        if (!settingsList.data || !settingsList.data) {
            alert('There was an error retrieving your s3 settings.\nPlease refresh the page to retry again.');
        }

        settingsList = _.filter(settingsList.data, function (settings) {
            return settings.logsType !== 'elb';
        });
        $scope.settings = settingsList;

        _.forEach($scope.settings, function (s3Settings) {
            s3Settings.secretKey = s3Settings.encryptedSecretKey; // For the dots in the html dom
        });
    });

});
/* origin: public/webapp/app/dashboard/data-sources/wizards/filebeat/logz-datasources-wizard-filebeat-container.js */
angular.module('webApp').directive('logzDatasourcesWizardFilebeatContainer', function(Backend, UserService, AuthService, AnalyticsService) {
    return {
        restrict: 'E',
        scope: {
            os: '@'
        },
        templateUrl: 'app/dashboard/data-sources/wizards/filebeat/logz-datasources-wizard-filebeat.html',
        controller: function($scope, $element) {
            $scope.osTypes = [ { name:'linux', placeholder:'/var/log/*/*.log' }, { name:'windows', placeholder:'C:\\inetpub\\logs\\LogFiles\\W3SVC1\\u_ex*.log' } ];
            var selectedOsType = _.find($scope.osTypes, { name: $scope.os }) || $scope.osTypes[0];
            $scope.selectedOsTypeName = selectedOsType.name;
            $scope.placeholder = selectedOsType.placeholder;
            $scope.prospectors = [{}];

            $scope.changePlaceholder = function (osType) {
                $scope.placeholder = osType.placeholder;
            };

            this.registerProspector = function (index, isValid, generateProspector) {
                $scope.prospectors[index].isValid = isValid;
                $scope.prospectors[index].generateProspector = generateProspector;
            };

            Backend.GET('/cms/docs/NRit1qhDsykUqwYsYC4W8').then(function (res) {
                $scope.logTypes = _.map(res.data.content.split('\n'), function (logType) {
                    var logTypeSplitted = logType.split(',');
                    return {
                        name: logTypeSplitted[0].trim(),
                        value: logTypeSplitted[1].trim()
                    };
                }).sort(function (a, b) {
                    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
                });

                $scope.logTypes.push({ name: 'Other', value: 'Other' });
            });

            var yamlConfigurationTemplates = {};
            Backend.GET('/cms/docs/3rGVsCeBegGwKOm06SUGaS').then(function (res) {
                yamlConfigurationTemplates.linux = res.data.content;
            });
            Backend.GET('/cms/docs/31K5Yftt7O2MqSWeEGk0OE').then(function (res) {
                yamlConfigurationTemplates.windows = res.data.content;
            });

            Backend.GET('/cms/docs/6cgBMj4zbGG6USGsMSW2a4').then(function (res) {
                $scope.yamlProspectorConfiguration = res.data.content;
            });

            if (AuthService.isAuthenticated()) {
                UserService.getSummary().then(function (res) {
                    $scope.token = res.data.accountToken;
                    $scope.listenerAddress = res.data.listenerAddress;
                });
            }
            else {
                $scope.token = '{{API_TOKEN}}';
                $scope.listenerAddress = '{{LOGZ_LISTENER}}';
            }

            $scope.generateConfigurationFile = function() {
                if (!allProspectorsValid()) return;

                var prospectorsYaml = '';
                var yamlConfiguration = $scope.selectedOsTypeName === 'windows'
                  ? yamlConfigurationTemplates.windows
                  : yamlConfigurationTemplates.linux;
                  
                for (var i = 0; i < $scope.prospectors.length; i++) {
                    var prospector = $scope.prospectors[i].generateProspector();
                    var prospectorTemplate = _.clone($scope.yamlProspectorConfiguration, true)
                        .replace('[@path]', prospector.path)
                        .replace('[@outputType]', prospector.outputType)
                        .replace('[@logType]', prospector.logType)
                        .replace('[@token]', $scope.token);

                    var additionalFields = '';
                    if (prospector.additionalFields) {
                        for (var j = 0; j < prospector.additionalFields.length; j++) {
                            additionalFields += [ '\r\n        ', prospector.additionalFields[j].name, ': ', prospector.additionalFields[j].value ].join('');
                        }
                    }
                    prospectorTemplate = prospectorTemplate.replace('[@additionalFields]', additionalFields);

                    var multiline = '';
                    if (prospector.multiline) {
                        multiline += '\r\n      multiline:\r\n';
                        multiline += [ '        pattern: \'', prospector.multiline, '\'\r\n' ].join('');
                        multiline += '        negate: true\r\n';
                        multiline += '        match: after';
                    }
                    prospectorTemplate = prospectorTemplate.replace('[@multiline]', multiline);

                    prospectorsYaml += [ '\r\n', prospectorTemplate ].join('');
                }

                yamlConfiguration = yamlConfiguration
                    .replace('[@prospectors]', prospectorsYaml)
                    .replace('[@logzListener]', $scope.listenerAddress);
                var element = document.createElement('a');
                element.setAttribute('href', [ 'data:text/plain;charset=utf-8,', encodeURIComponent(yamlConfiguration) ].join(''));
                element.setAttribute('download', 'filebeat.yml');

                element.style.display = 'none';
                document.body.appendChild(element);
                element.click();
                document.body.removeChild(element);
                AnalyticsService.report('filebeat:generate-configuration-file', {category: 'filebeat'});

                $scope.$parent.closeThisDialog();
            };

            var allProspectorsValid = function() {
                var isValid = true;
                for (var i = 0; i < $scope.prospectors.length; i++) {
                    var prospectorValid = $scope.prospectors[i].isValid();
                    isValid = isValid && prospectorValid;
                }

                if (isValid)
                    return isValid;

                var ngDialogContainer = $('.ngdialog'),
                    firstInvalid = $element.find('.ng-invalid.ng-touched')[0],
                    ngDialogScrollTop = ngDialogContainer.scrollTop();
                if (!firstInvalid)
                    return isValid;

                firstInvalid.focus();
                ngDialogContainer.scrollTop(ngDialogScrollTop);

                var invalidDomOffset = firstInvalid.offsetTop + firstInvalid.offsetParent.offsetTop;
                if (firstInvalid.classList.contains('additional-field-environment'))
                    invalidDomOffset += firstInvalid.parentElement.offsetTop;
                if (invalidDomOffset < ngDialogScrollTop)
                    ngDialogContainer.animate({scrollTop: invalidDomOffset}, 'slow');

                return isValid;
            };

            $scope.addNewProspector = function() {
                $scope.prospectors.push({});
            };

            $scope.removeProspector = function(index) {
                if ($scope.prospectors.length <= 1)
                    return;

                $scope.prospectors.splice(index, 1);
            };
        }
    };
});

/* origin: public/webapp/app/dashboard/data-sources/wizards/filebeat/logz-datasources-wizard-filebeat-prospector.js */
angular.module('webApp').directive('logzDatasourcesWizardFilebeatProspector', [function() {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/data-sources/wizards/filebeat/logz-datasources-wizard-filebeat-prospector.html',
        require: '^logzDatasourcesWizardFilebeatContainer',
        scope: {
            logTypes: '=',
            prospectorIndex: '='
        },
        controller: function($scope) {
            $scope.outputTypes = [ 'plain', 'json' ];
            $scope.selectedOutputType = $scope.outputTypes[0];
            $scope.path = '';
            $scope.additionalFields = [{ name: '', value: '' }];
            $scope.multiline = false;

            $scope.isPathValid = function() {
                if (!$scope.path || $scope.path === '') return false;

                return /^[A-Za-z0-9\/].*$/.test($scope.path);
            };

            $scope.isOtherLogTypeSelected = function() {
                return $scope.selectedLogType && $scope.selectedLogType.toLowerCase() === 'other';
            };

            $scope.isOtherLogTypeValid = function() {
                if (!$scope.isOtherLogTypeSelected()) return true;

                if (!$scope.otherLogType || $scope.otherLogType === '') return false;

                return /^[A-Za-z][^ ]*$/.test($scope.otherLogType);
            };

            $scope.isMultilineValid = function() {
                return !$scope.multiline || ($scope.multilinePattern && $scope.multilinePattern !== '');
            };

            $scope.isAdditionalFieldValid = function(field) {
                return /^[a-zA-Z0-9_\-]*$/.test(field.name) && (field.name !== '' || field.value === '');
            };
        },
        link: function (scope, element, attrs, wizardCtrl) {
            var generateProspector = function() {
                var prospector = {
                    path: scope.path,
                    logType: getLogType(),
                    outputType: scope.selectedOutputType
                };

                if (scope.multiline) {
                    prospector.multiline = scope.multilinePattern;
                }

                if (scope.additionalFields.length > 1) {
                    var additionalFields = [];
                    for (var i = 0; i < scope.additionalFields.length - 1; i ++) {
                        additionalFields.push(scope.additionalFields[i]);
                    }

                    prospector.additionalFields = additionalFields;
                }

                return prospector;
            };

            var isValid = function() {
                element.find('.path-input').addClass('ng-touched');
                element.find('.log-type-select').addClass('ng-touched');
                element.find('.other-type').addClass('ng-touched');
                element.find('.multiline-pattern').addClass('ng-touched');

                if (!scope.isPathValid() || !getLogType() || !scope.isMultilineValid() || !scope.isOtherLogTypeValid())
                    return false;

                for (var i = 0; i < scope.additionalFields.length; i++) {
                    if (!scope.isAdditionalFieldValid(scope.additionalFields[i]))
                        return false;
                }

                return true;
            };

            var getLogType = function() {
                if (!scope.selectedLogType)
                    return '';

                return scope.isOtherLogTypeSelected() ? scope.otherLogType : scope.selectedLogType;
            };

            var additionalFieldsUpdated = function() {
                var emptyFieldIndex = -1;

                for (var i = scope.additionalFields.length - 1; i >= 0; i--) {
                    var field = scope.additionalFields[i];
                    if (field.name !== '' || field.value !== '')
                        continue;

                    if (emptyFieldIndex === -1) {
                        emptyFieldIndex = i;
                    }
                    else {
                        var shouldRemoveTheLast = emptyFieldIndex === i + 1;
                        var indexToRemove = shouldRemoveTheLast ? emptyFieldIndex : i;
                        scope.additionalFields.splice(indexToRemove, 1);

                        if (!shouldRemoveTheLast) {
                            var elementToFocusOn = element.find('.additional-field-environment')[indexToRemove + 1];
                            if (elementToFocusOn) {
                                elementToFocusOn.focus();
                            }
                        }

                        break;
                    }
                }

                if (emptyFieldIndex === -1)
                    scope.additionalFields.push({ name: '', value: '' });
            };

            var setSelectedLogTypeIfNeeded = function() {
                if (scope.logTypes && (!scope.selectedLogType || _.find(scope.logTypes, { value: scope.selectedLogType })))
                    scope.selectedLogType = '';
            };

            wizardCtrl.registerProspector(scope.prospectorIndex, isValid, generateProspector);

            var additionalFieldsWatcher = scope.$watch('additionalFields', additionalFieldsUpdated, true);
            var logTypesWatcher = scope.$watch('logTypes', setSelectedLogTypeIfNeeded);
            scope.$on('$destroy', function() {
                if (additionalFieldsWatcher) additionalFieldsWatcher();
                if (logTypesWatcher) logTypesWatcher();
            });
        }
    };
}]);

/* origin: public/webapp/app/dashboard/data-sources/wizards/filebeat/logz-datasources-wizard-filebeat.js */
angular.module('webApp').directive('logzDatasourcesWizardFilebeat', function(ngDialog) {
    return {
        restrict: 'E',
        scope: {
            os: '@'
        },
        template: '<span ng-click="openWizard()" class="logz-btn" style="font-family: \"Titillium Web\";">Configuration wizard</span>',
        controller: function($scope) {
            $scope.openWizard = function() {
                ngDialog.open({
                    template: [ '<logz-datasources-wizard-filebeat-container os="', $scope.os, '"><logz-datasources-wizard-filebeat-container/>' ].join(''),
                    plain: true,
                    width: '608px',
                    closeByEscape: false,
                    closeByDocument: false,
                    showClose: false
                });
            };
        }
    };
});

/* origin: public/webapp/app/dashboard/incidents/dismiss-insight/dismiss-insight-controller.js */
angular.module('webApp').controller('DismissInsightController', [ function () {

}]);
/* origin: public/webapp/app/dashboard/incidents/edit-insight/edit-insight-controller.js */
angular.module('webApp').controller('EditInsightController', function ($rootScope, $scope, $element, Backend, AnalyticsService) {
    if ($scope.editInsightData.referenceLinks) {
        $scope.editInsightData.referenceLinks = $scope.editInsightData.referenceLinks.split(' ').map(function (link) {
            return {
                link: link
            };
        });
    }
    $scope.editInsightData.referenceLinks = $scope.editInsightData.referenceLinks || [];
    $scope.editInsightData.referenceLinks.push({link: ''});

    var referenceLinksUpdated = function () {
        var emptyLinkIndex = -1;

        for (var i = $scope.editInsightData.referenceLinks.length - 1; i >= 0; i--) {
            var link = $scope.editInsightData.referenceLinks[i].link;
            if (link && link !== '') {
                continue;
            }

            if (emptyLinkIndex === -1) emptyLinkIndex = i;
            else {
                var shouldRemoveTheLast = emptyLinkIndex === i + 1;
                var indexToRemove = shouldRemoveTheLast ? emptyLinkIndex : i;
                $scope.editInsightData.referenceLinks.splice(indexToRemove, 1);

                if (!shouldRemoveTheLast) {
                    var elementToFocusOn = $element.find('.edit-insight-reference-link')[indexToRemove + 1];
                    if (elementToFocusOn) {
                        elementToFocusOn.focus();
                    }
                }

                break;
            }
        }

        if (emptyLinkIndex === -1) {
            $scope.editInsightData.referenceLinks.push({link: ''});
        }
    };

    var referenceLinksUpdatedWatcher = $scope.$watch('editInsightData.referenceLinks', referenceLinksUpdated, true);

    $scope.saveChanges = function () {
        var newReferenceLinksArr = _.filter(_.uniq(_.map($scope.editInsightData.referenceLinks, 'link')), function (link) {
            return link.length;
        });

        AnalyticsService.report('edit-insight', {
            insightId: $scope.editInsightData.insightId,
            title: $scope.editInsightData.title,
            description: $scope.editInsightData.description,
            referenceLinks: newReferenceLinksArr,
            category: 'insights'
        });

        var insightPostData = {
            insight: {
                title: $scope.editInsightData.title,
                description: $scope.editInsightData.description,
                links: newReferenceLinksArr.join(' ')
            }
        };

        Backend.POST([ '/insights/', $scope.editInsightData.insightId ].join(''), insightPostData).then(function (res) {
            $scope.saveCallback(res.data);
        });

        $scope.closeThisDialog();
    };

    $scope.$on('$destroy', function () {
        if (referenceLinksUpdatedWatcher) referenceLinksUpdatedWatcher();
    });
});
/* origin: public/webapp/app/dashboard/incidents/incidents-chart/incidents-chart-service.js */
angular.module('webApp').service('IncidentsChartService', function ($q, ColorService, IncidentsService, IncidentsChartSettings) {
    var self = this;

    var POINTS_TO_PLOT = 250;
    var DEFAULT_NAVIGATOR_RANGE = +moment().subtract(6, 'months');

    self.chartConfig = IncidentsChartSettings;
    self.chartApi = { //todo build a factory to create the api
        addSeries: function () {},
        removeSeries: function () {},
        showLoading: function () {},
        hideLoading: function () {},
        setExtremes: function () {},
        applyVerticalLines: function () {}
    };

    var DEFAULT_SERIES_PROPERTIES = {
        lineWidth: 2,
        type: 'spline',
        showInNavigator: true
    };

    // var ANNOTATIONS_CHART_PROPERTIES = {
    //     type: 'flags',
    //     visible: false,
    //     marker: {
    //         enabled: true,
    //         symbol: 'square',
    //     },
    //     color: '#C4A4F7',
    //     shape: 'squarepin'
    // };

    var VERTICAL_MARKERS_PROPERTIES = {
        width: 1,
        showInNavigator: true,
        color: '#C4A4F7',
        dashStyle: 'dash',
        label: {
            align: 'right',
            verticalAlign: 'center',
            y: 200,
            x: 5
        }
    };

    self.plotIncidents = function (incidents, range) {
        var incidentsIds = _.map(incidents, 'id');

        // todo we can cache the navigator range by id and time
        return $q.all({
            selectedRange: IncidentsService.getIncidentsChart(incidentsIds, range, POINTS_TO_PLOT),
            navigatorRange: IncidentsService.getIncidentsChart(incidentsIds, self._getDefaultNavigatorRange(), POINTS_TO_PLOT)
        }).then(function (graphsData) {
            var highchartsData = self._convertBucketsToHighcharts(graphsData.selectedRange.insightsBuckets);
            var highchartsNavigatorData = self._convertBucketsToHighcharts(graphsData.navigatorRange.insightsBuckets);
            var incidentsToPlot = [];
            _.forEach(incidents, function (incident) {
                var data = highchartsData[incident.id];
                var navigatorData = highchartsNavigatorData[incident.id];
                if (!data) return;
                incidentsToPlot.push(self._prepareSeries(incident, data, navigatorData, range));
            });
            self.chartApi.addSeries(incidentsToPlot);
        });
    };

    /**
     * Prepare series to be plotted.
     *
     * Adds id, relevant name, unique color. attach the default series properties and add a symbol to the first data point
     * @param incident - An incident data
     * @param data - data points
     * @param navigatorData - navigator data points
     * @param range - chart data range
     */
    self._prepareSeries = function (incident, data, navigatorData, range) {
        var series = {
            id: incident.id,
            name: incident.title || 'no title',
            color: incident.color,
            navigatorOptions: {
                id: ['nav', incident.id].join('-'),
                data: navigatorData
            }
        };
        _.assign(series, DEFAULT_SERIES_PROPERTIES);
        series.data = self._addSymbolToFirstY(data, incident, range.startDate);
        return series;
    };

    self.unPlotIncidents = function (incidents) {
        var incidentsIds = _.map(incidents, 'id');
        self.chartApi.removeSeries(incidentsIds);
        return $q.when();
    };

    self.showLoading = function () {
        self.chartApi.showLoading('Loading data...');
    };
    self.hideLoading = function () {
        self.chartApi.hideLoading();
    };

    self.setExtremes = function (range) {
        self.chartApi.setExtremes(range.startDate, range.endDate);
    };

    self.plotMarkers = function (range) {
        if (!self.markersFeatureEnabled) {
            return $q.resolve();
        }

        return IncidentsService.getMarkers(range.startDate, range.endDate, '_logzio_markers')
            .then(function (data) {
                var series = _.map(data, function (line) {
                    return _.merge({
                        value: line.x,
                        label: {text : line.title}
                    }, VERTICAL_MARKERS_PROPERTIES);
                });
                self.chartApi.applyVerticalLines(series);
            });
    };

    /**
     * Adds a circle to the first point of a series.
     *
     * Adds a bigger point if this is the first occurrence of that incident
     * @param data - series data points
     * @param incident - the relevant incident
     * @param chartStartDate - chart start date
     */
    self._addSymbolToFirstY = function (data, incident, chartStartDate) {
        if (data.length === 0) return data;
        var point = data[0];
        var symbol = {
            symbol: 'circle',
            radius: 7
        };

        //if that is not really the first occurrence
        if (incident.firstOccurrence < chartStartDate) {
            symbol.radius = 4;
        }

        _.set(point, 'marker', symbol);
        return data;
    };

    self._convertBucketsToHighcharts = function (buckets) {
        var seriesData = {};
        buckets = _.orderBy(buckets, 'time');
        _.forEach(buckets, function (bucket) {
            _.forEach(bucket.insightOccurrences, function (occurrence) {
                var point = {x: bucket.time, y: occurrence.occurrences, marker: {enabled: false}};
                if (seriesData[occurrence.insightId]) {
                    seriesData[occurrence.insightId].push(point);
                }
                else {
                    seriesData[occurrence.insightId] = [point];
                }
            });
        });
        return seriesData;
    };

    self._getDefaultNavigatorRange = function () {
        return {
            startDate: DEFAULT_NAVIGATOR_RANGE,
            endDate: +moment()
        };
    };

    self.addFakeSeries = function () {
        self.chartApi.addSeries([{
            //fake chart to force large range in navigator
            id: 'forceXAxis',
            name: 'forceXAxis',
            visible: false,
            showInLegend: false,
            data: [{
                x: self._getDefaultNavigatorRange().startDate,
                y: 0
            }, {
                x: self._getDefaultNavigatorRange().endDate,
                y: 0
            }]
        }]);
    };
});

/* origin: public/webapp/app/dashboard/incidents/incidents-chart/incidents-chart-settings.js */
angular.module('webApp').constant('IncidentsChartSettings', {
    navigator: {
        enabled: true,
        outlineWidth: 0,
        margin: 0,
        maskFill: 'rgba(195,195,195,0.3)',
        adaptToUpdatedData: false,
        series: {
            color: '#A8A8A8',
            fillOpacity: 0.1,
        }
    },
    chart: {
        panning: false, //todo make this true but without refreshing data every time
    },
    series: [],
    title: {
        text: null
    },
    subtitle: {
        text: null
    },
    legend: {
        width: 800,
        align: 'center',
        verticalAlign: 'top',
        textOverflow: 'ellipsis',
        float: 'true',
        itemStyle: {
            width: '140px'
        }
    },
    plotOptions: {
        series: {
            marker: {
                enabled: true,
                symbol: 'circle',
                radius: 4,
                states: {
                    hover: {
                        enabled: true
                    }
                }
            }
        }
    },
    yAxis: {
        min: 0,
        softMax: 5,
        title: {text: 'Occurrences'},
    },
    xAxis: {
        id: 'upperAxis',
        type: 'datetime',
        tickPixelInterval: 150,
        title: {
            text: ''
        },
        events: {
            setExtremes: function () {}
        },
        dateTimeLabelFormats: {
            millisecond: '%H:%M:%S.%L',
            second: '%H:%M:%S',
            minute: '%H:%M',
            hour: '%H:%M',
            day: '%e. %b',
            week: '%e. %b',
            month: '%b \'%y',
            year: '%Y'
        }
    },
    credits: {
        enabled: false
    }
});
/* origin: public/webapp/app/dashboard/incidents/incidents-controller.js */
angular.module('webApp').controller('IncidentsController', function ($scope, $timeout, $q, LogzToast, retentionDays, markersFeatureEnabled,
                                                                     IncidentsFilterService, InsightsService, IncidentsService, IncidentsChartService) {

    var self = this;

    var TOP_INCIDENTS_AMOUNT = 5;
    var MAX_PLOTTED_INCIDENTS = 12;
    var INCIDENTS_ERROR_MESSAGES = {
        FILTER_ERROR: 'Something went wrong while filtering, please try again',
        PLOTTING_ERROR: 'Couldn\'t plot insights, please try again'
    };

    $scope.applyFilter = function (resetPagination) {
        $scope.tableApi.isLoading = true;
        // TODO: Optimize the flow of filter
        resetPagination = (resetPagination !== undefined ? resetPagination : true);
        if (resetPagination) {
            IncidentsFilterService.setPage(1); // reset table paging if content changes
        }

        return $timeout(function () { //Make sure all models are updated
            return IncidentsFilterService.applyFilter($scope.filterObject).then(function (data) {
                $scope.tableOptions.content = data;
                return data;
            }).catch(function (err) {
                LogzToast.error(INCIDENTS_ERROR_MESSAGES.FILTER_ERROR);
                IncidentsService.report('apply-filter-error', {error: err});
            }).finally(function () {
                $scope.tableApi.isLoading = false;
            });
        });
    };

    $scope.tableOptions = {
        content: [],
        selected: [],
        plotted: [],
        paging: {
            pageSize: IncidentsFilterService.getPageSize(),
            pageNumber: IncidentsFilterService.getPageNumber,
            totalResults: IncidentsFilterService.getTotalResults,
            onPageChange: function (pageNumber) {
                IncidentsFilterService.setPage(pageNumber);
                $scope.applyFilter(false)
                    .then(function () {
                        IncidentsService.report('page-change');
                    });
            },
        },
        sortHandler: function (field, desc) {
            IncidentsFilterService.setFilterSorting(field, desc);
            return $scope.applyFilter()
                .finally(function () {
                    IncidentsService.report('table-sorting', {field: field, desc: desc});
                });
        },
        incidentTypeToTitle: _.mapValues(IncidentsService.mapIncidentNameToFieldName, 'title'),
        updateSelectedStatus: function () {}
    };

    $scope.searchQueryChange = function (query) {
        IncidentsFilterService.setFilterSearchQuery(query);
        $scope.applyFilter()
            .then(function () {
                IncidentsService.report('table-search-query', {query: query});
            });
    };

    $scope.incidentsApi = {
        plotSelectedIncidents: function (incidents) {
            if (!incidents) return $q.reject();

            var incidentsArray = !_.isArray(incidents) ? [incidents] : incidents;
            if (_.size(incidentsArray) === 0) return $q.reject();

            if (_.unionBy(incidentsArray, $scope.tableOptions.plotted, 'id').length > MAX_PLOTTED_INCIDENTS) {
                //todo do this check elsewhere
                var errorMsg = ['Max plotted incidents is ', MAX_PLOTTED_INCIDENTS].join('');
                LogzToast.error(errorMsg);
                IncidentsService.report('plot-selected-insights-error', {error: errorMsg});
                return $q.reject(errorMsg);
            }

            IncidentsChartService.showLoading();
            return IncidentsChartService.plotIncidents(incidentsArray, $scope.chartDateRange)
                .then(function () {
                    IncidentsService.toggleItems($scope.tableOptions.plotted, incidentsArray, false);
                    $scope.tableOptions.updateSelectedStatus();

                    IncidentsChartService.hideLoading();
                    IncidentsService.report('plot-selected-insights', {ids: _.map(incidentsArray, 'id')});
                })
                .catch(function (error) {
                    LogzToast.error(INCIDENTS_ERROR_MESSAGES.PLOTTING_ERROR);
                    IncidentsService.report('plot-selected-insights-error', {error: error});
                });
        },
        unPlotSelectedIncidents: function (incidents) {
            if (!incidents) return $q.reject();
            var incidentsArray = !_.isArray(incidents) ? [incidents] : incidents;
            var arrayOfIds = _.map(incidentsArray, 'id');
            return IncidentsChartService.unPlotIncidents(incidentsArray)
                .then(function () {
                    self._removeUnPlotted(arrayOfIds);
                    IncidentsService.report('unplot-selected-insights');
                });
        }
    };

    $scope.resetChart = function () {
        $scope.incidentsApi.unPlotSelectedIncidents($scope.tableOptions.plotted)
            .then(function () {
                IncidentsChartService.setExtremes(IncidentsService.getDefaultDateRange());
                IncidentsService.report('reset-chart');
            });
    };

    $scope.applyTableRangeToChart = function () {
        var filterDateRange = IncidentsFilterService.getFilterDateRange();
        IncidentsChartService.setExtremes(filterDateRange);
        $scope.incidentsApi.plotSelectedIncidents($scope.tableOptions.plotted)
            .then(function () {
                IncidentsService.report('apply-table-range-to-chart');
            });
    };

    self._changeChartSubTitle = function (e) {
        $timeout(function () {
            var startDate = moment(e.min), endDate = moment(e.max);
            var chosenFormat = startDate.year() === endDate.year() ? $scope.dateFormats.SHORT : $scope.dateFormats.LONG;
            $scope.formattedChartDate = [startDate.format(chosenFormat), endDate.format(chosenFormat)].join(' - ');
        });
    };

    self._setRange = function (e) {
        $scope.chartDateRange.startDate = Math.floor(e.min);
        $scope.chartDateRange.endDate = Math.ceil(e.max);
        if (!$scope.tableOptions.plotted.length) return;

        $scope.incidentsApi.plotSelectedIncidents($scope.tableOptions.plotted);
        IncidentsChartService.plotMarkers($scope.chartDateRange);
    };

    self._removeUnPlotted = function (arrayOfIds) {
        _.forEach(arrayOfIds, function (toRemove) {
            _.remove($scope.tableOptions.plotted, {id: toRemove});

            var selectedElement = _.find($scope.tableOptions.selected, {id: toRemove});
            if (selectedElement) {
                selectedElement.isSelected = false;
                _.remove($scope.tableOptions.selected, {id: toRemove});
            }
        });
        $scope.tableOptions.updateSelectedStatus();
    };

    $scope.multiFilterApi = {};
    $scope.clearMultiFilter = function () {
        $scope.multiFilterApi.clearMultiFilter();
        IncidentsService.report('clear-multi-filter');
    };

    var isTopIncidentsPlotted;
    self._plotTopIncidents = function () {
        var topIncidents = [];
        IncidentsFilterService.setFilterSorting('OCCURRENCES', true);

        return $scope.applyFilter()
            .then(function (incidents) {
                topIncidents = _.take(incidents, TOP_INCIDENTS_AMOUNT);
                //if we didn't get the amount we expected
                if (topIncidents.length < TOP_INCIDENTS_AMOUNT) {
                    IncidentsFilterService.setFilterSorting('LAST_OCCURRENCE', true);
                    IncidentsFilterService.setFilterOnlyNewToggle(false);
                    return $scope.applyFilter();
                }
                return $q.when([]);
            })
            .then(function (moreIncidents) {
                IncidentsChartService.setExtremes(IncidentsService.getDefaultDateRange());
                IncidentsChartService.addFakeSeries();

                var topIncidentsCandidates = _.unionBy(_.concat(topIncidents, moreIncidents), 'id');
                topIncidents = _.take(topIncidentsCandidates, TOP_INCIDENTS_AMOUNT);
                $scope.incidentsApi.plotSelectedIncidents(topIncidents)
                    .finally(function () {
                        isTopIncidentsPlotted = true;
                        if (topIncidents.length === 0) {
                            IncidentsService.report('plot-top-insights-error', {error: 'no insights were requested'});
                        }
                        else {
                            IncidentsService.report('plot-top-insights');
                        }
                    });
            })
            .then(function(){
                return IncidentsChartService.plotMarkers($scope.chartDateRange);
            });
    };

    self._dateRangeCallback = function (range) {
        // Always take the day's end of the endDate (so 4-5 will show both 4th and 5th and not just what's in-between)
        range.endDateAsMoment = range.endDateAsMoment.endOf('day');
        var selectedRange = {
            startDate: range.startDateAsMoment.valueOf(),
            endDate: range.endDateAsMoment.valueOf(),
        };
        IncidentsFilterService.setFilterDateRange(selectedRange);
        $scope.applyFilter()
            .then(function () {
                IncidentsService.report('set-filter-date-range', selectedRange);
            });
    };

    self._onlyNewToggleCallback = function (value) {
        IncidentsFilterService.setFilterOnlyNewToggle(value);
        $scope.applyFilter()
            .then(function () {
                IncidentsService.report('show-only-new', {enabled: value});
            });
    };

    self._setExtremes = function (e) {
        self._changeChartSubTitle(e);
        if (isTopIncidentsPlotted && e.min && e.max) {
            self._setRange(e);
        }
    };

    this.$onInit = function () {
        $scope.retentionDays = retentionDays || 0; //resolved from route
        IncidentsChartService.markersFeatureEnabled = markersFeatureEnabled;

        $scope.chartConfig = IncidentsChartService.chartConfig;
        $scope.chartConfig.xAxis.events.setExtremes = self._setExtremes;

        $scope.chartApi = IncidentsChartService.chartApi;

        $scope.selectedFilters = [];
        $scope.filterMultiselectGroup = IncidentsFilterService.filterMultiselectGroup;
        $scope.filterObject = IncidentsFilterService.filterObject;

        $scope.onlyNewToggle = IncidentsFilterService.onlyNewToggle;
        $scope.onlyNewToggle.onlyNewToggleCallback = self._onlyNewToggleCallback;

        $scope.filterDateRange = IncidentsFilterService.dateRange;
        $scope.filterDateRange.initialValue = IncidentsFilterService.initializeDefaultValue();
        $scope.filterDateRange.dateRangeCallback = self._dateRangeCallback;
        $scope.filterDateRange.minDate = IncidentsService.DATE_FORMATS.MAX_DATE;
        $scope.filterDateRange.maxDate = IncidentsService.DATE_FORMATS.MIN_DATE;

        $scope.chartDateRange = IncidentsService.getDefaultDateRange();
        $scope.dateFormats = IncidentsService.DATE_FORMATS;
        $scope.tableApi = {};

        self._plotTopIncidents()
            .then(function () {
                IncidentsFilterService.setFilterOnlyNewToggle(false);
                IncidentsFilterService.setFilterSorting('FIRST_OCCURRENCE', true);
                return $scope.applyFilter();
            });

        // TODO: Loader on the filter
        IncidentsFilterService.setInitialValues()
            .then(function (filterObject) {
                $scope.filterObject = filterObject;
                $scope.filterMultiselectGroup[0].data = _.map($scope.filterObject, function (value) {
                    return {data: value, name: value.name};
                });
            });

        $scope.accountUsers = [{text: 'No one'}];
        InsightsService.getInsightsAccountUsers().then(function (users) {
            $scope.accountUsers = $scope.accountUsers.concat(_.map(users, function (user) {
                var displayedOption = user.myUser ? 'Me' : user.fullName;
                return {value: user.userId, text: displayedOption, expand: true, data: user};
            }));
        });

    };
});
/* origin: public/webapp/app/dashboard/incidents/incidents-filter-service.js */
angular.module('webApp').service('IncidentsFilterService', function ($q, IncidentsService, InsightsService, IntervalCalculator) {
    var self = this;
    self.defaultRange = IncidentsService.getDefaultDateRange();

    var SPARKLINE_BUCKETS = 6;
    var filter = {
        from: 0,
        size: 10,
        startDate: +self.defaultRange.startDate,
        endDate: +self.defaultRange.endDate,
        status: null, // ['ACTIVE']
        assignees: null, // []
        tagNames: null, // []
        onlyNew: true,
        sortBy: 'FIRST_OCCURRENCE', //OCCURRENCES, TAG_NAME, SEVERITY, TITLE, LAST_OCCURRENCE, FIRST_OCCURRENCE
        asc: false,
        search: null,
        logTypes: null,
        sparklineInterval: null
    };

    self.applyFilter = function (filterObject) {
        return IncidentsService.getIncidents(self._serializeFilter(filterObject))
            .then(function (data) {
                pagingData.totalResults = data.total;
                pagingData.pageNumber = (filter.from / filter.size) + 1;// todo convert to function.
                return data.results;
            });
    };

    // ~~~~~~~~~~~~~ Multi Filter ~~~~~~~~~~~~~~~~
    function FilterType(options) {
        this.name = options.name;
        this.id = options.id;
        this.filterType = options.filterType || 'appMultiselectCheckbox';
        this.data = options.data || [];
        this.singular = options.singular || this.name;
        this.width = options.width || 600;
    }

    FilterType.prototype.getSelectedItems = function () {
        return _.filter(this.data, {model: true});
    };

    FilterType.prototype.getSelectedCount = function () {
        return this.getSelectedItems().length;
    };

    FilterType.prototype.isEmpty = function () {
        return this.getSelectedCount() === 0;
    };

    FilterType.prototype.getSelectedItemNames = function () {
        return _.map(this.getSelectedItems(), function (item) {
            return item.label;
        });
    };

    FilterType.prototype.getDisplayedName = function () {
        var currentCount = this.getSelectedCount();
        if (currentCount === 1) {
            return [this.singular, ' : ', this.getSelectedItemNames()].join('');
        }
        else if (currentCount === 2) {
            return [this.name, ' : ', this.getSelectedItemNames().join(', ')].join('');
        }
        else {
            return [this.name, ': ', this.getSelectedItemNames().slice(0, 2).join(', '), ' +', currentCount - 2, ' more'].join('');
        }
    };

    self.filterObject = {
        types: new FilterType({
            name: 'Types',
            id: 'types',
            filterType: 'appSimpleMultiCheckbox',
            data: _.map(IncidentsService.mapIncidentNameToFieldName, function (incidentValues, incidentKeyName) {
                return {label: incidentValues.title, value: incidentKeyName};
            }),
            width: 250
        }),
        tagNames: new FilterType({
            name: 'Tags',
            singular: 'Tag',
            id: 'tagNames'
        }),
        status: new FilterType({
            name: 'Status',
            id: 'status',
            filterType: 'appSimpleMultiCheckbox',
            data: [
                {label: 'Active', value: 'ACTIVE'},
                {label: 'Dismissed', value: 'DISMISSED'},
                {label: 'Solved', value: 'SOLVED'}
            ],
            width: 250
        }),
        assignees: new FilterType({
            name: 'Assignees',
            singular: 'Assignee',
            id: 'assignees',
        })
    };

    self.filterMultiselectGroup = [{
        name: 'Filters',
        noResults: 'No such filter',
        id: 0,
        data: []
    }];

    self.setInitialValues = function () {
        return $q.all({
            users: InsightsService.getInsightsAccountUsers(),
            tagNames: InsightsService.getInsightsTags() //TODO ask naor
        }).then(function (filterData) {
            self.filterObject.assignees.data = _.map(filterData.users, function (user) {
                return {value: user.userId, label: user.fullName, text: user.fullName};
            });
            self.filterObject.tagNames.data = _.map(filterData.tagNames, function (tagName) {
                return {value: tagName, label: tagName};
            });

            return self.filterObject;
        });
    };

    // ~~~~~~~~~~~~~ DATE RANGE FILTER ~~~~~~~~~~~~~~~~
    self.dateRange = {};
    // // Since the directive does not support initial value, we pass it as a string in its ng-model

    self.initializeDefaultValue = function () {
        return {
            startDate: moment(+self.defaultRange.startDate).format(IncidentsService.DATE_FORMATS.DATE_RANGE_PICKER),
            startDateAsMoment: moment(+self.defaultRange.startDate),
            endDate: moment(+self.defaultRange.endDate).format(IncidentsService.DATE_FORMATS.DATE_RANGE_PICKER),
            endDateAsMoment: moment(+self.defaultRange.endDate)
        };
    };

    self.setFilterDateRange = function (range) {
        filter.startDate = range.startDate;
        filter.endDate = range.endDate;
    };
    self.getFilterDateRange = function () {
        return {
            startDate: filter.startDate,
            endDate: filter.endDate
        };
    };
    // ~~~~~~~~~~~~~ Only New Toggle ~~~~~~~~~~~~~~~~
    self.onlyNewToggle = {
        value: false
    };
    self.setFilterOnlyNewToggle = function (value) {
        filter.onlyNew = value;
    };

    // ~~~~~~~~~~~~~ Search Query ~~~~~~~~~~~~~~~~
    self.setFilterSearchQuery = function (value) {
        filter.search = value;
    };

    // ~~~~~~~~~~~~~~~ Sorting ~~~~~~~~~~~~~~~~~~~
    self.setFilterSorting = function (value, desc) {
        filter.sortBy = value;
        filter.asc = !desc;
    };

    // ~~~~~~~~~~~~~~~ Paging ~~~~~~~~~~~~~~~~~~~
    var pagingData = {
        pageNumber: 1,
        totalResults: 0
    };
    self.setPage = function (pageNumber) {
        // Page 1 is from index 0
        filter.from = (pageNumber - 1) * filter.size;
        pagingData.pageNumber = pageNumber;
    };
    self.getPageSize = function () {
        return filter.size;
    };
    self.getPageNumber = function () {
        return pagingData.pageNumber;
    };
    self.getTotalResults = function () {
        return pagingData.totalResults;
    };

    self._serializeFilter = function (filterObject) {
        _.forEach(filterObject, function (filterType) {
            filter[filterType.id] = self._getSelectedModels(filterType.data); //todo make this as prototype
        });
        filter.sparklineInterval = IntervalCalculator.calculateInterval(filter.startDate, filter.endDate, SPARKLINE_BUCKETS);
        return filter;
    };

    self._getSelectedModels = function (data) {
        var selected = _.chain(data)
            .filter('model')
            .map(function (tag) {
                return tag.value;
            })
            .value();
        return selected.length > 0 ? selected : null;
    };
});
/* origin: public/webapp/app/dashboard/incidents/incidents-header/incidents-header.js */
angular.module('webApp').component('incidentsHeader', {
    templateUrl: 'app/dashboard/incidents/incidents-header/incidents-header.html',
    controller: 'IncidentHeaderCtrl'
})
    .controller('IncidentHeaderCtrl', function (IncidentsService) {
        var self = this;
        self.$onInit = function () {
            return IncidentsService.getWeeklySummaryData()
                .then(function (data) {
                    self.summary = data;
                });
        };

    });

/* origin: public/webapp/app/dashboard/incidents/incidents-service.js */
angular.module('webApp').service('IncidentsService', function ($q, Backend, IntervalCalculator, AuthService, ElasticSearchService,
                                                               AnalyticsService, logzioApi, kibanaNavigator, FeatureFlagService) {

    var self = this;

    self.defaultRange = {
        startDate: +moment().subtract(1, 'week'),
        endDate: +moment(),
    };

    self.mapIncidentNameToFieldName = {
        PUBLIC_CI: {
            title: 'Cognitive Insights',
            field: '_logzio_insights',
            color: '#9079d6'
        },
        LOGCEPTION: {
            title: 'Application Insights',
            field: '_logzio_logceptions',
            color: '#1fb9b4'
        }
    };
    // {title: 'Markers', name: 'ANNOTATION', field: '_logzio_annotation', color: '#ed3c9c'}

    self.DATE_FORMATS = {
        SHORT: 'MMM D',
        LONG: 'MMM D, YYYY',
        FULL: 'MMM D, YYYY H:mm',
        DATE_RANGE_PICKER: 'MMM DD YYYY',
        MIN_DATE: moment(),
        MAX_DATE: moment().subtract(1, 'years')
    };

    /**
     * Analytics report wrapper
     */
    self.report = function (eventName, additionalData, incident) {
        var data = _.assign({
            category: 'insights',
            location: 'WebApp',
            insightType: _.get(incident, 'type'),
            incidentId: _.get(incident, 'id')
        }, additionalData);
        AnalyticsService.report(eventName, data);
    };


    /**
     * Get the default date range for chart, table, summary and etc.
     */
    self.getDefaultDateRange = function () {
        return _.cloneDeep(self.defaultRange);
    };

    self.getIncidentsChart = function (incidentIds, range, size) {
        if (!incidentIds.length) return $q.reject('no incidents were requested');
        return Backend.POST('/insights/charts', {
            startDate: range.startDate,
            endDate: range.endDate,
            insightIds: incidentIds,
            interval: IntervalCalculator.calculateInterval(range.startDate, range.endDate, size)
        }).then(function (res) {
            return res.data;
        });

    };

    /**
     * Edit multiple incidents.
     *
     * Create an array of objects with at least their ID, and send the changes of their object to the server.
     * @param incidents - An array of the incidents to be updated
     * @param pick - What fields do we want to update
     */
    self.applyIncidentsChanges = function (incidents, pick) {
        var copiedIncidents = [];
        pick = pick || ['id', 'assignee', 'status', 'title', 'description', 'links', 'severity'];
        pick = _.union(pick, ['id']);
        _.forEach(incidents, function (incident) {
            copiedIncidents.push(_.pick(incident, pick));
        });
        return Backend.POST('insights/edit', {request: copiedIncidents})
            .then(function (res) {
                return res.data;
            });
    };

    self.getSummaryData = function (request) {
        return Backend.POST('insights/summary', request);
    };

    /**
     * Get the summary data of the incidents (the number of incidents/ alerts etc..)
     */
    self.getWeeklySummaryData = function () {
        var defaultRange = self.getDefaultDateRange();
        var request = {
            types: ['PUBLIC_CI', 'LOGCEPTION'],
            timeRanges: [{
                startDate: +moment(defaultRange.startDate).subtract(1, 'week'),
                endDate: +moment(defaultRange.endDate).subtract(1, 'week')
            }, {
                startDate: +moment(defaultRange.startDate),
                endDate: +moment(defaultRange.endDate)
            }]
        };
        return self.getSummaryData(request)
            .then(function (res) {
                return _.reduce(_.get(res, 'data.response'), function (result, incidentData, incidentKey) {
                    var change = incidentData[1] / incidentData[0] - 1;
                    result[incidentKey] = {
                        value: incidentData[1],
                        change: change === Infinity ? 1 : change, //'âˆž'
                        title: self.mapIncidentNameToFieldName[incidentKey].title
                    };
                    return result;
                }, {});
            });
    };

    //TODO should be better
    // Get markers from ES
    self.getMarkers = function (from, to, fieldExists) {
        return ElasticSearchService.getElasticSearchLogLines(from, to, fieldExists).then(function (res) {
            var hits = _.get(res, 'data.hits.hits', []);
            return _.map(hits, function (hit) {
                return {
                    x: +moment(_.get(hit, '_source.@timestamp')),
                    title: _.get(hit, '_source.message'),
                    y: 0
                };
            });
        });
    };

    self.openCreateAlertWizardForIncident = function (incidentId, incidentType) {
        var match = {};
        match[self.mapIncidentNameToFieldName[incidentType].field] = {
            query: incidentId,
            type: 'phrase'
        };
        var alertInitialData = {};
        var filter = {
            bool: {
                must: [{
                    match_phrase: match
                }]
            }
        };

        return FeatureFlagService.isFeatureEnabled('continuous-aggregation').then(function (continuousAggregationEnabled) {
            if (continuousAggregationEnabled) {
                alertInitialData = {
                    search: {
                        queryString: '*',
                        filter: filter
                    },
                };
            }
            else {
                alertInitialData = {
                    alertDefinition: {
                        query: '*',
                        filter: filter
                    }
                };
            }

            logzioApi.openCreateAlertWizard(alertInitialData);
        });
    };

    var daysFromLastOccurrence = 2; // 2 Days
    self.viewInKibana = function (incidentData) {
        return AuthService.getUser()
            .then(function (res) {
                var indexPrefix = res.data.indexPrefix;
                var query = [self.mapIncidentNameToFieldName[incidentData.type].field, incidentData.id].join(':');
                var toDate = incidentData.lastOccurrence;
                var fromDate = moment(toDate).subtract(daysFromLastOccurrence, 'days');
                kibanaNavigator.navigateToDiscover(query, fromDate, toDate, null, indexPrefix, true);
            });
    };

    self.getIncidents = function (filter) {
        return Backend.POST('/insights/list', filter, {dontShowProgressBar: true})
            .then(function (res) {
                return res.data;
            });
    };

    self.toggleItems = function (collection, item, force) {
        if (_.isArray(item)) {
            _.forEach(item, function (single) {
                self.toggleItems(collection, single, force);
            });
            return;
        }
        var idx = _.indexOf(collection, item);
        if (idx !== -1) {
            if (force === false) return;
            collection.splice(idx, 1);
        }
        else {
            if (force === true) return;
            collection.push(item);
        }
    };
});
/* origin: public/webapp/app/dashboard/incidents/incidents-table/incidents-expanded-row/incidents-expanded-row.js */
angular.module('webApp')
    .component('incidentsExpandedRow', {
        templateUrl: 'app/dashboard/incidents/incidents-table/incidents-expanded-row/incidents-expanded-row.html',
        bindings: {
            incidentData: '='
        },
        controllerAs: 'expandedIncident',
        controller: 'IncidentsExpandedRowCtrl'
    })
    .controller('IncidentsExpandedRowCtrl', function ($timeout, IncidentsService, InsightsService) {
        var self = this;

        self.helpfulHandle = function () {
            if (self.incidentData.helpful === true) { // May be undefined
                return;
            }

            self.showImprovementsContainer = false;
            self.incidentData.helpful = true;

            InsightsService.sendImprovementSuggest(self.incidentData.id, true);
            InsightsService.updateIncidentCachedInsight(self.incidentData);
            IncidentsService.report('insight-improve-suggestion', { helpful: true }, self.incidentData);
            showThankYouMessage();
        };

        var lastHelpfulState;
        self.notHelpfulHandle = function () {
            if (self.incidentData.helpful === false) { // May be undefined
                return;
            }

            lastHelpfulState = self.incidentData.helpful;
            self.showImprovementsContainer = true;
            self.incidentData.helpful = false;
        };

        self.cancelImprovementSuggest = function () {
            self.showImprovementsContainer = false;
            self.incidentData.helpful = undefined;
            self.incidentData.helpful = lastHelpfulState;
        };

        self.sendImprovementSuggest = function () {
            InsightsService.sendImprovementSuggest(self.incidentData.id, false, self.improvementsRequest);
            InsightsService.updateIncidentCachedInsight(self.incidentData);
            IncidentsService.report('insight-improve-suggestion', { helpful: false, helpfulMessage: self.improvementsRequest }, self.incidentData);
            self.showImprovementsContainer = false;
            $timeout(showThankYouMessage, 400); // After the close improvement container animation is done
        };

        self.reportOpenInsightLink = function (link) {
            IncidentsService.report('open-insight-link', { link: link });
        };

        var showThankYouTimer;
        var showThankYouMessage = function () {
            if (self.showThankYouContainer) {
                $timeout.cancel(showThankYouTimer);
            }

            self.improvementsRequest = '';

            self.showThankYouContainer = true;
            showThankYouTimer = $timeout(function () {
                self.showThankYouContainer = false;
            }, 5000);
        };
    });

/* origin: public/webapp/app/dashboard/incidents/incidents-table/incidents-table-row/incidents-table-row.component.js */
angular.module('webApp').component('incidentTableRow', {
    controller: 'incidentTableRowCtrl',
    controllerAs: 'vm',
    templateUrl: 'app/dashboard/incidents/incidents-table/incidents-table-rpw/incidents-table-row.html'
});
/* origin: public/webapp/app/dashboard/incidents/incidents-table/incidents-table-row/incidents-table-row.controller.js */
// angular.module('webApp').controller('incidentsTableRowCtrl', function () {
//
// });
/* origin: public/webapp/app/dashboard/incidents/incidents-table/incidents-table.js */
/* eslint-disable max-lines */
angular.module('webApp').component('incidentsTable', {
    bindings: {
        accountUsers: '=',
        tableOptions: '=',
        incidentApi: '=',
        tableApi: '=',
        retentionDays: '<'
    },
    templateUrl: 'app/dashboard/incidents/incidents-table/incidents-table.html',
    controller: 'IncidentsTableCtrl',
    controllerAs: 'vm'
}).controller('IncidentsTableCtrl', function ($scope, AuthService, AnalyticsService, InsightsService,
                                              IncidentsService, IncidentsTableService, ColorService) {
    var self = this;
    
    self.dateFormats = IncidentsService.DATE_FORMATS;

    self._reportAnalytics = function (event, additionalData) {
        IncidentsService.report(event, additionalData, self.currentIncident);
    };

    self._updateInsightToIncidentData = function (updatedInsightData) {
        self.currentIncident.severity = updatedInsightData.insight.severity;
        self.currentIncident.status = updatedInsightData.status;
        self.currentIncident.title = updatedInsightData.insight.title;
        self.currentIncident.description = updatedInsightData.insight.description;
        self.currentIncident.links = updatedInsightData.insight.links;
        self.currentIncident.textLastEditedDate = updatedInsightData.textLastEditedDate;
        self.currentIncident.textLastEditedBy = updatedInsightData.textLastEditedBy;
        self.currentIncident.severityLastEditedDate = updatedInsightData.severityLastEditedDate;
        self.currentIncident.severityLastEditedBy = updatedInsightData.severityLastEditedBy;

        InsightsService.updateIncidentCachedInsight(self.currentIncident);
    };

    self.selection = {
        selectedStatus: {},
        selectedSection: {
            plotted: false,
            content: false
        },
        toggleSelection: function (incidentData) {
            IncidentsService.toggleItems(self.tableOptions.selected, incidentData);
            cleanAllStatus();
            self.tableOptions.updateSelectedStatus();
        },
        toggleSectionSelection: function (sectionCollection) {
            var difference = _.differenceBy(sectionCollection, self.tableOptions.selected, 'id');
            if (difference.length === 0) {
                IncidentsService.toggleItems(self.tableOptions.selected, sectionCollection, true);
                self.selection.markSelected(sectionCollection, false);
            }
            else {
                IncidentsService.toggleItems(self.tableOptions.selected, sectionCollection, false);
                self.selection.markSelected(difference, true);
            }
            self.tableOptions.updateSelectedStatus();
        },
        isSelected: function (section) {
            self.selection.selectedSection[section] = _.every(self.tableOptions[section], 'isSelected');
            return self.selection.selectedSection[section];
        },
        isIndeterminate: function (sectionCollection) {
            var intersected = _.intersectionBy(sectionCollection, self.tableOptions.selected, 'id').length;
            return intersected > 0 && intersected < sectionCollection.length;
        },
        clearSelected: function () {
            self.selection.markSelected(self.tableOptions.selected, false);
            self.tableOptions.selected = [];
            self.tableOptions.updateSelectedStatus();
        },
        markSelected: function (collection, isSelected) {
            _.forEach(collection, function (incidentData) {
                incidentData.isSelected = isSelected;
            });
        }
    };

    self.actions = {
        singleActions: {
            edit: {
                title: 'Edit',
                action: function (incidentData) {
                    self.currentIncident = incidentData;
                    var editInsightData = {
                        insightId: incidentData.id,
                        title: incidentData.title,
                        description: incidentData.description,
                        referenceLinks: incidentData.links
                    };

                    //TODO remake this modal
                    InsightsService.popupEditInsightDialog(editInsightData,
                        self.actions.singleActions.edit.editInsightCallback);
                },
                editInsightCallback: function (newInsightData) {
                    self._updateInsightToIncidentData(newInsightData);

                    self._reportAnalytics('edit-insight', {
                        title: self.currentIncident.title,
                        description: self.currentIncident.description,
                        referenceLinks: self.currentIncident.links
                    });
                }
            },
            createAnAlert: {
                title: 'Create an Alert/Optimizer',
                action: function (incidentData) {
                    self.currentIncident = incidentData;
                    IncidentsService.openCreateAlertWizardForIncident(incidentData.id, incidentData.type);

                    self._reportAnalytics('insight-create-alert-clicked');
                }
            }
            // setGraphDate: {//TODO
            //     title: 'Set date',
            //     action: function (incidentData) {
            //         console.log('setGraphDate', incidentData);
            //     }
            // }
        },
        otherActions: {
            viewInKibana: {
                title: 'View in kibana',
                action: function (incidentData) {
                    self.currentIncident = incidentData;
                    if (!incidentData.insightInRetention) return;
                    IncidentsService.viewInKibana(incidentData);
                    self._reportAnalytics('insight-view-in-kibana');
                }
            },
            plotIncident: {
                title: 'Plot Insight',
                action: function (incidentData) {
                    self.currentIncident = incidentData;
                    self.incidentApi.plotSelectedIncidents(incidentData);
                }
            },
            unPlotIncident: {
                title: 'Un-Plot Insight',
                action: function (incidentData) {
                    self.currentIncident = incidentData;
                    self.incidentApi.unPlotSelectedIncidents(incidentData);
                }
            }
        },
        multiActions: {
            plotIncidents: {
                action: function () {
                    return self.incidentApi.plotSelectedIncidents(self.tableOptions.selected);
                }
            },
            unPlotIncidents: {
                action: function () {
                    self.incidentApi.unPlotSelectedIncidents(self.tableOptions.selected);
                }
            }
        }
    };

    self.assignee = {
        applyAssigneeUrl: 'app/dashboard/incidents/incidents-table/assignee-expand-dialog/assignee-expand-dialog.html',
        applyAssigneeChange: function (incidentData, expandedOption) {
            // because there are two methods for app select for callback, one for expanded and one for the regular
            // the callback get called twice. so we need to ignore the cases where the assignee is not null
            // and no expanded data has been sent
            if (incidentData.assignee !== null && !expandedOption.option ) return;
            self.currentIncident = incidentData;
            var assigneeUserName = _.get(expandedOption, 'option.data.username', 'NONE');
            InsightsService.setInsightAssignee(incidentData.id, assigneeUserName, expandedOption.message).then(function (res) {
                incidentData.assigneeData = _.find(self.accountUsers, {value: expandedOption.option.value});
                InsightsService.updateIncidentCachedInsight(res.data);
            });
            self._reportAnalytics('insight-assignee-change', {newAssignee: assigneeUserName});
        },
        // multiApplyAssigneeExpansion: function (incidentData, message) {
        //     _.forEach(incidentsTable.tableOptions.selected, function (incidentData) {
        //         incidentData.assignee = incidentsTable.assignee.all;
        //         InsightsService.setInsightAssignee(incidentData.id, incidentsTable.assignee.all, message);
        //     });
        //     self._reportAnalytics('insight-assignee-change', { newAssignee: incidentsTable.assignee.all });
        // }
    };

    self.status = {
        data: [{
            text: 'Active',
            value: 'ACTIVE'
        }, {
            text: 'Solved',
            value: 'SOLVED'
        }, {
            text: 'Dismissed',
            value: 'DISMISSED'
        }],
        applyStatus: function (incidentData) {
            self.currentIncident = incidentData;
            if (incidentData.status === 'DISMISSED') {
                // Special dismiss case handle, we validate the user knows what he is doing
                InsightsService.popupDismissInsightDialog(self.status.changeStatus, self.status.revertStatus);
                return;
            }

            self.status.changeStatus();
        },
        multiApplyStatus: function (status) {
            self.currentIncident = self.tableOptions.selected;
            if (status === 'DISMISSED') {
                // Special dismiss case handle, we validate the user knows what he is doing
                InsightsService.popupDismissInsightDialog(self.status.changeStatus, self.status.revertStatus);
                return;
            }
            self.status.changeStatus();
        },
        revertStatus: function () {
            if (_.isArray(self.currentIncident)) return;
            self.currentIncident.status = self.currentIncident.previousStatus;
            InsightsService.updateIncidentCachedInsight(self.currentIncident);
        },
        changeStatus: function () {
            var newStatus;
            if (_.isArray(self.currentIncident)) {
                newStatus = self.status.all;
                _.forEach(self.currentIncident, function (incidentData) {
                    incidentData.previousStatus = incidentData.status;
                    incidentData.status = newStatus;
                });
                IncidentsService.applyIncidentsChanges(self.currentIncident, ['status']).then(function (data) {
                    _.forEach(data, function (incidentData) {
                        InsightsService.updateIncidentCachedInsight(incidentData);
                    });
                });
            }
            else {
                self.currentIncident.previousStatus = self.currentIncident.status;
                InsightsService.setInsightStatus(self.currentIncident.id, self.currentIncident.status);
                newStatus = self.currentIncident.status;
                InsightsService.updateIncidentCachedInsight(self.currentIncident);
            }

            self._reportAnalytics('change-insight-status', {newStatus: newStatus});
        }
    };

    self.severity = {
        data: [{
            text: 'Notable',
            value: 'LOW',
            templateUrl: 'directives/app-severity/select-severity.html'
        }, {
            text: 'Important',
            value: 'MEDIUM',
            templateUrl: 'directives/app-severity/select-severity.html'
        }, {
            text: 'Critical',
            value: 'HIGH',
            templateUrl: 'directives/app-severity/select-severity.html'
        }],
        multiApplySeverity: function (severityValue) {
            _.forEach(self.tableOptions.selected, function (incidentData) {
                incidentData.severity = severityValue;
            });
            IncidentsService.applyIncidentsChanges(self.tableOptions.selected, ['severity']).then(function (data) {
                _.forEach(data, function (incidentData) {
                    InsightsService.updateIncidentCachedInsight(incidentData);
                });
            });
        },
        applySeverity: function (incidentData) {
            self.currentIncident = incidentData;

            InsightsService.setInsightSeverity(self.currentIncident.id, self.currentIncident.severity).then(function (res) {
                self.currentIncident.severityLastEditedDate = res.data.severityLastEditedDate;
                self.currentIncident.severityLastEditedBy = res.data.severityLastEditedBy;

                InsightsService.updateIncidentCachedInsight(self.currentIncident);

                self._reportAnalytics('insight-severity-change', {newSeverity: self.currentIncident.severity});
            });
        },
    };

    self.isNotPlottedIncidents = function (incidentData) {
        return !_.some(self.tableOptions.plotted, {id: incidentData.id});
    };

    function cleanAllStatus() {
        self.severity.all = undefined;
        self.status.all = undefined;
    }

    /*****************************************************************************************************
     *                                              WATCHERS                                             *
     *****************************************************************************************************/

    // TODO: Convert this to $onChanges
    $scope.$watch(function () {
        return self.tableOptions.content;
    }, function () {
        self.tableOptions.selected.length = 0;

        //TODO make this better - its not working
        _.forEach(self.tableOptions.plotted, function (incident) {
            incident.isSelected = false;
        });

        _.forEach(self.tableOptions.content, function (incidentData) {
            incidentData.previousStatus = incidentData.status;
            incidentData.sparklineChartConfig = IncidentsTableService.getOccurrencesChartConfig(incidentData);
            incidentData.color = ColorService.convertStringToRGBA(incidentData.id);

            incidentData.exception = _.get(incidentData.additionalData, 'exception', null);
            incidentData.subTitleName = _.get(incidentData.additionalData, 'subTitleName', null);
            incidentData.assigneeData = _.find(self.accountUsers, {value: incidentData.assignee}); //todo there is a better way here, this is due to backend change between old and new api
            incidentData.insightInRetention = +moment().subtract(self.retentionDays, 'days') <= incidentData.lastOccurrence;
            incidentData.occurrencesHumanReadable = LogzIO.Strings.HumanReadableNumber(incidentData.occurrences);

            //replace old plotted/selected items with the newly arrived items,if any. to rebind them
            var plottedIndex = _.findIndex(self.tableOptions.plotted, {id: incidentData.id});
            if (plottedIndex !== -1) {
                self.tableOptions.plotted.splice(plottedIndex, 1, incidentData);
            }
        });

        self.tableOptions.updateSelectedStatus();
    });

    function updateSelectedStatus() {
        self.selection.selectedStatus.plot = _.difference(self.tableOptions.selected, self.tableOptions.plotted).length > 0;
        self.selection.selectedStatus.unPlot = _.intersection(self.tableOptions.plotted, self.tableOptions.selected).length > 0;
        self.selection.selectedStatus.showMultiActions = self.tableOptions.selected.length;
    }

    self.$onInit = function () {
        self.tableOptions.updateSelectedStatus = updateSelectedStatus;
    };

});
/* eslint-enable max-lines */
/* origin: public/webapp/app/dashboard/incidents/incidents-table/incidents-table.service.js */
angular.module('webApp').service('IncidentsTableService', function () {
    var self = this;

    self.generateDataForOccurrencesChart = function (occurrencesData) {
        return Object.keys(occurrencesData).sort().map(function (timestamp) {
            return {x: +timestamp, y: occurrencesData[timestamp]};
        });
    };

    self.getOccurrencesChartConfig = function (incident) {
        return {
            chart: {
                type: 'column',
                backgroundColor: null
            },
            title: false,
            legend: false,
            xAxis: {
                visible: false,
                type: 'datetime',

            },
            yAxis: {
                visible: false
            },
            tooltip: {
                headerFormat: '',
                pointFormat: '{point.x:%Y-%m-%d %H:%M} <br /> {point.y} occurrences'
            },
            credits: false,
            plotOptions: {
                column: {

                    color: '#a3a3a3',
                    borderWidth: 0,
                    states: {
                        hover: {
                            animation: {duration: 200},
                            brightness: -0.3,
                            borderWidth: 5,
                            borderColor: '#575757'
                        }
                    }
                }
            },
            series: [{
                data: self.generateDataForOccurrencesChart(incident.sparkline)
            }]
        };
    };
});
/* origin: public/webapp/app/dashboard/kibana-container/kibana-container.js */
angular.module('webApp').controller('KibanaContainerCtrl', function ($scope, Backend, UserService, KibanaFrameService) {

    $scope.preparingAccountIndex = true;
    KibanaFrameService.waitForAccountInitialLoad()
        .then(function () {
            $scope.preparingAccountIndex = false;
        });
});

/* origin: public/webapp/app/dashboard/kibana-frame/kibana-frame-controller.js */
angular.module('webApp').controller('KibanaFrameController', function ($scope, KibanaFrameService) {
    $scope.kibanaFrameService = KibanaFrameService;
});
/* origin: public/webapp/app/dashboard/kibana-frame/kibana-frame.js */
angular.module('webApp').directive('kibanaFrame', function () {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/kibana-frame/kibana-frame.html',
        scope: {
            isEmbedded: '=?'
        },
        controller: 'KibanaFrameController'
    };
});
/* origin: public/webapp/app/dashboard/settings/audit-trail/audit-trail-controller.js */
angular.module('webApp').controller('AuditTrailCtrl', function ($scope, $q, $state, Backend, AnalyticsService,
    CsvService, UserService, AuditTrailService) {

    // This is to avoid double data fetching (because filling the data table with content triggers the sort listener which fetches data again)
    // TODO: Find a more elegant way than this
    $scope.firstSort = true;
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                INITIALIZATION ACCORDING TO FROM WHENCE WE CAME
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    var fromAdminPanel = $state.$current.includes['dashboard.accountpage'] === true;
    // In $scope for breadcrumbs
    $scope.accountId = $state.params.accountId;
    $scope.endpointUrl = fromAdminPanel
        ? [ '__admin__/account/', $scope.accountId, '/audit-trail' ].join('')
        : '/account/audit-trail';

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                                  FILTERS
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // ~~~~~~~~~~~~~ USER FILTER ~~~~~~~~~~~~~~~~
    $scope.userFilter = {};
    $scope.userFilter.options = [];
    $scope.userFilter.changeCallback = function (value) {
        $scope.setDataParams({userFilter: value, filtering: true, newSearch: true, from: 0});
    };

    // ~~~~~~~~~~~~~ ACTION FILTER ~~~~~~~~~~~~~~~~
    $scope.actionFilter = {};
    $scope.actionFilter.options = [];
    $scope.actionFilter.changeCallback = function (value) {
        $scope.setDataParams({actionFilter: value, filtering: true, newSearch: true, from: 0});
    };

    // ~~~~~~~~~~~~~ COLUMNS FILTER ~~~~~~~~~~~~~~~~
    $scope.columnsFilter = {};
    $scope.columnsFilter.options = {};

    // Redirect the value to the relevant column in the data-table
    $scope.columnsChangeListener = function(id, item) {
        $scope.auditDataTable.headers[id].show = item.value;
    };

    // Create a dictionary of columns { <ID>: { label: ~, value: ~}}
    // We create this and the data-table headers like that so they could communicate on change of the checkbox menu
    for (var key in AuditTrailService.DATA_TABLE_COLUMNS) {
        if (!AuditTrailService.DATA_TABLE_COLUMNS.hasOwnProperty(key)) { return; }

        var filterColumn = AuditTrailService.DATA_TABLE_COLUMNS[key];

        $scope.columnsFilter.options[filterColumn.ID]= {
            label: filterColumn.NAME,
            value: filterColumn.DEFAULT_SHOW,
        };
    }

    $scope.sortListener = function (fieldTitle, descending) {
        if ($scope.firstSort) {
            $scope.firstSort = false;
            return;
        }

        $scope.setDataParams({
            from: 0,
            sort: !!descending,
            newSearch: true
        });
    };

    // ~~~~~~~~~~~~~ DATE RANGE FILTER ~~~~~~~~~~~~~~~~

    $scope.dateRange = {};
    // Since the directive does not support initial value, we pass it as a string in its ng-model
    $scope.dateRange.initialValue = {
        startDate: moment().subtract(90, 'days').format('MMM DD YYYY'),
        startDateAsMoment: moment().subtract(90, 'days'),
        endDate: moment().format('MMM DD YYYY'),
        endDateAsMoment: moment()
    };

    $scope.dateRange.dateRangeListener = function (range) {

        // Always take the day's end of the endDate (so 4-5 will show both 4th and 5th and not just what's in-between)
        range.endDateAsMoment = range.endDateAsMoment.endOf('day');

        $scope.setDataParams({
            from: 0,
            fromDate: range.startDateAsMoment.valueOf(),
            toDate: range.endDateAsMoment.valueOf(),
            filtering: true,
            newSearch: true
        });
    };

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                                  DATA-TABLE
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    $scope.auditDataTable = {};
    $scope.auditDataTable.content = [];
    $scope.auditDataTable.pageSize = AuditTrailService.PAGE_SIZE;
    $scope.auditDataTable.totalNumOfResults = 0;

    $scope.auditDataTable.headers = {};

    $scope.auditDataTable.paginateContent = function (firstIndex) {
        $scope.setDataParams({from: firstIndex - 1});
    };

    // Create a dictionary of columns { <ID>: { title: ~, show: ~}}
    for (key in AuditTrailService.DATA_TABLE_COLUMNS) {
        if (!AuditTrailService.DATA_TABLE_COLUMNS.hasOwnProperty(key)) { return; }

        var dataTableColumn = AuditTrailService.DATA_TABLE_COLUMNS[key];

        $scope.auditDataTable.headers[dataTableColumn.ID]= {
            title: dataTableColumn.NAME,
            show: dataTableColumn.DEFAULT_SHOW,
            sortable: dataTableColumn.SORTABLE,
            sortFieldName: dataTableColumn.SORT_FIELD_NAME,
            sorted: dataTableColumn.SORTED,
            field: dataTableColumn.FIELD,
            decorate: dataTableColumn.DECORATE,
            width: dataTableColumn.WIDTH,
            grow_ratio: dataTableColumn.GROW_RATIO
        };
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                        CONTENT FETCHING RELATED
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


    var default_date_params = AuditTrailService.default_date_params();

    var DEFAULT_GET_DATA_PARAMS = {
        FROM: AuditTrailService.FROM_INDEX,
        SIZE: AuditTrailService.PAGE_SIZE,
        FROM_DATE: default_date_params.fromDate,
        TO_DATE: default_date_params.toDate,
        SORT: true,
        FILTERING: true
    };

    $scope._createDataParams = function(filteringObject) {
        return {
            from: !_.isNil(filteringObject.from) ? filteringObject.from : _.get($scope._dataParams, 'from', null),
            size: !_.isNil(filteringObject.size) ? filteringObject.size : _.get($scope._dataParams, 'size', null),
            fromDate: !_.isNil(filteringObject.fromDate) ? filteringObject.fromDate : _.get($scope._dataParams, 'fromDate', null),
            toDate: !_.isNil(filteringObject.toDate) ? filteringObject.toDate : _.get($scope._dataParams, 'toDate', null),
            sortDescending: !_.isNil(filteringObject.sort) ? filteringObject.sort : _.get($scope._dataParams, 'sortDescending', null),
            includeFiltersData: !_.isNil(filteringObject.filtering) ? filteringObject.filtering : false,
            auditEventType: filteringObject.actionFilter !== undefined ? filteringObject.actionFilter : _.get($scope._dataParams, 'auditEventType', null),
            auditEventUser: filteringObject.userFilter !== undefined ? filteringObject.userFilter : _.get($scope._dataParams, 'auditEventUser', null),
        };
    };

    $scope.setDataParams = function (filterObject) {
        $scope._dataParams = $scope._createDataParams(filterObject);

        // For every change we fetch the new filtered data
        return $scope.getData(filterObject.filtering, !_.isNil(filterObject.newSearch));
    };

    // TODO: Make this a general utility function in app-select
    $scope._convertActionToAppSelectOption = function (obj) {
        return {
            text: obj['auditEventTypeTitle'],
            value: obj['auditEventType']
        };
    };

    $scope._convertUserToAppSelectOption = function (obj) {
        var convertedObject = {
            text: _.get(obj, 'fullName', null),
            value: obj
        };

        if (_.get(obj, 'userToken', false)) {
            convertedObject.prefix = 'Token';
        }

        return convertedObject;
    };

    /**
     * @param filtering - Whether the fetching is a fresh fetch so we'll init the content (e.g - filtering)
     * @param newSearch - Whether the fetching is by sorting
     */
    $scope.getData = function(filtering, newSearch) {
        $scope.auditDataTable.loadingResults = true;
        return Backend.POST($scope.endpointUrl, $scope._dataParams).then(function (res) {
            $scope.auditDataTable.totalNumOfResults = res.data.total;
            $scope.auditDataTable.content = res.data.results;
            $scope.auditDataTable.loadingResults = false;

            if (filtering) {
                $scope.userFilter.options = _.map(res.data.auditEventUsersList, $scope._convertUserToAppSelectOption);
                $scope.actionFilter.options =  _.map(res.data.auditEventTypesList, $scope._convertActionToAppSelectOption);
            }

            if (newSearch) {
                $scope.auditDataTable.pageNumber = 1;
            }
        });
    };

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                                EXPORT TO CSV
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    $scope.exportAudit2Csv = function () {
        var headers = [ 'User ID', 'User Name', 'Date & Time', 'Action', 'Extra Data', 'IP', 'Geo Location'];
        var fields = [ 'auditEventUser.id', 'auditEventUser.fullName', 'date', 'auditEventTypeTitle', 'extraDataList', 'ip', 'geoLocation' ];


        var params = $scope._createDataParams({
            from: DEFAULT_GET_DATA_PARAMS.FROM,
            size: $scope.auditDataTable.totalNumOfResults,
            fromDate: $scope._dataParams.fromDate,
            toDate: $scope._dataParams.toDate
        });

        return Backend.POST($scope.endpointUrl, params)
            .then(function (res) {
                var restructuredData = AuditTrailService.restructureAuditData(res.data.results);
                var options = {
                    headers: headers,
                    fields: fields
                };

                // Account name & id & date range
                var fileName = [ 'Audit ', $scope.summaryData.accountId, ' ', $scope.summaryData.accountName, ' ',
                    AuditTrailService.getDateAsString(params.fromDate, false), ' - ',
                    AuditTrailService.getDateAsString(params.toDate, false), '.csv' ].join('');
                CsvService.json2Csv(fileName, restructuredData, options);

                AnalyticsService.report('csv-download', {
                    category: 'audit-trail'
                });
            });
    };

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                                INITIALIZATION
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    $q.all({
        userSummary: UserService.getSummary(),
        auditData: $scope.setDataParams({
            from: DEFAULT_GET_DATA_PARAMS.FROM,
            size: DEFAULT_GET_DATA_PARAMS.SIZE,
            fromDate: DEFAULT_GET_DATA_PARAMS.FROM_DATE,
            toDate: DEFAULT_GET_DATA_PARAMS.TO_DATE,
            filtering: DEFAULT_GET_DATA_PARAMS.FILTERING,
            sort: DEFAULT_GET_DATA_PARAMS.SORT
        })
    }).then(function (res) {
        $scope.summaryData = res.userSummary.data;
    }).catch(function(error) {
        console.error(error);
    }).finally(function () {
        $scope.finishPageLoading = true;
    });
});
/* origin: public/webapp/app/dashboard/settings/audit-trail/audit-trail-service.js */
angular.module('webApp').service('AuditTrailService', function ($q, FeatureFlagService, AuthService, enums) {

    var self = this;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                      DEFAULTS
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    this.DEFAULT_DAYS_SPAN = 90;
    this.PAGE_SIZE = 15;
    this.FROM_INDEX = 0;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                  APP ROUTE RELATED
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // For route navigation
    this.userHasPermissionsToViewAudit = function () {
        return $q.all({
            auditEnabled: FeatureFlagService.isFeatureEnabled('audit'),
            userSession: AuthService.getUserSession()
        }).then(function (res) {
            return res.auditEnabled && res.userSession.role === enums.USER_ROLES.ADMIN;
        });
    };

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                  CSV EXPORT
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * Used for exportAudit2Csv. Render the data to be human-readable.
     * @param data - {json[]}
     * @private
     */
    this.restructureAuditData = function (data) {
        data.forEach(function (element, index) {
            _.set(data[index], 'auditEventUser.fullName', self.getUserNameString(_.get(data[index], 'auditEventUser')));
            _.set(data[index], 'date', self.getDateAsString(_.get(data[index], 'date')));
            _.set(data[index], 'extraDataList', self.getExtraDataString(_.get(data[index], 'extraDataList')));
        });

        return data;
    };

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                  DATA DECORATORS
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    this.get12hoursTime = function (date) {
        var hours = (date.getHours() + 11) % 12 + 1;
        // hours = hours < 10 ? '0' + hours : hours;
        var minutes = date.getMinutes() < 10 ? '0' + date.getMinutes() : date.getMinutes();
        var suffix = date.getHours() >= 12 ? 'PM' : 'AM';
        return hours + ':' + minutes + ' ' + suffix;
    };

    // For altering the fields in the data-table
    this.getUserNameString = function (data) {
        if (!data) { return ''; }

        var userToken = _.get(data, 'userToken');
        var userName = _.get(data, 'fullName');

        return userToken
            ? [ '(Token) ', userName ].join('')
            : userName;
    };

    this.getDateAsString = function (date) {
        if (!date) { return ''; }

        date = new Date(date);

        return [
            date.toISOString().split('T')[0],
            self.get12hoursTime(date)
        ].join(' ');
    };

    this.getExtraDataString = function (data) {
        if (!data) { return ''; }

        var extraDataList = [];
        data.forEach(function (extraData) {
            extraData = extraData['oldValue']
                ? [ extraData['fieldName'], ': [Old value: ', extraData['oldValue'], ' | New value: ', extraData['newValue'], ']'].join('')
                : [ extraData['fieldName'], ': [', extraData['newValue'], ']'].join('');

            extraDataList.push(extraData);
        });
        return extraDataList.join('; ');
    };

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                              DATA-RETRIEVAL PARAMS UTILITIES
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    this.default_date_params = function() {
        var currentTime = new Date();

        return {
            fromDate: new Date().setDate(currentTime.getDate() - this.DEFAULT_DAYS_SPAN),
            toDate: currentTime.getTime()
        };
    };

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                                  COLUMNS DEFINITIONS
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    this.DATA_TABLE_COLUMNS = {
        USER_ID: {
            NAME: 'User ID',
            ID: 1,
            DEFAULT_SHOW: true,
            FIELD: 'auditEventUser.id',
            WIDTH: '7%',
            GROW_RATIO: 1
        },
        USER_NAME: {
            NAME: 'User Name',
            ID: 2,
            DEFAULT_SHOW: true,
            // Pass the whole object so the decorator could see the 'userToke' field
            FIELD: 'auditEventUser',
            DECORATE: this.getUserNameString,
            WIDTH: '10%',
            GROW_RATIO: 2
        },
        DATE_AND_TIME: {
            NAME: 'Date & Time',
            ID: 3,
            DEFAULT_SHOW: true,
            SORTABLE: true,
            SORTED: true,
            FIELD: 'date',
            DECORATE: this.getDateAsString,
            WIDTH: '10%',
            GROW_RATIO: 2
        },
        IP: {
            NAME: 'IP',
            ID: 6,
            DEFAULT_SHOW: true,
            FIELD: 'ip',
            WIDTH: '10%',
            GROW_RATIO: 1
        },
        GEO_LOCATION: {
            NAME: 'Geo Location',
            ID: 7,
            DEFAULT_SHOW: true,
            FIELD: 'geoLocation',
            WIDTH: '10%',
            GROW_RATIO: 2
        },
        ACTION: {
            NAME: 'Action',
            ID: 4,
            DEFAULT_SHOW: true,
            FIELD: 'auditEventTypeTitle',
            WIDTH: '10%',
            GROW_RATIO: 2
        },
        EXTRA_DATA: {
            NAME: 'Extra Data',
            ID: 5,
            DEFAULT_SHOW: true,
            FIELD: 'extraDataList',
            DECORATE: this.getExtraDataString,
            WIDTH: '20%',
            GROW_RATIO: 3
        }
    };
});
/* origin: public/webapp/app/dashboard/settings/field-mapping/field-mapping-bottom-buttons/field-mapping-bottom-buttons.js */
angular.module('webApp').directive('fieldMappingBottomButtons', function () {
    return {
        restrict: 'E',
        scope: {
            isFieldChanged: '=',
            attemptsToApply: '=',
            applyFunc: '=',
            discardFunc: '=',
            isErrorTab: '=',
            attemptsTemplate: '='
        },
        templateUrl: 'app/dashboard/settings/field-mapping/field-mapping-bottom-buttons/field-mapping-bottom-buttons.html'
    };
});
/* origin: public/webapp/app/dashboard/settings/field-mapping/field-mapping-logs-table-row/field-mapping-logs-table-row-controller.js */
angular.module('webApp').controller('FieldMappingLogsTableRowController', function ($scope, Focus, ngDialog, Backend, cacheService, MappingsService, $rootScope, AnalyticsService) {

    $scope.availableFieldTypes = [
        {val: 'automatic', name: 'Automatic'},
        {val: 'boolean', name: 'Boolean'},
        {val: 'date', name: 'Date (timestamp)'},
        {val: 'double', name: 'Double'},
        {val: 'geoip', name: 'GeoIp Enrichment'},
        {val: 'ip', name: 'IP'},
        {val: 'keyword', name: 'Keyword (String)'},
        {val: 'long', name: 'Long'}
    ];
    $scope.availableFieldTypesExtra = [
        {val: 'byte', name: 'Byte'},
        {val: 'geo_point', name: 'Geo Point'},
        {val: 'float', name: 'Float'},
        {val: 'integer', name: 'Integer'},
        {val: 'text', name: 'Text (Analysed Field)'},
        {val: 'short', name: 'Short'}
    ];

    $scope.isRowEdited = false;

    $scope.fieldTypeDisabledTemplate = 'app/dashboard/settings/field-mapping/wizard-mapping-templates/field-type-disabled.html';
    $scope.fieldRenameDisabledTemplate = 'app/dashboard/settings/field-mapping/wizard-mapping-templates/field-rename-disabled.html';

    var analyticsReport = function (eventName, eventData) {
        eventData = eventData || {};
        eventData = _.assign(eventData, {
            category: 'fields-mapping', fieldMapping: $scope.data.fieldType.val,
            fieldName: $scope.data.fieldName.val,
            fieldRename: $scope.data.fieldRename.val,
            logType: $scope.data.logType.val,
            mappingErrorsTab: $scope.isMappingErrors
        });
        eventName = ['fields-mapping', eventName].join(':');
        AnalyticsService.report(eventName, eventData);
    };

    var updateDisableFieldsStatus = function () {
        if ($scope.data.otherlogTypes) {
            $scope.data.disableRename = false;
            $scope.data.disableSelect = true;
        }
        else {
            $scope.isMappingErrors ? $scope.data.disableRename = false : $scope.data.disableRename = true;//rename should be always enabled for errors mapping tab
            $scope.data.disableSelect = false;
        }
    };
    updateDisableFieldsStatus();

    $scope.editAccountNameMode = false;

    $scope.isUsed = false;

    $scope.OrigFieldRename = $scope.prevFieldRename = $scope.data.fieldRename.val;
    $scope.OrigFieldType = $scope.prevFieldType = $scope.data.fieldType.val;

    $scope.enableEdit = function () {
        $scope.data.disableSelect = false;
    };

    var getEffectiveName = function () {
        return $scope.data.fieldRename.val || $scope.data.fieldName.val;
    };

    $scope.removeErrorMapping = function () {
        if ($scope.isResolved) {
            $scope.isResolved = false;
            $scope.data.resolved = false;
            $scope.isRowChanged.count--;
        }
        else {
            $scope.isResolved = true;
            $scope.data.resolved = true;
            $scope.isRowChanged.count++;
        }
    };

    $scope.setEditMode = function () {
        $scope.prevAlias = $scope.data.fieldRename.val;

        $scope.isRenameActive ? $scope.isRenameActive = false : $scope.isRenameActive = true;

        $scope.editAccountNameMode = true;
        Focus('edit-main-account-name-input');

    };

    $scope.exitEditMode = function (isRenameField) {
        $scope.editAccountNameMode = false;
        $scope.data.fieldType.val = $scope.data.fieldType.val ? $scope.data.fieldType.val.trim() : '';

        //check if row was changed
        if (($scope.OrigFieldRename === $scope.data.fieldRename.val) && ($scope.OrigFieldType === $scope.data.fieldType.val)) {
            if ($scope.isRowEdited) {
                $scope.isRowChanged.count--;
            }
            $scope.isRowEdited = false;
        }
        else {
            if (!$scope.isRowEdited) {
                $scope.isRowChanged.count++;
            }
            $scope.isRowEdited = true;
        }

        //adjust UI to mapping changes on the fly
        if ($scope.prevFieldType !== $scope.data.fieldType.val) {

            $scope.changeLogTypesMappingFunc(getEffectiveName(), $scope.data.fieldType.val, false);
            $scope.prevFieldType = $scope.data.fieldType.val;

            analyticsReport('field-type-change');
        }

        if (isRenameField) {

            $scope.isRenameActive ? $scope.isRenameActive = false : $scope.isRenameActive = true;

            $scope.enableMappingFunc($scope.prevAlias);//clear all mapping disable restrictions

            if ($scope.data.fieldRename.val !== '') {

                if (!$scope.isFieldNameUsedInUIFunc($scope.data.fieldRename.val, $scope.data.fieldName.val)) {

                    var effectiveFieldNameData = $scope.getEffectiveNameMappingInUIFunc($scope.data.fieldRename.val);

                    if (effectiveFieldNameData.length === 0) {
                        searchFieldInServer();
                    }
                    else {
                        UpdateMappingDisabledOfThisAndOtherRows(effectiveFieldNameData[0].fieldType.val);
                    }
                }
                else {
                    $scope.isUsed = true;
                }

                analyticsReport('rename-field');
            }
        }
    };

    var searchFieldInServer = function () {
        Backend.GET(['/mappings/field/', $scope.data.fieldRename.val].join('')).then(function (res) {

            //if field doesn't exist -> rename enabled
            if (res.data.length === 0) {
                $scope.data.fieldType.val = 'Automatic';
            }
            else {
                //if field exist but no rename -> rename enabled
                if (res.data[0].fieldRename === '' && res.data[0].fieldType !== '') {
                    var fieldTypeVal =_.find($scope.availableFieldTypes, {val: res.data[0].fieldType});
                    UpdateMappingDisabledOfThisAndOtherRows(fieldTypeVal.name);
                }
                //if field exist but + rename -> rename disabled
                else if (res.data[0].fieldRename !== '') {
                    $scope.isUsed = true;
                }
                else {
                    $scope.data.fieldType.val = 'Automatic';
                }
            }

        }).catch(function (err) {
            console.error('error getting log lines:', err);
        });
    };

    var UpdateMappingDisabledOfThisAndOtherRows = function (fieldType) {
        $scope.data.fieldType.val = $scope.prevFieldType = fieldType;
        $scope.data.disableSelect = true;
        $scope.data.disableRename = false;

        $scope.changeLogTypesMappingFunc($scope.data.fieldRename.val, $scope.data.fieldType.val, true); //disable mapping for all the rows with that field name
    };

    $scope.viewVisualizations = function () {
        MappingsService.getAllVisualizationsWithDashboardsByFieldName($scope.data['fieldName']['val']).then(function (data) {

            var mappingsRowScope = $rootScope.$new();
            mappingsRowScope.data = data;

            ngDialog.open({
                template: 'app/dashboard/settings/field-mapping/wizard-mapping-templates/mappings-visualizations/mappings-visualization.html',
                width: '624px',
                closeByEscape: false,
                closeByDocument: false,
                showClose: false,
                scope: mappingsRowScope
            });
        });

        analyticsReport('view-visualizations');
    };

    $scope.openAliasIsUsedDialog = function () {
        ngDialog.open({
            template: 'app/dashboard/settings/field-mapping/wizard-mapping-templates/mappings-dialogs/alias-is-in-use-dialog.html',
            controller: 'MappingDialogsController',
            width: '624px',
            closeByEscape: false,
            closeByDocument: false,
            showClose: false
        });
    };

    $scope.$on('ngDialog.closing', function () {
        if ($scope.isUsed) {
            $scope.setEditMode();
            $scope.isUsed = false;
        }
    });

    $scope.$watch('isUsed', function () {
        !$scope.isUsed || $scope.openAliasIsUsedDialog();
    }, true);

});
/* origin: public/webapp/app/dashboard/settings/field-mapping/field-mapping-logs-table-row/field-mapping-logs-table-row.js */
angular.module('webApp').directive('fieldMappingLogsTableRow', function () {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/settings/field-mapping/field-mapping-logs-table-row/field-mapping-logs-table-row.html',
        controller: 'FieldMappingLogsTableRowController',
        scope: {
            data: '=',
            fieldsNames: '=',
            isMappingErrors : '=',
            isRowChanged : '=',
            isFieldNameUsedInUIFunc: '=',
            getEffectiveNameMappingInUIFunc: '=',
            changeLogTypesMappingFunc: '=',
            enableMappingFunc: '='
        }
    };
});
/* origin: public/webapp/app/dashboard/settings/field-mapping/field-mapping-logs-table/field-mapping-logs-table-controller.js */
angular.module('webApp').controller('FieldMappingLogsTableController', function ($scope, $timeout) {

    var dataSize = 500;
    var fromPage = 0;

    var storeOriginalData = function () {
        $scope.OriginalData = _.cloneDeep($scope.data);

        $scope.OriginalData.forEach(function (element) {
            element.getEffectiveName = function () {
                return element.fieldRename.val || element.fieldName.val;
            };
        });
    };
    storeOriginalData();

    $scope.enableMappingIfNotMultiLogTypes = function (prevAlias) {

        var aliasMap = _.countBy($scope.data, function (item) {
            return item.fieldRename.val || item.fieldName.val;
        });

        $scope.data.forEach(function (element) {

            var fieldAppearsOnceInUI = aliasMap[element.fieldName.val] === 1;
            var fieldAppearsOnceInServer = !element.otherlogTypes;
            if (element.fieldName.val === prevAlias && fieldAppearsOnceInServer && fieldAppearsOnceInUI) {
                element.disableRename = true;
                element.disableSelect = false;
            }
        });
    };

    $scope.isRowChanged = {count: 0};

    var initiatePegenation = function(){
        $scope.paginationData = {
            from: 1,
            to: 20,
        };
    };
    initiatePegenation();

    $scope.prevPage = function () {
        if ($scope.isTableChanged > 0) {
            $scope.dialogOpenFunction($scope.isMappingErrors, $scope.isRowChanged.count);
            return;
        }
        if ($scope.paginationData.from - 1 < 1) return;

        $scope.paginationData.from = Math.max($scope.paginationData.from - 20, 1);
        $scope.paginationData.to = $scope.paginationData.from + 19;

        renderPagination();
    };

    $scope.nextPage = function () {
        if ($scope.isTableChanged > 0) {
            $scope.dialogOpenFunction($scope.isMappingErrors);
            return;
        }

        if(($scope.paginationData.to + 20) >= $scope.data.length && $scope.data.length !== $scope.totalDataNum){//get more data from server
            fromPage += dataSize;
            $scope.getMappingsData(fromPage, dataSize, true);
        }

        if ($scope.paginationData.to + 1 > $scope.data.length) return;

        $scope.paginationData.from += 20;
        $scope.paginationData.to = Math.min($scope.paginationData.from + 19, $scope.data.length);

        renderPagination();
    };

    var renderPaginationTimer;
    var renderPagination = function () {

        if ($scope.renderingPagination) {
            $timeout.cancel(renderPaginationTimer);
        }

        $scope.renderingPagination = true;
        renderPaginationTimer = $timeout(function () {
            $scope.renderingPagination = false;
        }, 400);// For the fade out - fade in animation
    };

    $scope.isFieldNameUsed = function (alias, fieldName) {

        var res = false;

        $scope.data.forEach(function (element) {
            var renameChainCase1 = (element.fieldName.val === alias && element.fieldRename.val !== '');
            var renameChainCase2 = element.fieldRename.val === fieldName;
            if (renameChainCase1 || renameChainCase2) {
                res = true;
            }
        });
        return res;
    };

    $scope.changeLogTypesMappingByFieldName = function (fieldName, fieldType, shouldDisable) {

        $scope.OriginalData.forEach(function (element, index) {
            if (element.getEffectiveName() === fieldName) {

                if (shouldDisable) { // disable other log types with the same field name
                    $scope.data[index].disableRename = false;
                    $scope.data[index].disableSelect = true;
                }
                else {
                    $scope.data[index].fieldType.val = fieldType;
                }
            }
        });
        storeOriginalData();
    };

    $scope.getEffectiveNameDataByFieldName = function (fieldName) {

        return _.filter($scope.OriginalData, function (element) {
            return element.getEffectiveName() === fieldName;
        });
    };

    $scope.$watch('data', function () {
        initiatePegenation();
        renderPagination();
    });

    //check if one of the rows was changed
    $scope.$watch('isRowChanged.count', function (newValue, oldValue) {
        newValue > oldValue ? $scope.isTableChanged++ : $scope.isTableChanged--;
    });
    $scope.isTableChanged++;//for the first digest loop of the watcher

    $scope.$on('$destroy', function () {
        if ($scope.renderingPagination) $timeout.cancel(renderPaginationTimer);
    });
});
/* origin: public/webapp/app/dashboard/settings/field-mapping/field-mapping-logs-table/field-mapping-logs-table.js */
angular.module('webApp').directive('fieldMappingLogsTable', function () {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/settings/field-mapping/field-mapping-logs-table/field-mapping-logs-table.html',
        controller: 'FieldMappingLogsTableController',
        scope: {
            data: '=',
            totalDataNum: '=',
            fieldsNames: '=',
            isMappingErrors: '=',
            isTableChanged : '=',
            searchText : '=',
            dialogOpenFunction: '=',
            getMappingsData: '='
        }
    };
});
/* origin: public/webapp/app/dashboard/settings/field-mapping/field-mapping-tab-explanation/field-mapping-tab-explanation.js */
angular.module('webApp').directive('fieldMappingTabExplanation', function () {
    return {
        restrict: 'E',
        scope: {
            data: '=',
        },
        templateUrl: 'app/dashboard/settings/field-mapping/field-mapping-tab-explanation/field-mapping-tab-explanation.html'
    };
});
/* origin: public/webapp/app/dashboard/settings/field-mapping/field-mapping.js */
angular.module('webApp').controller('FieldMappingSettingsController', function ($rootScope, $scope, Backend, ngDialog, ElasticSearchService, MappingsService, $stateParams, AnalyticsService) {

    var fromPage = 0;
    var dataSize = 500;
    $scope.errorsTabActive = false;
    $scope.placeholder = '';
    $scope.searchQuery = {query: $stateParams.q || ''};
    $scope.loadMappingsDataComplete = false;
    $scope.hadErrors = false;
    $scope.loadErrorsDataComplete = false;
    $scope.showNoDataMessage = false;
    $scope.isMappingFieldsChanged = {isChanged: 0};
    $scope.isErrorMappingFieldsChanged = {isChanged: 0};

    $scope.fieldsNames = [
        {val: 'logType', name: 'Log type'},
        {val: 'fieldName', name: 'Field name'},
        {val: 'fieldRename', name: 'Field alias'},
        {val: 'fieldType', name: 'Mapping'}];

    $scope.mappingsAttemptsTemplate = 'app/dashboard/settings/field-mapping/wizard-mapping-templates/mappings-attempts-alert.html';

    $scope.searchText = ''; // Otherwise inited to undefined and then $filter returns an empty list

    $scope.enterTab = function (tab) {
        tab.tabTitle === 'Mapping errors' ? $scope.errorsTabActive = true : $scope.errorsTabActive = false;
    };

    var analyticsReport = function (eventName, eventData) {
        eventData = eventData || {};
        eventData = _.assign(eventData, {category: 'fields-mapping'});
        eventName = ['fields-mapping', eventName].join(':');
        AnalyticsService.report(eventName, eventData);
    };

    $scope.organizeUpdatedData = function (parsedDataDiff, parsedData) {

        var difference = MappingsService.diffBetweenInitialAndChangedData(parsedDataDiff, parsedData);
        if (difference.length === 0) return;

        return MappingsService.parseDataBeforeApply(difference);
    };

    $scope.applyMappedFields = function () {

        $scope.loadMappingsDataComplete = false;
        var data = $scope.organizeUpdatedData($scope.parsedMappingDataToDiff['mappings'], $scope.parsedMappingData['mappings']);

        Backend.POST('/mappings', data).then(function (res) {

            $scope.openApplySuccessDialog(res.data.numberOfFieldUpdated);
            $scope.isMappingFieldsChanged.isChanged = 0;
            $scope.refreshMapping();

            $scope.searchQuery.query !== '' ? $scope.getSearchMappingsData() : $scope.getMappingsData(fromPage, dataSize, false);

            calculateNumOfAttemptsToApply(res);
            analyticsReport('apply-mappings', {mappingErrorsTab: false});

        }, function () {
            $scope.openApplyFailedDialog();
            $scope.loadMappingsDataComplete = true;
        });
    };

    $scope.applyFixedMappingErrors = function () {

        $scope.loadErrorsDataComplete = false;
        var data = $scope.organizeUpdatedData($scope.parsedErrorMappingDataToDiff['mappings'], $scope.parsedErrorMappingData['mappings']);

        Backend.POST('/mappings/errors', data).then(function (res) {

            $scope.openApplySuccessDialog(res.data.numberOfFieldUpdated);
            $scope.isErrorMappingFieldsChanged.isChanged = 0;
            $scope.refreshMapping();
            $scope.getMappingsErrorsData();

            //update the mapping tab as well
            $scope.searchQuery.query !== '' ? $scope.getSearchMappingsData() : $scope.getMappingsData(fromPage, dataSize, false);

            calculateNumOfAttemptsToApply(res);
            analyticsReport('apply-mappings', {mappingErrorsTab: true});

        }, function () {
            $scope.openApplyFailedDialog();
            $scope.loadErrorsDataComplete = true;
        });
    };

    $scope.discardMappedFields = function () {
        MappingsService.discardMappedFields($scope.parsedMappingDataToDiff, $scope.parsedMappingData);
        MappingsService.discardMappedFields($scope.parsedErrorMappingDataToDiff, $scope.parsedErrorMappingData);
        $scope.isMappingFieldsChanged.isChanged = 0;
        $scope.isErrorMappingFieldsChanged.isChanged = 0;
    };

    $scope.openApplyDialog = function (isErrorFixes) {

        var editMappingScope = $rootScope.$new();
        editMappingScope.discardMappedFields = $scope.discardMappedFields;
        if (isErrorFixes) {
            editMappingScope.applyMappedFields = $scope.applyFixedMappingErrors;
        }
        else {
            editMappingScope.applyMappedFields = $scope.applyMappedFields;
        }

        ngDialog.open({
            template: 'app/dashboard/settings/field-mapping/wizard-mapping-templates/mappings-dialogs/mappings-on-apply-dialog.html',
            controller: 'MappingDialogsController',
            width: '624px',
            closeByEscape: false,
            closeByDocument: false,
            showClose: false,
            scope: editMappingScope
        });
    };

    $scope.openApplyFailedDialog = function () {

        ngDialog.open({
            template: 'app/dashboard/settings/field-mapping/wizard-mapping-templates/mappings-dialogs/mappings-on-apply-failed-dialog.html',
            controller: 'MappingDialogsController',
            width: '624px',
            closeByEscape: false,
            closeByDocument: false,
            showClose: false
        });
    };

    $scope.openApplySuccessDialog = function (numOfUpdatedFields) {

        var editMappingScope = $rootScope.$new();
        editMappingScope.numOfUpdatedFields = numOfUpdatedFields;

        ngDialog.open({
            template: 'app/dashboard/settings/field-mapping/wizard-mapping-templates/mappings-dialogs/mappings-on-apply-success-dialog.html',
            controller: 'MappingDialogsController',
            width: '624px',
            closeByEscape: false,
            closeByDocument: false,
            showClose: false,
            scope: editMappingScope
        });
    };

    $scope.openWindowExitDialog = function (isErrorFixes) {

        var editMappingScope = $rootScope.$new();
        editMappingScope.discardMappedFields = $scope.discardMappedFields;
        if (isErrorFixes) {
            editMappingScope.applyMappedFields = $scope.applyFixedMappingErrors;
        }
        else {
            editMappingScope.applyMappedFields = $scope.applyMappedFields;
        }

        ngDialog.open({
            template: 'app/dashboard/settings/field-mapping/wizard-mapping-templates/mappings-dialogs/mappings-on-window-exit-dialog.html',
            controller: 'MappingDialogsController',
            width: '624px',
            closeByEscape: false,
            closeByDocument: false,
            showClose: false,
            scope: editMappingScope
        });
    };

    $scope.refreshingMapping = false;
    $scope.refreshMapping = function () {
        if ($scope.refreshingMapping) return;
        $scope.refreshingMapping = true;

        ElasticSearchService.refreshMapping('fields-mapping', 'settings').finally(function () {
            $scope.refreshingMapping = false;
        });
    };

    $scope.clearSearch = function () {
        $scope.searchQuery.query = '';
        $scope.search();
    };

    $scope.search = function () {
        if ($scope.isMappingFieldsChanged.isChanged && $scope.attemptsToApply.numOfAttemptsLeft) {
            $scope.openApplyDialog();
            return;
        }
        $scope.searchQuery.query !== '' ? $scope.getSearchMappingsData() : $scope.getMappingsData(fromPage, dataSize, false);
    };

    $scope.$on('$stateChangeStart', function (event) {
        if ($scope.attemptsToApply.numOfAttemptsLeft) {
            if ($scope.parsedMappingDataToDiff) {
                if (MappingsService.diffBetweenInitialAndChangedData($scope.parsedMappingDataToDiff['mappings'], $scope.parsedMappingData['mappings']).length !== 0) {
                    $scope.openWindowExitDialog(false);
                    event.preventDefault();
                }
            }
            if ($scope.parsedErrorMappingDataToDiff) {
                if (MappingsService.diffBetweenInitialAndChangedData($scope.parsedErrorMappingDataToDiff['mappings'], $scope.parsedErrorMappingData['mappings']).length !== 0) {
                    $scope.openWindowExitDialog(true);
                    event.preventDefault();
                }
            }
        }
    });

    var fetchAndParseData = function (isPaging, res) {
        $scope.loadMappingsDataComplete = true;

        if (_.isEmpty(res)) {
            $scope.parsedMappingData = {'mappings': []};
            if (_.isEmpty($scope.mapping_res)) {
                $scope.showNoDataMessage = true;
            }
            return;
        }

        $scope.showNoDataMessage = false;
        //for pagination
        if ($scope.prevMappingRes && isPaging) {
            $scope.mapping_res = _.concat($scope.prevMappingRes, res);
        }
        else {
            $scope.mapping_res = res;
        }
        $scope.prevMappingRes = res;

        $scope.parsedMappingData = {'mappings': []};
        $scope.parsedMappingDataToDiff = {'mappings': []};
        MappingsService.parseData($scope.mapping_res, $scope.parsedMappingDataToDiff, $scope.parsedMappingData);
    };

    var calculateNumOfAttemptsToApply = function (res) {

        $scope.attemptsToApply = {};
        $scope.attemptsToApply.numOfAttempts = res.data.numOfUpdatesDoneToday;
        $scope.attemptsToApply.attemptsLimit = res.data.numOfUpdatesAllowedPerDay;
        $scope.attemptsToApply.numOfAttemptsLeft = $scope.attemptsToApply.attemptsLimit - $scope.attemptsToApply.numOfAttempts;
    };

    $scope.getMappingsData = function (fromPage, dataSize, isPaging) {
        $scope.searchQuery.query = '';

        Backend.GET(['/mappings?from=', fromPage, '&size=', dataSize].join('')).then(function (res) {
            fetchAndParseData(isPaging, res.data.results);
            $scope.parsedMappingData['totalDataNum'] = res.data.total;
            calculateNumOfAttemptsToApply(res);

        }, function (error) {
            console.log(error);
        });
    };

    $scope.getMappingsErrorsData = function () {
        Backend.GET('/mappings/errors').then(function (res) {
            $scope.loadErrorsDataComplete = true;

            if (_.isEmpty(res.data)) {
                $scope.hadErrors = false;
                $scope.mapping_res_errors = {'mappings': []};
                $scope.errorsTabActive = false;
                return;
            }

            $scope.hadErrors = true;
            $scope.mapping_res_errors = res.data;
            $scope.parsedErrorMappingData = {'mappings': []};
            $scope.parsedErrorMappingDataToDiff = {'mappings': []};
            MappingsService.parseData($scope.mapping_res_errors, $scope.parsedErrorMappingDataToDiff, $scope.parsedErrorMappingData);
            $scope.parsedErrorMappingData['totalDataNum'] = res.data.length;
        });
    };

    $scope.getSearchMappingsData = function () {
        Backend.GET(['/mappings/search/', $scope.searchQuery.query].join('')).then(function (res) {
            fetchAndParseData(false, res.data);
            $scope.parsedMappingData['totalDataNum'] = res.data.length;

        }, function (error) {
            console.log(error);
        });
    };

    $scope.getMappingsData(fromPage, dataSize, false);
    $scope.getMappingsErrorsData();
});
/* origin: public/webapp/app/dashboard/settings/field-mapping/wizard-mapping-templates/mappings-dialogs/mapping-dialogs-controller.js */
angular.module('webApp').controller('MappingDialogsController', function ($scope) {

    $scope.discardMappedFieldsInDialog = function(){
        $scope.closeThisDialog();
        $scope.discardMappedFields();
    };

    $scope.openApplyDialogInDialog = function(){
        $scope.closeThisDialog();
        $scope.applyMappedFields();
    };
});
/* origin: public/webapp/app/dashboard/settings/general/general.js */
angular.module('webApp').controller('GeneralSettingsController', function ($q, $rootScope, $scope, Backend,
    AuthService, UserService, CsvService, FeatureFlagService, ElasticSearchService, AnalyticsService, AuditTrailService,
    enums) {

    $q.all({
        // userSummary: UserService.getSummary(), // Why? read my comment below
        userSettings: UserService.getUserSettings(),
        userSession: AuthService.getUserSession(),
        auditEnabled: AuditTrailService.userHasPermissionsToViewAudit(),
        supportAccessEnd: getSupportAccessEnd()
    }).then(function (res) {
        // $scope.summaryData = res.userSummary.data; // Why? read my comment below
        initThemeToggleData(res.userSettings.kibanaTheme);
        $scope.isAccountAdmin = res.userSession.role === enums.USER_ROLES.ADMIN;
        $scope.auditEnabled = res.auditEnabled;
        $scope.supportAccessEnd = res.supportAccessEnd;
    }).then(UserService.getSummary).then(function (res) {
        // This is really weird, I hate this, for some reason when we pull user summary data using $q.all() using Backend.GET
        // (when no cache is available and this is the first call, for example after login or switch account) it returns the data
        // without accountToken property, IDK WHY! and if you leave the page and reenter (refresh or navigate) it returns the summary data
        // fine with accountToken. SPOOKY ACTION! if you look at cache you can see accountToken is there, no way to explain this but
        // $q.all() is a sorceress.
        $scope.summaryData = res.data;
    }).finally(function () {
        $scope.finishLoading = true;
    });

    $scope.passwordEditing = { value: false };
    $scope.supportAccessEditing = { value: false };

    function initThemeToggleData(value) {
        $scope.themeToggleData = {
            leftOption: {
                label: 'Dark',
                value: 1
            },
            rightOption: {
                label: 'Light',
                value: 0
            },
            value: value
        };
    }

    var userSettingsReload = function () {
        UserService.cleanUserSettings();
        UserService.getUserSettings();
    };

    $scope.themeUpdateCallback = function (value) {
        UserService.getUserSettings().then(function (userSettings) {
            userSettings.kibanaTheme = value;
            Backend.POST('/user-settings', userSettings).then(userSettingsReload);
        });
    };

    function getSupportAccessEnd() {
        return AuthService.getUserSession().then(function (res) {
            if (res.role !== enums.USER_ROLES.ADMIN) {
                return; // Must be an account admin
            }

            return Backend.GET('/support-access').then(function (res) {
                return _.get(res, 'data.endApprovalDate');
            });
        });
    }

    $scope.refreshMapping = function() {
        if ($scope.refreshingMapping) return;
        $scope.refreshingMapping = true;

        ElasticSearchService.refreshMapping('general', 'settings').finally(function() {
            $scope.refreshingMapping = false;
        });
    };
});

/* origin: public/webapp/app/dashboard/settings/manage-accounts_/accounts-card/accounts-card-component.js */
angular.module('webApp').component('manageAccountsAccountsCard', {
    controller: 'ManageAccountsAccountsCardCtrl',
    controllerAs: 'vm',
    templateUrl: 'app/dashboard/settings/manage-accounts_/accounts-card/accounts-card.html'

});
/* origin: public/webapp/app/dashboard/settings/manage-accounts_/accounts-card/accounts-card-controller.js */
angular.module('webApp').controller('ManageAccountsAccountsCardCtrl', function (UserService, UpgradeService, $state,
                                                                                AccountService, SubAccountsService, sharedObjects, Account, $rootScope, $timeout, LogzToast) {
    var self = this;

    self.selectedAccount;

    self.ERR_ZERO_MANAGED_ACCOUNTS = 'Account has zero managed accounts';
    self.ERR_FAIL_FETCH_SUB_ACCOUNTS = 'COULD_NOT_GET_SUB_ACCOUNTS';

    /*********************************************************************************************************
     *                                          HIGH-CHARTS GRAPHS                                            *
     *********************************************************************************************************/
    self.createAccountsPieChart = function () {
        self.accountsPieChart = Highcharts.chart('accounts-pie-chart-container', {
            chart: {
                plotShadow: false,
                type: 'pie'
            },
            credits: false,
            title: false,
            tooltip: {
                useHTML: true,
                headerFormat: '',
                pointFormat: '<span class="graph-bullet" style="background-color:{point.color}"></span> {point.name} <br />&nbsp;&nbsp;&nbsp;{point.y} GB <br />',
            },
            plotOptions: {
                pie: {
                    allowPointSelect: true,
                    cursor: 'pointer',
                    borderWidth: 0,
                    dataLabels: false,
                    colorByPoint: true,
                    size: 200
                }
            },
            series: [{
                dashStyle: 'LongDash',
                data: self.getDataForAccountsPieChart()
            }]
        });
    };

    /*********************************************************************************************************
     *                                              FUNCTIONS                                                *
     *********************************************************************************************************/

    self.getDataForAccountsPieChart = function () {
        return self.accountsList.map(function (account) {
            return {
                // ID is for distinguishing
                id: account.id,
                name: account.name,
                color: account.color,
                y: account.volumeGB,
                events: {
                    select: function (event) {
                        self.toggleSelectedAccount(self.accountsList[event.target.index]);
                    },
                    unselect: function (event) {
                        self.clearSelectedAccount(event.target.index);
                    }
                },
                selected: self.selectedAccount && (account.id === self.selectedAccount.id)
            };
        });
    };

    self.createdAccount = function (account) {
        self.emitAccountChanges(account);
        self.refreshData(account);
    };

    self.updatedAccount = function (account) {
        self.emitAccountChanges(account);
        self.refreshData(account);
    };

    self.deletedAccount = function (deletedAccount) {
        self.refreshData(deletedAccount);
        self.cancelAccountSelection();
    };

    /***
     * Update the current logged-in account
     * TODO: Legacy code - Eww.. Make a service for these kind of things
     */
    self.emitAccountChanges = function (account) {
        if (account.getIsMain()) {
            $rootScope.$emit('Account.updatedName', self.account.name);
        }
        else {
            $rootScope.$emit('SubAccounts.updated');
        }
    };

    /***
     * Refresh the accounts list & pie chart (after an external change)
     */
    self.refreshData = function (account) {
        self.account = account.getMain();

        self.selectedAccount = account;
        self.accountsList = self.selectedAccount.getFlatAccountList();

        // Update data in pie chart
        self.accountsPieChart.series[0].setData(self.getDataForAccountsPieChart());
    };

    self.clickOnAccount = function (index) {
        self.accountsPieChart.series[0].data[index].select();
    };

    self.toggleSelectedAccount = function (account) {
        self.selectedAccount = (self.selectedAccount === account) ? null : account;
    };

    self.clearSelectedAccount = function (index) {
        if (self.selectedAccount.id === self.accountsList[index].id) {
            self.selectedAccount = null;
        }
    };


    self.handleErrors = function (err) {
        if (err === self.ERR_ZERO_MANAGED_ACCOUNTS) {
            LogzToast.error(err, false);
            return $state.go('dashboard.kibana');
        }
        else if (err === self.ERR_FAIL_FETCH_SUB_ACCOUNTS) {
            LogzToast.error('Could not retrieve sub accounts', false);  // TODO: extract to a errorMessage to readable message obj
        }
        else {
            console.error(err);
        }
    };

    /***
     * Toggles the add new button UI able/disable states
     */
    self.isAddNewDisabled = function () {
        return self.accountsList.slice(1).length >= self.account.maxSubAccounts || self.account.volumeGB <= 0;
    };

    self.addNewAccount = function () {
        if (self.selectedAccount) {
            self.cancelAccountSelection();
        }
        self.selectedAccount = new Account({parent: self.account.getMain()});
    };

    /**
     * Programmatically clearSelectedAccount
     */
    self.cancelAccountSelection = function () {
        var selectedPieSlice = _.find(self.accountsPieChart.series[0].data, {'id': self.selectedAccount.id});
        if (selectedPieSlice) {
            selectedPieSlice.select();
        }
        self.selectedAccount = null;
    };

    /*********************************************************************************************************
     *                                      INITIALIZATION FUNCTION                                          *
     *********************************************************************************************************/

    self.$onInit = function () {
        self.isLoading = true;
        return Account.prototype.createAccountTree()
            .then(function (account) {
                self.account = account;
                self.accountsList = self.account.getFlatAccountList();
            })
            .then(function () {
                // We use $timeout to create the accounts pie chart
                // when the current digest cycle is ended, and the accountsList
                // is (should be) properly rendered
                $timeout(self.createAccountsPieChart, 0);
            })
            .catch(self.handleErrors)
            .finally(function () {
                self.isLoading = false;
            });
    };
});
/* origin: public/webapp/app/dashboard/settings/manage-accounts_/accounts-card/edit-account-section/edit-account-section-component.js */
angular.module('webApp').component('manageAccountsEditAccountSection', {
    controller: 'ManageAccountsEditAccountSectionCtrl',
    controllerAs: 'vm',
    templateUrl: 'app/dashboard/settings/manage-accounts_/accounts-card/edit-account-section/edit-account-section.html',
    bindings: {
        cancelEventHandler: '&',
        createEventHandler: '&',
        updateEventHandler: '&',
        deleteEventHandler: '&',
        selectedAccount: '<',
        accounts: '<'
    }
});
/* origin: public/webapp/app/dashboard/settings/manage-accounts_/accounts-card/edit-account-section/edit-account-section-controller.js */
angular.module('webApp').controller('ManageAccountsEditAccountSectionCtrl', function (LogzToast, $q, ConfirmService, AnalyticsService) {

    var self = this;

    self.setSharingObjectAccountsSuggestions = function (accounts) {
        self.accountsGroupForSelection = [{
            data: accounts.filter(function (account) {
                // Do not include the selected account in the suggestions
                return account.id !== self.account.id;
            }).map(function (account) {
                return {
                    data: account.id,
                    name: account.name
                };
            })
        }];
    };

    self.saveAccount = function () {
        if (!self.account.token) {
            return self.createSubAccount();
        }
        return self.updateAccount();
    };

    self.createSubAccount = function () {
        // ConfirmService.open() - TODO: use it, validate in here too
        self.account.sharingObjectsAccounts = _.map(self.account.sharingObjectsAccountsMultiSelect, 'data');

        var analyticsObject = self.createAnalyticsObject(self.account);

        self.isUpdatingAccount = true;
        return self.account.createSubAccount()
            .then(function (subAccount) {
                self.createEventHandler({account: subAccount});
                LogzToast.success('Account created');
                analyticsObject.success = true;
            }).catch(function (error) {
                // TODO: Decoration of the error (if it's 500, then show a relevant error),
                // refactor to use both errors properly.
                var errorMessage = error ?
                    'Failure: ' + error.data :
                    'There was an error, please contact support';

                LogzToast.error(errorMessage, false);

                analyticsObject.success = false;
                analyticsObject.error = error;

                return $q.reject(error);
            })
            .finally(function () {
                AnalyticsService.report('create', analyticsObject);
                self.isUpdatingAccount = false;
            });
    };

    self.deleteSubAccount = function () {
        var analyticsObject = self.createAnalyticsObject(self.account);

        return self.account.delete()
            .then(function () {
                // TODO: toggle some loader? do I really have to wait to deletion? not necessary.
                self.deleteEventHandler({deletedAccount: self.account});
                LogzToast.success('Sub account deleted');
                analyticsObject.success = true;
            })
            .catch(function (error) {
                // TODO: Decoration of the error (if it's 500, then show a relevant error),
                // refactor to use both errors properly.
                var errorMessage = error ?
                    'Failure: ' + error.data :
                    'There was an error, please contact support';

                LogzToast.error(errorMessage, false);

                analyticsObject.success = false;
                analyticsObject.error = error;

                return $q.reject(error);
            })
            .finally(function () {
                AnalyticsService.report('delete', analyticsObject);
            });
    };

    self.confirmDeleteSubAccount = function (subAccountName) {
        ConfirmService.open({
            template: 'directives/confirm-dialog/text-confirm-dialog.html',
            confirmButtonText: 'Delete',
            width: '524px',
            isFormValid: function (inputName) {
                return subAccountName === inputName;
            },
            action: 'Objects defined in this sub account are shared with other accounts. ' +
            'Are you sure you want to delete it? \n' +
            'There is no going back! \n\n' +
            'Please enter sub account\'s name:',
            confirm: function () {
                var confirmDialog = this;
                self.isUpdatingAccount = true;
                self.deleteSubAccount()
                    .finally(function () {
                        self.isUpdatingAccount = false;
                        confirmDialog.closeThisDialog();
                    });
            },
            cancel: function () {
                this.closeThisDialog();
            }
        });
    };

    self.createAnalyticsObject = function (account) {
        var analyticsObject = {
            category: 'sub-accounts'
        };

        if (account) {
            analyticsObject.accountName = account.name;
            analyticsObject.maxDailyGB = account.volumeGB;
            analyticsObject.retentionDays = account.retentionDays;
            analyticsObject.searchable = account.isSearchable;
            analyticsObject.accessible = account.isAccessible;
            analyticsObject.sharingObjectAccounts = account.sharingObjectAccounts;
        }
        return analyticsObject;
    };

    self.updateAccount = function () {
        self.isUpdatingAccount = true;
        self.account.sharingObjectsAccounts = _.map(self.account.sharingObjectsAccountsMultiSelect, 'data');

        var analyticsObject = self.createAnalyticsObject(self.account);

        // We want to save a reference to the current account,
        // even if a user would exit the current scope
        var currentAccount = _.cloneDeep(self.account);
        return self.account.update()
            .then(function () {
                // TODO: Should be the object we receive from the response, and then resyncing the accounts
                self.updateEventHandler({account: currentAccount});
                LogzToast.success('Account updated');

                analyticsObject.success = true;
            })
            .catch(function (error) {
                // TODO: Decoration of the error (if it's 500, then show a relevant error)
                var errorMessage = error.data ?
                    'Failure: ' + error.data :
                    'There was an error, please contact support';

                LogzToast.error(errorMessage, false);

                analyticsObject.success = false;
                analyticsObject.error = error;

                return $q.reject(error);
            }).finally(function () {
                AnalyticsService.report('edit', analyticsObject);
                self.isUpdatingAccount = false;
            });
    };

    /***
     * Clone the original selected account and use it in the current context,
     * to prevent mutating the original account
     */
    self.initFormlySelectedAccount = function () {
        self.account = _.cloneDeep(self.selectedAccount);
    };

    self.fillSharingObjectsAccounts = function () {
        // Fill sharing accounts for edit form
        self.account.sharingObjectsAccountsMultiSelect = self.accountsGroupForSelection[0].data.filter(function (account) {
            return _.includes(self.account.sharingObjectsAccounts, account.data);
        });
    };

    self.cancelAccountSelection = function () {
        self.cancelEventHandler();
    };

    /*********************************************************************************************************
     *                                      HIGH-CHARTS GRAPHS                                               *
     *********************************************************************************************************/

    self.createAccountWeeklyUsageGraph = function (data) {
        var maxDaily = _.maxBy(data, 'bytes');

        self.accountWeeklyUsageGraph = Highcharts.chart('account-weekly-usage-graph', {
            chart: {
                type: 'column',
                margin: [60, 0, 0, 0],
                width: 160,
                height: 100,
                backgroundColor: null,
            },
            title: false,
            legend: false,
            xAxis: {
                labels: false,
                title: false,
                tickPositions: []
            },
            yAxis: {
                labels: false,
                gridLineWidth: 0,
                title: false
            },
            tooltip: {
                formatter: function () {
                    return this.point.name + ' <br /> ' + window.LogzIO.formatBytes(this.point.rawData);
                }
            },
            credits: false,
            plotOptions: {
                column: {
                    // Hard coded since this is the only way the animation works
                    color: '#a3a3a3',
                    borderWidth: 0,
                    pointWidth: 10,
                    states: {
                        hover: {
                            animation: {duration: 200},
                            brightness: -0.3,
                            borderWidth: 5,
                            // Hard coded since this is the only way the animation works
                            borderColor: '#575757'
                        }
                    }
                }
            },
            series: [{
                // .slice().reverse() to not mutate original data
                data: data.slice().reverse().map(function (dailyUsage) {
                    return {
                        name: moment(dailyUsage.date).format('MMM DD'),
                        // GB
                        y: dailyUsage.bytes / (1024 * 1024 * 1024),
                        rawData: dailyUsage.bytes,
                        color: maxDaily === dailyUsage ? 'black' : '',
                    };
                })
            }]
        });
    };

    /*********************************************************************************************************
     *                                      LIFE-CYCLE HOOKS                                                 *
     *********************************************************************************************************/

    self.$onInit = function () {
        // AFTER UPDATE REPLACE THE SELECTED/  WITH THE NEW
        self.initFormlySelectedAccount();
        self.setSharingObjectAccountsSuggestions(self.account.getFlatAccountList());
        self.fillSharingObjectsAccounts();

        if (self.account.token) {
            self.createAccountWeeklyUsageGraph(self.account.dailyUsage);
        }
    };
    // Since one-way binding goes only for reference, we need to clone the object in order to isolate it from the parent
    self.$onChanges = function (changesObj) {
        if (changesObj.selectedAccount && !changesObj.selectedAccount.isFirstChange()) {
            self.$onInit();
        }
    };
});

/* origin: public/webapp/app/dashboard/settings/manage-accounts/edit-main-account.js */
angular.module('webApp').controller('EditMainAccount', function ($scope, $q, $rootScope, AccountService, SubAccountsService, FeatureFlagService, AnalyticsService) {
    _.defaults($scope, {
        accountId: 0,
        accountName: '',
        subAccounts: [],
        sharingAccounts: []
    });

    $scope.sharingAccountIds = $scope.sharingAccounts.map(function(x) { return x.accountId; });

    var sharableAccounts = $scope.subAccounts
        .filter(function(x) { return x.account.accountId !== $scope.accountId; })
        .map(function(x) { return { accountId: x.account.accountId, name: x.account.accountName }; });

    $scope.subAccountGroup = [{
        name: 'Sub Accounts',
        icon: 'email',
        noResults: 'No Sub Accounts to select',
        id: 0,
        data: sharableAccounts,
    }];

    $scope.selectedAccounts = $scope.subAccountGroup[0].data.filter(function(x) {
        return $scope.sharingAccountIds.some(function(sa) {
            return sa === x.accountId;
        });
    });

    $scope.isSaving = false;

    $scope.isSharedObjectsEnabled = false;
    FeatureFlagService.isFeatureEnabled('shared-objects').then(function(isEnabled) {
        $scope.isSharedObjectsEnabled =  isEnabled;
    });

    $scope.shared = function(accountId) {
        return _.includes($scope.sharingAccounts, accountId.toString());
    };

    $scope.save = function () {
        $scope.isSaving = true;

        var sharingAccountsIds = $scope.selectedAccounts.map(function(x) { return x.accountId; });
        AccountService.updateMainAccount($scope.accountName, sharingAccountsIds).then(function () {

            AnalyticsService.report('sub-accounts:edit', {
                isMain: true,
                accountName: $scope.accountName,
                sharingObjectsAccounts: sharingAccountsIds
            });
            if (sharingAccountsIds && sharingAccountsIds.length)
                AnalyticsService.report('sub-accounts:sharing-accounts', sharingAccountsIds);

            $rootScope.$emit('Account.updatedName', $scope.accountName);
        }).catch(function () {
            SubAccountsService.errorDialog('Could not update the account.');
        }).finally(function () {
            $scope.isSaving = false;
            $scope.success($scope.accountName);
            $scope.closeThisDialog();
        });
    };
});

/* origin: public/webapp/app/dashboard/settings/manage-accounts/edit-sub-account.js */
angular.module('webApp').controller('EditSubAccount', function ($scope, $rootScope, AccountService, SubAccountsService, cacheService, $timeout, FeatureFlagService, AnalyticsService) {
    _.defaults($scope, {
        isNew: true,
        isEditFormOpen: true,
        mainAccount: {},
        accountId: 0,
        accountName: '',
        accountToken: '',
        maxDailyGB: 0,
        retentionDays: 0,
        accessible: false,
        searchable: false,
        mainRemainingGB: 0,
        totalRetentionDays: 0,
        subAccounts: [],
        sharedAccounts: []
    });


    $scope.sharingAccountIds = $scope.sharedAccounts.map(function (x) {
        return x.accountId;
    });

    var sharableAccounts = $scope.subAccounts
        .filter(function (x) {
            return x.account.accountId !== $scope.accountId;
        })
        .map(function (x) {
            return {accountId: x.account.accountId, name: x.account.accountName};
        });

    sharableAccounts.unshift({
        accountId: $scope.mainAccount.accountId,
        name: $scope.mainAccount.accountName
    });

    $scope.subAccountGroup = [{
        name: 'Sub Accounts',
        icon: 'email',
        noResults: 'No Sub Accounts to select',
        id: 0,
        data: sharableAccounts,
    }];

    $scope.selectedAccounts = $scope.subAccountGroup[0].data.filter(function (x) {
        return $scope.sharingAccountIds.some(function (sa) {
            return sa === x.accountId;
        });
    });

    $scope.isSharedObjectsEnabled = false;
    FeatureFlagService.isFeatureEnabled('shared-objects').then(function (isEnabled) {
        $scope.isSharedObjectsEnabled = isEnabled;
    });


    var oldName = $scope.accountName.toLowerCase();
    var subAccountNames = sharableAccounts.map(function (x) {
        return x.name.toLowerCase();
    });

    $scope.save = function () {
        if (!isFormValid())
            return;


        var lowerAccountName = $scope.accountName.toLowerCase();
        if (lowerAccountName !== oldName && _.includes(subAccountNames, lowerAccountName)) {
            return SubAccountsService.errorDialog('SUB_ACCOUNT_ALREADY_EXISTS');
        }

        $scope.updatingSubAccount = true;
        $scope.lockForm = true;

        var data = {
            accountName: $scope.accountName,
            maxDailyGB: $scope.maxDailyGB,
            retentionDays: $scope.retentionDays,
            searchable: $scope.searchable,
            accessible: $scope.accessible,
            sharingObjectsAccounts: $scope.selectedAccounts.map(function (x) {
                return x.accountId;
            })
        };

        var promise = $scope.isNew
            ? AccountService.createSubAccount(data)
            : AccountService.updateSubAccount($scope.accountId, data);


        promise.then(function () {
            if ($scope.maxDailyGB !== $scope.initialMaxGB) {
                $scope.showUpdateMessage = true;
            }

            AnalyticsService.report('sub-accounts:edit', data);
            if (data.sharingObjectsAccounts && data.sharingObjectsAccounts.length)
                AnalyticsService.report('sub-accounts:sharing-accounts', data.sharingObjectsAccounts);

            $rootScope.$emit('SubAccounts.updated');

            if (!$scope.isNew)
                $rootScope.$emit('SubAccounts.updated.' + $scope.accountId, data);

            $rootScope.$emit('SubAccounts.updateRemainingGB');

            cacheService.clear('sub-accounts');
            cacheService.clear('accounts-index-map');

            animateSaveButtonAndClose(data);
        }).catch(function () {
            $scope.closeThisDialog();
            SubAccountsService.errorDialog($scope.isNew ? 'COULD_NOT_CREATE_SUB_ACCOUNT' : 'COULD_NOT_UPDATE_SUB_ACCOUNT');
        });
    };

    function isFormValid() {
        if ($scope.updatingSubAccount)
            return false;

        if (!$scope.accountName || $scope.accountName.length === 0)
            return false;

        if ($scope.maxDailyGB < 0 || $scope.maxDailyGB > $scope.mainRemainingGB + $scope.initialMaxGB)
            return false;

        if ($scope.retentionDays < 1 || $scope.retentionDays > $scope.totalRetentionDays)
            return false;

        return true;
    }

    function animateSaveButtonAndClose(data) {
        $timeout(angular.noop, 1000).then(function () {
            $scope.updatingSubAccount = false;
            $scope.finishedUpdatingSubAccount = true;
            return $timeout(angular.noop, 800);
        }).then(function () {
            $scope.lockForm = false;
            $scope.isEditFormOpen = false;
            return $timeout(angular.noop, 300);
        }).then(function () {
            $scope.finishedUpdatingSubAccount = false;
            $scope.success(data);
            $scope.closeThisDialog();
        });
    }
});

/* origin: public/webapp/app/dashboard/settings/manage-accounts/manage-accounts.js */
angular.module('webApp')
    .controller('ManageAccountsSettingsController', function($scope, UserService, UpgradeService, ngDialog, $state, $rootScope, AccountService, $timeout, Focus, SubAccountsService, sharedObjects) {

        this.$onInit = function() {
            return UserService.getSummary().then(function(summary) {
                if (summary.data.subAccount)
                    $state.go('dashboard.kibana');
            });
        };

        var ERR_ZERO_MANAGED_ACCOUNTS = 'Account has zero managed accounts.';

        var initMainAccountDetails = function() {
            $scope.mainAccountDetails = {};

            return UserService.getSummary()
                .then(function(res) {
                    var summary = res.data;

                    if (summary.subAccount) {
                        // Current account is a sub account of another primary account, this page is irrelevant for this account
                        throw new Error(ERR_ZERO_MANAGED_ACCOUNTS);
                    }

                    $scope.mainAccountDetails.accountName = summary.accountName;
                    $scope.mainAccountDetails.accountToken = summary.accountToken;
                })
                .then(UpgradeService.getPlanDetails)
                .then(function (res) {
                    if (res.data.maxSubAccounts === 0)
                        throw new Error(ERR_ZERO_MANAGED_ACCOUNTS);

                    $scope.mainAccountDetails.accountId = res.data.accountId;
                    $scope.mainAccountDetails.totalDailyGB = res.data.maxDailyGB;
                    $scope.mainAccountDetails.maxSubAccounts = res.data.maxSubAccounts;
                    $scope.mainAccountDetails.totalRetentionDays = res.data.retentionDays;
                    $scope.mainAccountDetails.maxDailyGB = res.data.maxDailyGB;
                    $scope.mainAccountDetails.remainingGB = res.data.maxDailyGB;
                })
                .then(UserService.getUsage)
                .then(function (usage) {
                    $scope.mainAccountDetails.usage = SubAccountsService.normalizeDailyUsageArray(usage);
                    $scope.mainAccountDetails.usageDateRanges = SubAccountsService.getUsageDateRangesString($scope.mainAccountDetails.usage);
                })
                .catch(function(e) {
                    if (e.message === ERR_ZERO_MANAGED_ACCOUNTS)
                        return $state.go('dashboard.kibana');

                    $scope.mainAccountDetails.usage = [];
                    $scope.mainAccountDetails.usageDateRanges = 'N/A';
                })
                .finally(function() {
                    $scope.isLoadingPage = false;
                });
        };

        var updateTotalAccountAndSubAccountsUsage = function() {
            var totalUsage = $scope.mainAccountDetails.usage;
            if (_.isUndefined(totalUsage)) {
                $scope.totalAccountAndSubAccountsUsage = [];
                return;
            }

            angular.forEach($scope.subAccounts, function (subAccount) {
                Object.keys(totalUsage).forEach(function(u) {
                    if (subAccount.dailyUsagesList.hasOwnProperty(u)) {
                        totalUsage[u] += subAccount.dailyUsagesList[u];
                    }
                });
            });

            if (totalUsage.hasOwnProperty('contains'))
                delete totalUsage['contains'];

            $scope.totalAccountAndSubAccountsUsage = totalUsage;
        };

        $scope.openEditMainAccountForm = function() {
            var dialogProperties = {
                template: 'app/dashboard/settings/manage-accounts/edit-main-account.html',
                controller: 'EditMainAccount',
                width: '765px',
                showClose: false
            };

            var dialogScope = $scope.$new();
            dialogScope.accountName = $scope.mainAccountDetails.accountName;
            dialogScope.accountId = $scope.mainAccountDetails.accountId;
            dialogScope.subAccounts = $scope.subAccounts;
            dialogScope.success = function(newName) {
                sharedObjects.clearCache();
                $scope.mainAccountDetails.accountName = newName;
            };

            sharedObjects.getSharingAccounts().then(function(sharingAccounts) {

                dialogScope.sharingAccounts = sharingAccounts;
                dialogProperties.scope = dialogScope;

                ngDialog.open(dialogProperties);
            });
        };

        var refreshSubAccountsList = function() {
            $scope.isLoadingSubAccounts = true;
            return AccountService.getSubAccounts().then(function (subAccounts) {
                $scope.subAccounts = subAccounts;
                $scope.mainAccountDetails.remainingGB = $scope.mainAccountDetails.maxDailyGB;
                $rootScope.$emit('SubAccounts.updateRemainingGB');

                angular.forEach(subAccounts, function(subAccount) {
                    subAccount.dailyUsagesList = SubAccountsService.normalizeDailyUsageArray(subAccount.dailyUsagesList.usage);
                    subAccount.usageDateRanges = SubAccountsService.getUsageDateRangesString(subAccount.dailyUsagesList);
                    subAccount.accessible = subAccount.subAccountRelation.accessible;
                    subAccount.searchible = subAccount.subAccountRelation.searchable;

                    subAccount.accountId = subAccount.subAccountRelation.subAccountId;

                    subAccount.usageDateRanges = $scope.mainAccountDetails.usageDateRanges;
                });

                updateTotalAccountAndSubAccountsUsage();
            }).catch(function() {
                SubAccountsService.errorDialog('COULD_NOT_GET_SUB_ACCOUNTS');
            }).finally(function() {
                $scope.isLoadingSubAccounts = false;
            });
        };

        $scope.totalAccountAndSubAccountsUsage = null;
        $scope.isAddFormVisible = false;
        $scope.isCreatingSubAccount = false;
        $scope.areAllOpened = true;
        $scope.searchTerm = '';
        $scope.accountNameEdit = '';
        $scope.subAccounts = [];
        $scope.doesSubAccountItemsExpanded = true;
        $scope.isLoadingSubAccounts = true;
        $scope.editAccountNameMode = false;
        $scope.doesUpdatingMainAccountName = false;
        $scope.isLoadingPage = true;
        $scope.copyAnimationActive = false;
        $scope.addSubAccountFormOriginal = {};

        var animationTimer = false;

        $scope.focusSearchInput = function() { Focus('search-sub-accounts-input'); };
        $scope.playCopyAnimation = function() {
            $scope.copyAnimationActive = true;
            animationTimer = $timeout(function() {
                $scope.copyAnimationActive = false;
            }, 1400);
        };

        $scope.setEditMode = function() {
            $scope.originalAccountName = $scope.mainAccountDetails.accountName;
            $scope.editAccountNameMode = true;
            Focus('edit-main-account-name-input');
        };
        $scope.exitEditMode = function() {
            $scope.editAccountNameMode = false;
            $scope.mainAccountDetails.accountName = $scope.originalAccountName;
        };

        $scope.upgrade = function() { $state.go('dashboard.settings.usage-and-billing'); };

        $scope.openAddSubAccountForm = function() {
            if ($scope.mainAccountDetails.maxSubAccounts === $scope.subAccounts.length)
                return SubAccountsService.errorDialog('MAX_SUB_ACCOUNTS');

            var dialogProperties = {
                template: 'app/dashboard/settings/manage-accounts/edit-sub-account.html',
                controller: 'EditSubAccount',
                width: '765px',
                showClose: false
            };

            var dialogScope = $scope.$new();
            dialogScope.accountName = '';
            dialogScope.mainAccount = $scope.mainAccountDetails;
            dialogScope.mainRemainingGB = $scope.mainAccountDetails.remainingGB;
            dialogScope.totalRetentionDays = $scope.mainAccountDetails.totalRetentionDays;
            dialogScope.retentionDays = $scope.mainAccountDetails.totalRetentionDays;
            dialogScope.success = refreshSubAccountsList;
            dialogScope.subAccounts = $scope.subAccounts;
            dialogProperties.scope = dialogScope;

            ngDialog.open(dialogProperties);
        };

        $scope.updateRemainingGB = function() {
            $scope.mainAccountDetails.remainingGB = $scope.mainAccountDetails.maxDailyGB;
            angular.forEach($scope.subAccounts, function(subAccount) {
                if (subAccount.account !== undefined)
                    $scope.mainAccountDetails.remainingGB -= subAccount.account.maxDailyGB;
            });
        };

        $scope.searchTermFilter = function(subAccount) {
            return subAccount.account.accountName.toLowerCase().indexOf($scope.searchTerm.toLowerCase()) !== -1 ||
                (subAccount.subAccountRelation && subAccount.subAccountRelation.subAccountId && subAccount.subAccountRelation.subAccountId.toString().indexOf($scope.searchTerm) !== -1);
        };

        // Fetch data and initialize
        initMainAccountDetails().then(refreshSubAccountsList);

        // Custom events
        var unwatchRemoveSubAccounts = $rootScope.$on('SubAccounts.removeSubAccountFromArray', function(event, accountId) {
            $scope.subAccounts = _.filter($scope.subAccounts, function(s) { return s.accountId !== accountId; });
        });
        var unwatchRemainingGB = $rootScope.$on('SubAccounts.updateRemainingGB', $scope.updateRemainingGB);

        $scope.$on('$destroy', function() {
            if (unwatchRemoveSubAccounts && _.isFunction(unwatchRemoveSubAccounts)) unwatchRemoveSubAccounts();
            if (unwatchRemainingGB && _.isFunction(unwatchRemainingGB)) unwatchRemainingGB();
            $timeout.cancel(animationTimer);
        });
    });
/* origin: public/webapp/app/dashboard/settings/manage-accounts/sub-account-item.js */
angular.module('webApp').directive('subAccountItem', function(ngDialog, $rootScope, $timeout, AccountService, SubAccountsService) {
    var link = function($scope) {
        $scope.isEditFormOpen = false;
        $scope.updatingSubAccount = false;
        $scope.finishedUpdatingSubAccount = false;
        $scope.editSubAccountFormOriginal = {};
        $scope.deletingSubAccount = false;
        $scope.hasChanged = false;

        $scope.showUpdateMessage = false;

        $scope.copyAnimationActive = false;
        var unwatchCopyAnimationTimer;

        $scope.playCopyAnimation = function(){
            $scope.copyAnimationActive = true;
            unwatchCopyAnimationTimer = $timeout(function() {
                $scope.copyAnimationActive = false;
            }, 1400);
        };

        $scope.openEditForm = function($event) {
            ngDialog.open(initDialogProperties($scope, $event));
        };

        $scope.showDeleteDialog = function(accountName) {
            if ($scope.updatingSubAccount)
                return;

            var $parentScope = $scope;
            var dialog = ngDialog.open({
                data: {
                    title: 'Oops'
                },
                controller: ['$scope', '$timeout', 'Focus', function($scope, $timeout, Focus) {
                    $scope.subAccountName = accountName;
                    $scope.inputSubAccountName = '';
                    $scope.showRedBorder = false;
                    $scope.checkFormAndDelete = function(inputVal) {
                        if ($scope.subAccountName.trim().toLowerCase() !== inputVal.trim().toLowerCase()) {
                            $scope.showRedBorder = true;
                            angular.element('#delete-dialog-input').focus();
                            return;
                        }

                        $parentScope.deleteSubAccount();
                        $scope.closeDialog();
                        $scope.showRedBorder = false;
                    };

                    $scope.showSharingAccountsWarning = $parentScope.$parent.subAccounts.some(function(sa) {
                        return sa.accountId !== $parentScope.subAccountObject.accountId
                            && sa.sharingObjectsAccounts.some(function(sharingSA) {
                                return sharingSA.accountId === $parentScope.subAccountObject.accountId;
                            })                            ;
                    });

                    $scope.closeDialog = dialog.close;

                    $timeout(function () { Focus('delete-sub-account-validator-input'); }, 0);

                }],
                className: 'dialog-delete',
                template: ' app/dashboard/settings/manage-accounts/delete-dialog.html',
                width: '376px',
                showClose: false,
                closeByEscape: true
            });
        };

        $scope.deleteSubAccount = function() {
            $scope.deletingSubAccount = true;
            AccountService.deleteSubAccount($scope.subAccountObject.accountId).then(function() {
                $rootScope.$emit('SubAccounts.removeSubAccountFromArray', $scope.subAccountObject.accountId);
                $rootScope.$emit('SubAccounts.updateRemainingGB');
                $rootScope.$emit('SubAccounts.updated');
            }).catch(function() {
                SubAccountsService.errorDialog('COULD_NOT_DELETE_SUB_ACCOUNT');
            }).finally(function() {
                $scope.deletingSubAccount = false;
            });
        };

        $scope.cancelEdit = function($event) {
            $event.stopPropagation();

            if ($scope.updatingSubAccount)
                return;

            $scope.isEditFormOpen = false;
        };

        $scope.$on('$destroy', function() {
            $timeout.cancel(unwatchCopyAnimationTimer);
        });

    };

    var initDialogProperties = function ($scope, $event) {
        $event.stopPropagation();

        var dialogProperties = {
            template: 'app/dashboard/settings/manage-accounts/edit-sub-account.html',
            controller: 'EditSubAccount',
            width: '765px',
            showClose: false
        };

        var dialogScope = $scope.$new();
        dialogScope.isEditFormOpen = true;
        dialogScope.isNew = false;

        dialogScope.accountId = $scope.subAccountObject.account.accountId;
        dialogScope.accountName = $scope.subAccountObject.account.accountName;
        dialogScope.accountToken = $scope.subAccountObject.account.accountToken;
        dialogScope.maxDailyGB = $scope.subAccountObject.account.maxDailyGB;
        dialogScope.initialMaxGB = $scope.subAccountObject.account.maxDailyGB;
        dialogScope.retentionDays = $scope.subAccountObject.account.retentionDays;
        dialogScope.accessible = $scope.subAccountObject.subAccountRelation.accessible;
        dialogScope.searchable = $scope.subAccountObject.subAccountRelation.searchable;
        dialogScope.subAccounts = $scope.$parent.subAccounts;
        dialogScope.sharedAccounts = $scope.subAccountObject.sharingObjectsAccounts;

        dialogScope.mainAccount = $scope.mainAccountObject;
        dialogScope.mainRemainingGB = $scope.mainAccountObject.remainingGB;
        dialogScope.totalRetentionDays = $scope.mainAccountObject.totalRetentionDays;
        dialogScope.success = function(data) {
            $scope.subAccountObject.account.accountName = data.accountName;
            $scope.subAccountObject.account.maxDailyGB = data.maxDailyGB;
            $scope.subAccountObject.account.retentionDays = data.retentionDays ;
            $scope.subAccountObject.subAccountRelation.searchable = data.searchable;
            $scope.subAccountObject.subAccountRelation.accessible = data.accessible;
            $scope.subAccountObject.sharingObjectsAccounts = data.sharingObjectsAccounts.map(function(x) { return { accountId: x }; });
        };

        dialogProperties.scope = dialogScope;



        return dialogProperties;
    };

    var isolatedScope = {
        subAccountObject: '=',
        listIndex: '@',
        mainAccountObject: '='
    };

    return {
        templateUrl: 'app/dashboard/settings/manage-accounts/sub-account-item.html',
        restrict: 'A',
        link: link,
        scope: isolatedScope
    };
});


/* origin: public/webapp/app/dashboard/settings/manage-accounts/sub-accounts-service.js */
angular.module('webApp').service('SubAccountsService', function ($q, ngDialog, AccountService, AuthService, UserService, UpgradeService, cacheService, logzioApi) {

    var errors = {
        'COULD_NOT_GET_SUB_ACCOUNTS': 'Could not get managed accounts for this account, please contact support.',
        'MAX_SUB_ACCOUNTS': 'You have reached the maximal number of sub-accounts for your account.',
        'SUB_ACCOUNT_ALREADY_EXISTS': 'A sub-account with that name already exists.',
        'SUB_ACCOUNT_NAME_IS_EMPTY': 'Please provide a name for this sub-account.',
        'INVALID_RETENTION_TIME': 'Retention time can not be zero or greater than the main account\'s retention time.',
        'INVALID_DAILY_VOLUME': 'Daily volume can not be zero or greater than the main account\'s daily volume.',
        'COULD_NOT_CREATE_SUB_ACCOUNT': 'Could not create the sub-account, please contact support.',
        'COULD_NOT_UPDATE_SUB_ACCOUNT': 'Could not update this sub-account, please contact support.',
        'COULD_NOT_DELETE_SUB_ACCOUNT': 'Could not delete this sub-account.',
    };

    var service = function() { };

    service.prototype.errorDialog = function (errorKey) {
        logzioApi.errorPopup('Oops', errors[errorKey], false);
    };

    service.prototype.normalizeSize = function(size) {
        var sizeInGigaBytes = size / 1024 / 1024 / 1024,
            shortened = sizeInGigaBytes.toFixed(2);

        if (shortened * 10 / shortened === 1)
            return parseFloat('' + shortened + '0');
        return parseFloat(shortened);
    };

    service.prototype.normalizeDailyUsageArray = function(usage) {
        var self = this;

        if (!_.isArray(usage))
            usage = [];

        usage.sort(function(a, b) { return a.date - b.date; });
        var ret = [];

        angular.forEach(usage, function (value) {
            ret[value.date.toString()] = self.normalizeSize(value.bytes);
        });

        return ret;
    };

    service.prototype.getUsageDateRangesString = function(usageArr) {
        if (usageArr && Object.keys(usageArr).length) {
            return d3.time.format('%b %d')(new Date(parseInt(Object.keys(usageArr)[0]))) +
                ' - ' + d3.time.format('%b %d')(new Date(parseInt(Object.keys(usageArr)[Object.keys(usageArr).length-1])));
        }
        else
            return 'N/A';
    };

    return new service();
});
/* origin: public/webapp/app/dashboard/settings/manage-users/manage-users.js */
angular.module('webApp').controller('ManageUsersSettingsController', function ($q, $scope, $rootScope, $state, $compile, Backend, UserService, AuthService, AccountService, UpgradeService) {

    var init = function () {
        $scope.loading = true;

        $q.all({
            accountUsers: AccountService.getUsers(),
            userSummary: UserService.getSummary()
        }).then(function (res) {
            $scope.accountUsers = res.accountUsers;
            $scope.accountId = res.userSummary.data.accountId;
            $scope.canManuallyAddUsers = res.userSummary.data.canManuallyAddUsers;
        }).finally(function () {
            $scope.loading = false;
        });
    };
    init();

    $scope.addUser = function () {
        if ($scope.loading || !$scope.canManuallyAddUsers) return;

        UpgradeService.getPlanDetails().then(function (planDetails) {
            var maxUsers = planDetails.data.maxUsersCount;
            var activeUsers = _.filter($scope.accountUsers, function (user) {
                return user.active;
            });
            if (maxUsers === 0 || activeUsers.length >= maxUsers)
                UpgradeService.usersDialog();
            else
                openAddUser();
        });
    };

    var openAddUser = function () {
        var newUserRow = '<logz-user-row editing="true" account="' + $scope.accountId + '" />';
        var compiled = $compile(newUserRow)($scope);
        $('.users-list-contents').append(compiled);
        $('.new-button.add-user').hide();
    };

    $rootScope.$on('user-management-change', function () {
        init();
        $('logz-user-row:last').remove();
        $('.new-button.add-user').show();
    });

});
/* origin: public/webapp/app/dashboard/settings/s3-archiving/s3-archiving.js */
angular.module('webApp').controller('S3ArchivingSettingsController', function ($scope, AuthService, Backend, UserService) {

    UserService.getSummary().then(function (res) {
        $scope.accountId = res.data.accountId;
    });

    if (!$scope.settings)
        $scope.settings = {};

    AuthService.getUser().then(function (user) {
        $scope.accountId = user.data.accountId;
    });

    Backend.GET('/account/archive-settings').then(function (s3ArchiveSettings) {
        if (!s3ArchiveSettings.data)
            alert('There was an error retrieving your s3 archive settings.\nPlease refresh the page to retry again.');

        $scope.settings = s3ArchiveSettings.data;

        _.forEach($scope.settings, function (s3Settings) {
            s3Settings.secret = s3Settings.encryptedSecret; // For the dots in the html dom
        });
    });

});
/* origin: public/webapp/app/dashboard/settings/settings-menu/settings-menu-controller.js */
angular.module('webApp').controller('SettingsMenuController', function ($q, $state, UserService, AuthService, UpgradeService, FeatureFlagService, isHeroku, enums) {
    var vm = this;

    function isAdminRole () {
        return userSession.role === enums.USER_ROLES.ADMIN;
    }

    var initData = function () {
        vm.pages = [{
            title: 'General',
            stateName: 'general',
            visible: function () { return true; }
        }, {
            title: 'Manage Users',
            stateName: 'manage-users',
            visible: isAdminRole
        }, {
            title: 'Manage Accounts',
            stateName: timelessIndexEnabled ? 'manage-accounts_' : 'manage-accounts',
            visible: function () {
                return !isHeroku && isAdminRole() && planDetails.maxSubAccounts > 0 && !isSubAccount;
            }
        }, {
            title: 'Usage & Billing',
            stateName: 'usage-and-billing',
            visible: function () {
                return !isHeroku && isAdminRole();
            }
        }, {
            title: 'Shared Tokens',
            stateName: 'shared-tokens',
            visible: isAdminRole
        }, {
            title: 'S3 Archiving',
            stateName: 's3-archiving',
            visible: isAdminRole,
            preOpenFunc: function () {
                if (planDetails.planType === 'PRO' || planDetails.planType === 'TRIAL' || planDetails.planType === 'ENTERPRISE') {
                    return true;
                }
                else {
                    UpgradeService.s3archiveDialog();
                    return false;
                }
            }
        }, {
            title: 'Field Mapping',
            stateName: 'field-mapping',
            visible: function () {
                return isAdminRole() && fieldMappingEnabled;
            }
        }, {
            title: 'System Status',
            stateName: 'system-status',
            visible: function () { return true; }
        }];
    };

    vm.openPage = function (page) {
        if (page.preOpenFunc && !page.preOpenFunc()) {
            return;
        }

        var stateFullName = [ 'dashboard.settings.', page.stateName ].join('');
        $state.go(stateFullName);
    };

    vm.visibilityFilter = function (item) {
        return item.visible();
    };

    var getCurrentNestedStateName = function () {
        return $state.current.name.replace('dashboard.settings.', '');
    };

    var validateCurrentPageAndSetActive = function () {
        var currentPage = _.find(vm.pages, { stateName: getCurrentNestedStateName() });

        // TODO: AMIR - Remove once the new manage accounts is open for all,
        if (_.endsWith($state.current.name, 'manage-accounts')) {
            // If we arrive from the url, we actively set the current page to OLD manage accounts
            currentPage = _.find(vm.pages, {title: 'Manage Accounts'});
            currentPage.isActive = true;
            return;
        }

        if (!currentPage || !vm.visibilityFilter(currentPage)) {
            vm.openPage(vm.pages[0]);
            return;
        }

        currentPage.isActive = true;
    };

    var isSubAccount;
    var userSession;
    var fieldMappingEnabled;
    var timelessIndexEnabled;
    var planDetails;
    $q.all({
        userSummary: UserService.getSummary(),
        userSession: AuthService.getUserSession(),
        fieldMappingEnabled: FeatureFlagService.isFeatureEnabled('field-mappings'),
        timelessIndexEnabled: FeatureFlagService.isFeatureEnabled('timeless-index'),
        planDetails: UpgradeService.getPlanDetails()
    }).then(function (res) {
        isSubAccount = res.userSummary.data.subAccount;
        userSession = res.userSession;
        fieldMappingEnabled = res.fieldMappingEnabled;
        timelessIndexEnabled = res.timelessIndexEnabled;
        planDetails = res.planDetails.data;
        initData();
        validateCurrentPageAndSetActive();
    });
});
/* origin: public/webapp/app/dashboard/settings/settings-menu/settings-menu.js */
angular.module('webApp').directive('settingsMenu', function () {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/settings/settings-menu/settings-menu.html',
        controller: 'SettingsMenuController',
        controllerAs: 'vm',
        scope: true
    };
});
/* origin: public/webapp/app/dashboard/settings/shared-tokens/shared-tokens.js */
angular.module('webApp').controller('SharedTokensSettingsController', function($scope, Backend, UserTokensService) {

    var loadTokens = function() {
        UserTokensService.getUserTokens().then(function(tokens) {
            $scope.tokens = tokens;
            $scope.tokens.push({});
        });
    };
    loadTokens();

    var loadQueryFilters = function() {
        UserTokensService.getQueryFilters().then(function(filters) {
            $scope.queryFilters = filters;
            $scope.queryFilters.push({
                description: '',
                type: 'TERM',
                content: {
                    field: '',
                    value: '',
                    type: 'TERM'
                }
            });
        });
    };
    loadQueryFilters();

    $scope.$on('user-token-update', function() {
        UserTokensService.clearCache();
        loadQueryFilters();
        loadTokens();
    });
    $scope.$on('query-filter-update', function() {
        UserTokensService.clearCache();
        loadQueryFilters();
        loadTokens();
    });

});
/* origin: public/webapp/app/dashboard/settings/timeless-accounts/timeless-accounts-card/edit-timeless-account-section/edit-timeless-account-section.component.js */
angular.module('webApp').component('manageAccountsEditTimelessAccountSection', {
    controller: 'ManageAccountsEditTimelessAccountSectionCtrl',
    controllerAs: 'vm',
    templateUrl: 'app/dashboard/settings/timeless-accounts/timeless-accounts-card/edit-timeless-account-section/edit-timeless-account-section.html',
    bindings: {
        cancelEventHandler: '&',
        updatedEventHandler: '&',
        createdEventHandler: '&',
        deletedEventHandler: '&',
        selectedTimelessAccount: '<',
        account: '<',
        accountsList: '<',
        availableVolumeGb: '<'
    }
});
/* origin: public/webapp/app/dashboard/settings/timeless-accounts/timeless-accounts-card/edit-timeless-account-section/edit-timeless-account-section.controller.js */
angular.module('webApp').controller('ManageAccountsEditTimelessAccountSectionCtrl', function (LogzToast, ConfirmService, TimelessAccount, TimelessAccountsService, AnalyticsService, $q) {

    var self = this;

    self.setSharingObjectAccountsSuggestions = function (accounts) {
        self.multiSelectAuthorizedAccounts = [];
        self.accountsGroupForSelection = [{
            data: _.map(accounts, function (account) {
                return {
                    data: account.id,
                    name: account.name
                };
            })
        }];
    };

    self.setCurrentAuthorizedAccounts = function () {
        if (self.timelessAccount.authorizedAccounts) {
            self.multiSelectAuthorizedAccounts = self.accountsGroupForSelection[0].data.filter(function (multiSelectAccount) {
                return _.some(self.timelessAccount.authorizedAccounts, {'data': multiSelectAccount.data});
            });
        }
    };

    /***
     * Clone the original selected timeless account and use it in the current context,
     * to prevent mutating the original timeless account
     */
    self.initFormlySelectedTimelessAccount = function (selectedTimelessAccount) {
        self.timelessAccount = _.cloneDeep(selectedTimelessAccount);
    };

    self.cancelTimelessAccountSelection = function () {
        self.cancelEventHandler();
    };

    /***
     *
     * @returns {number} - The timeless account available volume gb
     */
    self.getOwnAvailableVolume = function () {
        var availableVolumeGb = self.availableVolumeGb;

        // If the timeless account exists already,
        // We add the timeless account current volume gb to the global available volume
        if (self.selectedTimelessAccount.createdAt) {
            availableVolumeGb += self.selectedTimelessAccount.volumeGb;
        }

        return availableVolumeGb;
    };

    /*********************************************************************************************************
     *                                      HIGH-CHARTS GRAPHS                                               *
     *********************************************************************************************************/

    self.saveTimelessAccount = function () {
        self.timelessAccount.setAuthorizedAccounts(self.multiSelectAuthorizedAccounts);

        if (!self.timelessAccount.createdAt) {
            self._createTimelessAccount(self.timelessAccount);
        }
        else {
            self._updateTimelessAccount(self.timelessAccount);
        }
    };

    self.createTimelessAccountWeeklyUsageGraph = function (data) {
        var maxDaily = _.maxBy(data, 'bytes');

        self.accountWeeklyUsageGraph = Highcharts.chart('timeless-account-weekly-usage-graph', {
            chart: {
                type: 'column',
                margin: [60, 0, 0, 0],
                width: 140,
                height: 100,
                backgroundColor: null,
            },
            title: false,
            legend: false,
            xAxis: {
                labels: false,
                title: false,
                tickPositions: []
            },
            yAxis: {
                labels: false,
                gridLineWidth: 0,
                title: false
            },
            tooltip: {
                formatter: function () {
                    return this.point.name + ' <br /> ' + window.LogzIO.formatBytes(this.point.rawData);
                }
            },
            credits: false,
            plotOptions: {
                column: {
                    // Hard coded since this is the only way the animation works
                    color: '#a3a3a3',
                    borderWidth: 0,
                    pointWidth: 10,
                    states: {
                        hover: {
                            animation: {duration: 200},
                            brightness: -0.3,
                            borderWidth: 5,
                            // Hard coded since this is the only way the animation works
                            borderColor: '#575757'
                        }
                    }
                }
            },
            series: [{
                // .slice().reverse() to not mutate original data
                data: data.slice().reverse().map(function (dailyUsage) {
                    return {
                        name: moment(dailyUsage.date).format('MMM DD'),
                        // GB
                        y: dailyUsage.bytes / (1024 * 1024 * 1024),
                        rawData: dailyUsage.bytes,
                        color: maxDaily === dailyUsage ? 'black' : '',
                    };
                })
            }]
        });
    };

    self._createTimelessAccount = function (timelessAccount) {
        // ConfirmService.open() - TODO: use it, validate in here too

        self.isSubmittingForm = true;

        var analyticsObject = self.createAnalyticsObject();

        return TimelessAccountsService.create(timelessAccount).then(function (timelessAccountRes) {
            if (timelessAccountRes.status >= 300) return;
            LogzToast.success('Account created');
            var timelessAccountResInstance = new TimelessAccount(timelessAccountRes.data);

            analyticsObject.success = true;
            analyticsObject.timelessAccountId = timelessAccountResInstance.id;

            self.createdEventHandler({timelessAccount: timelessAccountResInstance});
        }).catch(function (error) {
            // TODO: Decoration of the error (if it's 500, then show a relevant error),
            // refactor to use both errors properly.
            var errorMessage = error.data ?
                'Failure: ' + error.data.message :
                'There was an error, please contact support';

            LogzToast.error(errorMessage, false);

            analyticsObject.success = false;
            analyticsObject.timelessAccountId = timelessAccount.id;
            analyticsObject.error = error;

            return $q.reject(error);
        })
            .finally(function () {
                AnalyticsService.report('create', analyticsObject);
                self.isSubmittingForm = false;
            });
    };

    self.createAnalyticsObject = function () {
        return {
            category: 'timeless-accounts'
        };
    };

    self._updateTimelessAccount = function (timelessAccount) {
        self.isSubmittingForm = true;
        var analyticsObject = self.createAnalyticsObject();

        TimelessAccountsService.update(timelessAccount).then(function (timelessAccountRes) {
            if (timelessAccountRes.status >= 300) return;

            LogzToast.success('Account updated');
            var timelessAccountResInstance = new TimelessAccount(timelessAccountRes.data);

            analyticsObject.success = true;
            analyticsObject.timelessAccountId = timelessAccountResInstance.id;

            self.updatedEventHandler({timelessAccount: timelessAccountResInstance});
        })
            .catch(function (error) {
                // TODO: Decoration of the error (if it's 500, then show a relevant error),
                // refactor to use both errors properly.
                var errorMessage = error.data ?
                    'Failure: ' + error.data.message :
                    'There was an error, please contact support';

                LogzToast.error(errorMessage, false);

                analyticsObject.success = false;
                analyticsObject.timelessAccountId = timelessAccount.id;
                analyticsObject.error = error;

                return $q.reject(error);
            })
            .finally(function () {
                AnalyticsService.report('update', analyticsObject);
                self.isSubmittingForm = false;
            });
    };

    /*********************************************************************************************************
     *                                      LIFE-CYCLE HOOKS                                                 *
     *********************************************************************************************************/

    self.$onInit = function () {
        self.isSubmittingForm = false;

        self.weeklyUsageDateFormat = 'MMM dd';

        self.initFormlySelectedTimelessAccount(self.selectedTimelessAccount);
        self.setSharingObjectAccountsSuggestions(self.accountsList);
        self.setCurrentAuthorizedAccounts();

        if (self.timelessAccount.createdAt) {
            self.createTimelessAccountWeeklyUsageGraph(self.timelessAccount.dailyUsage.usage);
        }
    };

    // Since one-way binding goes only for reference, we need to clone the object in order to isolate it from the parent
    self.$onChanges = function (changesObj) {
        if (changesObj.selectedTimelessAccount && !changesObj.selectedTimelessAccount.isFirstChange()) {
            self.$onInit();
        }

        if (changesObj.accountsList && !changesObj.accountsList.isFirstChange()) {
            self.$onInit();
        }
    };
});

/* origin: public/webapp/app/dashboard/settings/timeless-accounts/timeless-accounts-card/timeless-account-model.js */
angular.module('webApp')
    .factory('TimelessAccount', function () {
        var TimelessAccount = function (timelessAccountObject) {
            if (!timelessAccountObject || !timelessAccountObject.createdAt) {
                var blankTimelessAccount = _createNewTimelessAccount();
                _.assignIn(this, blankTimelessAccount);
                return;
            }
            this.id = timelessAccountObject.id;
            this.name = timelessAccountObject.name;
            this.volumeGb = timelessAccountObject.volumeGb;
            this.actualUsage = timelessAccountObject.actualUsage;
            this.createdAt = timelessAccountObject.createdAt;
            this.dailyUsage = timelessAccountObject.dailyUsage;
            this.logType = timelessAccountObject.logType;

            // Adjusting the authorizedAccounts raw data to auto complete
            // compatible object
            this.authorizedAccounts = _.map(timelessAccountObject.authorizedAccounts, function (account) {
                return {
                    name: account.accountName,
                    data: account.accountId
                };
            });
            this.setColor();
        };

        // privates and globals
        _.assignIn(TimelessAccount.prototype, {
            _globalColorIndex: 0,
            // TODO: Style-Guide --> Colors
            colorsPalette: ['#fcc200', '#c5195a', '#00a9f7', '#44b049', '#5020ab'],

            _allocateColor: function () {
                this.color = this.colorsPalette[TimelessAccount.prototype._globalColorIndex % this.colorsPalette.length];
                TimelessAccount.prototype._globalColorIndex += 1;
            }
        });

        _.assignIn(TimelessAccount.prototype, {
            getAuthorizedAccounts: function () {
                if (_.isArray(this.authorizedAccounts) && this.authorizedAccounts.length > 0) {
                    return _.map(this.authorizedAccounts, function (permittedAccount) {
                        return permittedAccount.data;
                    });
                }
                return [];
            },

            setAuthorizedAccounts: function (authorizedAccounts) {
                this.authorizedAccounts = _.map(authorizedAccounts, function (authorizedAccount) {
                    return _.pick(authorizedAccount, ['name', 'data']);
                });
            },

            getParsedCreationTime: function () {
                return new moment.unix(this.createdAt).format('ddd, MMM DD YYYY');
            },

            getColor: function () {
                return this.color;
            },

            setColor: function () {
                this._allocateColor();
            },

            getParsedHumanReadableUsage: function () {
                var humanReadableSize = this.actualUsage.humanReadableSize || '';
                var humanReadableSizeComponents = humanReadableSize.split(' ');

                var number = humanReadableSizeComponents[0] || '0';
                var metric = humanReadableSizeComponents[1] || 'B';

                return {
                    number: number,
                    metric: metric
                };
            },

            getParsedActualUsagePercentage: function () {
                var percentage = this.actualUsage.percentage || 0.0;
                var percentageNumber = parseFloat(percentage);

                // TODO: change to a percentage filter, full implementation i;
                // https://stackoverflow.com/questions/29989200/angular-calculate-percentage-in-the-html
                return percentageNumber + '%';
            }
        });

        function _createNewTimelessAccount() {
            var blankTimelessAccount = {
                id: null,
                name: 'New timeless account',
                volumeGb: 1,
                actualUsage: {
                    percentage: 0,
                    bytes: 0,
                    humanReadableSize: '',
                },
                createdAt: null,
                logType: '',
                authorizedAccounts: [],
                dailyUsage: {
                    date: null,
                    bytes: 0,
                    humanReadableSize: ''
                },
                color: ''
            };
            return blankTimelessAccount;
        }

        return TimelessAccount;
    });
/* origin: public/webapp/app/dashboard/settings/timeless-accounts/timeless-accounts-card/timeless-accounts-card.component.js */
angular.module('webApp').component('manageAccountsTimelessAccountsCard', {
    controller: 'ManageAccountsTimelessAccountsCardCtrl',
    controllerAs: 'vm',
    templateUrl: 'app/dashboard/settings/timeless-accounts/timeless-accounts-card/timeless-accounts-card.html'
});
/* origin: public/webapp/app/dashboard/settings/timeless-accounts/timeless-accounts-card/timeless-accounts-card.controller.js */
angular.module('webApp').controller('ManageAccountsTimelessAccountsCardCtrl', function (TimelessAccountsService, TimelessAccount, Account, $timeout) {
    var self = this;

    self.timelessAccounts = [];
    self.selectedTimelessAccount = null;
    self.maxAllowedTimelessAccounts = 0;
    self.totalVolumeGb = 0;
    self.availableVolumeGb = 0;

    self.isLoading = true;

    /*********************************************************************************************************
     *                                          HIGH-CHARTS GRAPHS                                            *
     *********************************************************************************************************/
    self.createTimelessAccountPieChart = function () {
        self.timelessAccountsPieChart = Highcharts.chart('timeless-accounts-pie-chart-container', {
            chart: {
                plotBackgroundColor: null,
                backgroundColor: null,
                plotBorderWidth: null,
                plotShadow: false,
                type: 'pie'
            },
            credits: false,
            title: false,
            tooltip: {
                useHTML: true,
                headerFormat: '',
                pointFormat: '<span style="color:{point.color}">\u25CF</span> {point.name} <br />&nbsp;&nbsp;&nbsp;{point.y} GB <br />&nbsp;&nbsp;&nbsp;<b>{point.usage:.1f}% Usage</b><br /><div style="margin-top:5px; background-color:#e5e5e5; height: 6px;"><div style="width:{point.usage:.1f}%;background-color:{point.color};height: 100%">&nbsp;</div></div>',
            },
            plotOptions: {
                pie: {
                    allowPointSelect: true,
                    cursor: 'pointer',
                    borderWidth: 0,
                    dataLabels: false,
                    colorByPoint: true,
                    size: 200
                }
            },
            series: [{
                dashStyle: 'ShortDash',
                data: self.getDataForTimelessAccountsPieChart()
            }]
        });
    };

    /*********************************************************************************************************
     *                                              FUNCTIONS                                                *
     *********************************************************************************************************/

    self.getDataForTimelessAccountsPieChart = function () {
        var timelessAccounts = self.timelessAccounts.map(function (timelessAccount) {
            return {
                // ID is for distinguishing
                id: timelessAccount.id,
                name: timelessAccount.name,
                color: timelessAccount.color,
                y: timelessAccount.volumeGb,
                actualUsage: timelessAccount.actualUsage.percentage,
                events: {
                    select: function (event) {
                        self.setSelectedTimelessAccount(self.timelessAccounts[event.target.index]);
                    },
                    unselect: function (event) {
                        self.clearSelectedTimelessAccount(event.target.index);
                    }
                },
                selected: self.selectedTimelessAccount && (timelessAccount.id === self.selectedTimelessAccount.id)
            };
        });

        var pieChartAvailableSpace = self.getAvailableVolumeGb();
        if (pieChartAvailableSpace > 0) {
            timelessAccounts.push({
                name: 'Available space',
                color: 'transparent',
                borderWidth: 2,
                borderColor: '#d8d8d8',
                description: 'free',
                y: pieChartAvailableSpace
            }, 0);
        }

        return timelessAccounts;
    };

    self.updatedTimelessAccount = function (timelessAccount) {
        var account = _.findIndex(self.timelessAccounts, _.pick(timelessAccount, 'id'));
        if (account !== -1) {
            self.timelessAccounts.splice(account, 1, timelessAccount);
            self.setSelectedTimelessAccount(timelessAccount);
        }
        self.timelessAccountsPieChart.series[0].setData(self.getDataForTimelessAccountsPieChart());
    };

    self.createdTimelessAccount = function (timelessAccount) {
        self.timelessAccounts.push(timelessAccount);
        self.timelessAccountsPieChart.series[0].setData(self.getDataForTimelessAccountsPieChart());

        self.clickOnTimelessAccount(self.timelessAccounts.indexOf(timelessAccount));
    };

    self.deletedTimelessAccount = function (id) {
        self.timelessAccounts = _.filter(self.timelessAccounts, function (timelessAccount) {
            return timelessAccount.id !== id;
        });
        self.timelessAccountsPieChart.series[0].setData(self.getDataForTimelessAccountsPieChart());
    };

    self.clickOnTimelessAccount = function (index) {
        // Set the selected pie chart slice programmatically
        self.timelessAccountsPieChart.series[0].data[index].select();
    };

    self.setSelectedTimelessAccount = function (timelessAccount) {
        self.selectedTimelessAccount = self.selectedTimelessAccount === timelessAccount ? null : timelessAccount;
    };

    self.clearSelectedTimelessAccount = function (index) {
        if (self.selectedTimelessAccount.id === self.timelessAccounts[index].id) {
            self.selectedTimelessAccount = null;
        }
    };

    self.getAvailableVolumeGb = function () {
        var occupiedSpace = _.sumBy(self.timelessAccounts, 'volumeGb');
        var availableSpace = self.totalVolumeGb - occupiedSpace;
        return availableSpace;
    };

    self.isAddNewDisabled = function () {
        return self.timelessAccounts.length >= self.maxAllowedTimelessAccounts || self.getAvailableVolumeGb() <= 0;
    };

    self.isInitialState = function () {
        return self.timelessAccounts.length === 1 && self.timelessAccounts[0].volumeGb === self.totalVolumeGb;
    };

    self.addNewTimelessAccount = function () {
        self.unselectSelectedPieChartSlice();
        self.selectedTimelessAccount = new TimelessAccount();
    };

    /**
     * Programmatically clearSelectedTimelessAccount
     */
    self.cancelTimelessAccountSelection = function () {
        self.unselectSelectedPieChartSlice();
        self.selectedTimelessAccount = null;
    };

    /***
     * Unselects a selected pie chart and doesn't alter the timeless accounts data
     * @returns {boolean} - Whether the selected pie slice was selected or not
     */
    self.unselectSelectedPieChartSlice = function () {
        if (!self.selectedTimelessAccount) {
            return false;
        }

        var selectedPieSlice = _.find(self.timelessAccountsPieChart.series[0].data, {'id': self.selectedTimelessAccount.id});
        if (!selectedPieSlice) {
            return false;
        }

        selectedPieSlice.select();
        return true;
    };

    /*********************************************************************************************************
     *                                      INITIALIZATION FUNCTION                                          *
     *********************************************************************************************************/

    self.$onInit = function () {

        TimelessAccountsService.getAll()
            .then(function (timelessAccountsResponse) {
                if (timelessAccountsResponse.status !== 200) return;
                self.isLoading = false;

                var timelessAccountsObj = timelessAccountsResponse.data;
                self.maxAllowedTimelessAccounts = timelessAccountsObj.maxAllowed;
                self.totalVolumeGb = timelessAccountsObj.totalVolumeGb;
                self.timelessAccounts = timelessAccountsObj.timelessIndices.map(function (timelessAccount) {
                    return new TimelessAccount(timelessAccount);
                });

                // We must render the DOM first,
                // so we use $timeout to wait until the current stack has ended,
                // which renders the DOM.
                $timeout(self.createTimelessAccountPieChart, 0);
            });

        // Fetching the account tree in order to show a list
        // of available acconts to associate the timeless account with in the sub-section component
        Account.prototype.createAccountTree()
            .then(function (accountResponse) {
                self.account = accountResponse;
                self.accountsList = self.account.getFlatAccountList();
            });
    };
});
/* origin: public/webapp/app/dashboard/settings/timeless-accounts/timeless-accounts-card/timeless-accounts-service.js */
angular.module('webApp').service('TimelessAccountsService', function (Backend, $q) {
    var self = this;
    this.timelessAccountsUrl = '/timeless-indices';
    this.searchableAccountsUrl = '/searchable-accounts?accountType=TIMELESS_INDEX';

    this.getAll = function () {
        return Backend.GET(this.timelessAccountsUrl);
    };

    this.getAllSearchableAccounts = function () {
        return Backend.GET(this.searchableAccountsUrl);
    };

    this.get = function (timelessId) {
        return Backend.GET(this.timelessAccountsUrl + timelessId);
    };

    /***
     * Creates a new timeless account
     * @param timelessAccount - Object, consists of name: String, volumeGb: number, authorizedAccounts: Array<number>
     * @returns {* Promise } - The timeless account that was generated
     */
    this.create = function (timelessAccount) {
        var safeTimelessAccount = self._getSafeTimelessAccountObject(timelessAccount);
        return Backend.POST(this.timelessAccountsUrl, safeTimelessAccount)
            .then(function (response) {
                if (response.status >= 300) {
                    return $q.reject(response);
                }
                return response;
            });
    };

    /***
     * Updates a timeless account
     * @param timelessAccount - Object, consists of name: String, volumeGb: number, authorizedAccounts: Array<number>
     * @returns {* Promise } - A promise that resolves the timeless account that was generated
     */
    this.update = function(timelessAccount) {
        var safeTimelessAccount = self._getSafeTimelessAccountObject(timelessAccount);
        return Backend.PUT(this.timelessAccountsUrl + '/' + timelessAccount.id, safeTimelessAccount);
    };

    this.remove = function (timelessId) {
        return Backend.DELETE(this.timelessAccountsUrl + '/' + timelessId);
    };

    this._getSafeTimelessAccountObject = function (timelessAccount) {
        if (!timelessAccount || !timelessAccount.name || !_.isNumber(timelessAccount.volumeGb) || timelessAccount.volumeGb <= 0) return;

        var authorizedAccounts = timelessAccount.getAuthorizedAccounts();
        var safeTimelessAccountObject = _.pick(timelessAccount, ['name', 'volumeGb']);

        // if no permitted accounts were provided, we apply a blank array
        safeTimelessAccountObject.authorizedAccounts = authorizedAccounts;

        return safeTimelessAccountObject;
    };
});
/* origin: public/webapp/app/dashboard/settings/usage-and-billing/usage-and-billing.js */
/* eslint-disable */
angular.module('webApp').controller('UsageAndBillingSettingsController', function ($scope, $state, $stateParams, PlanPricingService, UserService, AuthService, UpgradeService, enums, AccountService, AnalyticsService) {

    // GENERAL STUFF //

    var userInfoPromise = UserService.getSummary().then(function(res) {
        var userSummary = res.data;
        $scope.userEmail = userSummary.username;
        if (userSummary.fullName && userSummary.fullName.indexOf(' ') > 0) {
            var splitName = userSummary.fullName.split(' ');
            $scope.userFirstName = splitName[0];
            $scope.userLastName = userSummary.fullName.substr(splitName[0].length);
        }

        $scope.isSubAccount = userSummary.subAccount;
    });

    $scope.friendlyPrice = function() {
        if (!$scope.totalPrice) return '';
        if ($scope.chosenBillingOption === 'monthly')
            return '$' + LogzIO.Strings.FriendlyPrice($scope.totalPrice);
        return '$' + LogzIO.Strings.FriendlyPrice($scope.totalPrice / 12);
    };


    // BILLING //

    //var contractUrl = 'https://sandbox.bluesnap.com/jsp/buynow.jsp?contractId=2263977';
    var contractUrl = 'https://www.bluesnap.com/jsp/buynow.jsp?contractId=';

    // check if we got a custom contract id
    if ($stateParams.contractId) {
        $scope.customContractId = $stateParams.contractId;
        $scope.customMaxVolume = $stateParams.maxVolume;
        $scope.customRetention = $stateParams.retention;
        $scope.customPlanTypeId = $stateParams.planTypeId;
        $scope.customContractUrl = contractUrl + $scope.customContractId + '&currency=USD' +
            '&custom1=' + $scope.customRetention + '&custom2=' + $scope.customMaxVolume + '&custom3=' + $scope.customPlanTypeId;
    }

    UpgradeService.getPlanDetails().then(function(planDetails) {
        if (!planDetails.data || !planDetails.data.planType) return;
        planDetails = planDetails.data;
        $scope.planType = planDetails.planType.toLowerCase();
        $scope.isFreePlan = $scope.planType == 'free';
        $scope.isTrialPlan = planDetails.planType.toLowerCase() == 'trial';
        $scope.currentPlan = $scope.planType;
        $scope.displayPlansSection = $scope.currentPlan == 'free' || $scope.currentPlan == 'trial';

        if (planDetails.endDate) {
            var endDate = new Date(planDetails.endDate);
            var now = new Date();
            $scope.expireDays = Math.round((endDate - now) / (1000 * 60 * 60 * 24));
        }
    });

    AccountService.getSubAccounts().then(function (res) {
        $scope.totalDailyGb = 0;

        _.forEach(res, function (subAccountData) {
            $scope.totalDailyGb += subAccountData.account.maxDailyGB;
        })

        calculateIfVolumeFitsSubAccounts();
    });

    var loadDailyVolumes = function(planType) {
        PlanPricingService.getVolumeSizes(planType).then(function(sizes) {
            $scope.volumeSizes = _.uniq(sizes).map(function(size) { return {size:size + ' GB'}; });
            $scope.chosenVolumeSize = $scope.volumeSizes[0];
        });
    };

    var calculateIfVolumeFitsSubAccounts = function () {
        var size = _.get($scope.chosenVolumeSize, 'size');
        if (size === undefined || $scope.totalDailyGb === undefined) return;

        $scope.volumeDoesntFit = parseInt($scope.chosenVolumeSize.size.split(' ')[0]) < $scope.totalDailyGb;
    };

    $scope.$watch('chosenVolumeSize', function(chosenSize) {
        if (!chosenSize) return;

        calculateIfVolumeFitsSubAccounts();

        PlanPricingService.getRetentionSizes($scope.chosenPlan, chosenSize.size.split(' ')[0]).then(function(sizes) {
            $scope.retentionSizes = sizes.map(function(size) { return {size:size + ' days'}; });
            $scope.chosenRetentionSize = $scope.retentionSizes[0];
        });
    });

    var updatePlanPrice = function() {
        userInfoPromise.then(function() {

            var chosenVolumeSize = $scope.chosenVolumeSize.size.split(' ')[0];
            var chosenRetentionSize = $scope.chosenRetentionSize.size.split(' ')[0];

            PlanPricingService.getPlanDetails($scope.chosenPlan, chosenVolumeSize, chosenRetentionSize).then(function(planDetails) {
                $scope.totalPrice = $scope.chosenBillingOption === 'monthly' ? planDetails.monthlyPrice : planDetails.annualPrice;
                var contractId = $scope.chosenBillingOption === 'monthly' ? planDetails.contractId : planDetails.annualContractId;
                $scope.contractUrl = contractUrl + contractId + '&currency=USD';
                if ($scope.userEmail)
                    $scope.contractUrl += '&email=' + encodeURIComponent($scope.userEmail);
                if ($scope.userFirstName && $scope.userLastName)
                    $scope.contractUrl += '&firstName=' + encodeURIComponent($scope.userFirstName) + '&lastName=' + encodeURIComponent($scope.userLastName);

                // custom1 = Retention
                // custom2 = MaxVolume
                // custom3 = PlanType
                //var planTypes = {2:'STANDARD', 3:'PRO'};
                $scope.contractUrl += '&custom1=' + encodeURIComponent(chosenRetentionSize) + '&custom2=' + encodeURIComponent(chosenVolumeSize) + '&custom3=' + planDetails.planTypeId;
            });
        });
    };

    $scope.$watch('chosenRetentionSize', function(chosenSize) {
        if (!chosenSize) return;
        updatePlanPrice();
    });


    $scope.chosenBillingOption = 'annually';

    $scope.chosenPlan = 'pro';
    $scope.choosePlan = function(chosenPlan) {
        $scope.chosenPlan = chosenPlan;
        loadDailyVolumes(chosenPlan);
    };
    $scope.choosePlan('pro');

    $scope.selectBillingOption = function(billingOption) {
        $scope.chosenBillingOption = billingOption;
        updatePlanPrice();
    };

    $scope.displayPlans = function() {
        $scope.displayPlansSection = true;
        AnalyticsService.report('upgrade-your-plan', { event: 'click', location: 'billing-page' });
    };


    // USAGE GRAPH //

    UserService.getUsage().then(function (usage) {
        usage.sort(function(a, b) {
            return a.date - b.date;
        });

        var values = [];
        angular.forEach(usage, function (value) {
            values.push([value.date, normalizeSize(value.bytes)]);
        });

        $scope.usageData = [{
            "key": "Daily Data Usage",
            "values": values
        }];

        if (values.length > 0) {
            $scope.avgDailyUsage = _.reduce(values, function(sum, val, i, arr) {
                return sum + val[1] / arr.length;
            }, 0).toFixed(2);
        }

        if (usage && usage.length)
            $scope.datesRange = d3.time.format('%d/%m')(new Date(usage[0].date)) + ' - ' + d3.time.format('%d/%m')(new Date(usage[usage.length-1].date));
    });
    $scope.xAxisTickFormatFunction = function () {
        return function (d) {
            return d3.time.format('%d/%m')(new Date(d)); //uncomment for date format
        };
    };
    $scope.yAxisTickFormatFunction = function () {
        return d3.format(',.2f');
    };
    function normalizeSize(size) {
        var sizeInGigaBytes = size / 1024 / 1024 / 1024;
        var shortened = sizeInGigaBytes.toFixed(2);
        if (shortened * 10 / shortened == 1)
            return parseFloat('' + shortened + '0');
        return parseFloat(shortened);
    }
    $scope.getGraphColor = function() {
        return '#b0d6ec';
    };



    // TYPE USAGE GRAPH //

    $scope.totalCount = 0;
    UserService.getUsageByType().then(function(usageByType) {
        var typeUsageData = [];
        for (var type in usageByType) {
            if (!usageByType.hasOwnProperty(type))
                return;

            typeUsageData.push({key: type, y: usageByType[type]});
            $scope.totalCount += usageByType[type];
        }

        $scope.typeUsageData = typeUsageData;
    });
    $scope.typeUsageXFunction = function() {
        return function(d) { return d.key; };
    };
    $scope.typeUsageYFunction = function() {
        return function(d) {
            return parseInt((d.y / $scope.totalCount) * 100);
        };
    };
    $scope.typeUsageYFormatFunction = function() {
        return function (key, y, e, graph) {
            return '<h3>' + key + '</h3>' +
                '<p>' + parseInt(y) + ' % </p>';
        };
    };

    $scope.goToSubAccounts = function () {
        $state.go('dashboard.settings.manage-accounts');
    };

    (function() {
        var fromDate = LogzIO.Dates.addDays(-7);
        var now = new Date(Date.now());
        var range = fromDate.getDate() + '/' + (fromDate.getMonth() + 1) + ' - ' + now.getDate() + '/' + (now.getMonth() + 1);
        $scope.typeUsageDateRange = range;
    })();
});
/* eslint-enable */
/* origin: public/webapp/app/dashboard/welcome/logz-welcome-congrats.js */
angular.module('webApp').directive('logzWelcomeCongrats', function($state) {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/welcome/logz-welcome-congrats.html',
        scope: {
            welcomeFlow: '='
        },
        link: function(scope) {
            scope.start = function() {
                $state.go('dashboard.dataSources');
            };
        }
    };
});
/* origin: public/webapp/app/dashboard/welcome/logz-welcome-how-it-works.js */
angular.module('webApp').directive('logzWelcomeHowItWorks', [function() {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/welcome/logz-welcome-how-it-works.html',
        scope: {
            welcomeFlow: '='
        }
    };
}]);
/* origin: public/webapp/app/dashboard/welcome/logz-welcome-questions.js */
angular.module('webApp').directive('logzWelcomeQuestions', [function() {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/welcome/logz-welcome-questions.html',
        scope: {
            flow: '='
        }
    };
}]);
/* origin: public/webapp/app/dashboard/welcome/logz-welcome-technologies.js */
angular.module('webApp').directive('logzWelcomeTechnologies', [function() {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/welcome/logz-welcome-technologies.html',
        scope: {
            flow: '='
        },
        link: function(scope) {
            scope.toggleTechnology = function(use) {
                var list = scope.flow.technologies === '' ? [] : scope.flow.technologies.split(',');
                if (list.indexOf(use) >= 0) {
                    _.remove(list, function(u) { return u === use; });
                    scope.flow.technologies = list.join(',');
                }
                else {
                    list.push(use);
                    scope.flow.technologies = list.join(',');
                }
            };

            scope.selectedTechnology = function(technology) {
                if (!scope.flow || !scope.flow.technologies || scope.flow.technologies.length === 0)
                    return false;

                var list = scope.flow.technologies.split(',');
                return list.indexOf(technology) >= 0;
            };
        }
    };
}]);
/* origin: public/webapp/app/dashboard/welcome/logz-welcome-use-cases.js */
angular.module('webApp').directive('logzWelcomeUseCases', [function () {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/welcome/logz-welcome-use-cases.html',
        scope: {
            flow: '='
        },
        link: function (scope) {

            scope.useCasesLeft = [{
                name: 'IT Operations',
                text: 'Find operational problems faster by searching through your aggregated and consolidated logs. Be proactive by defining alerts.',
                id: 'it',
                using: false
            }, {
                name: 'Business Intelligence',
                text: 'If you are a data-driven organization, Logz.io gives you near real-time anaytics capabilities leveraging the many visualizations that exist in Kibana 4.',
                id: 'bi',
                using: false
            }, {
                name: 'Security and Compliance',
                text: 'With archiving capabilities and the ability to create compliance dashboards, you can satisfy all your compliance needs.',
                id: 'security',
                using: false
            }];
            scope.useCasesRight = [{
                name: 'Web Analytics',
                text: 'Automatically detect the profile of the user and the geo location that your visitors are coming from. Get near real-time analytics using Kibana 4 visualizations.',
                id: 'analytics',
                using: false
            }, {
                name: 'DevOps',
                text: 'Give your developers real-time access to your production logs in a safe and secure way, allowing them to address issues faster.',
                id: 'devops',
                using: false
            }, {
                name: 'Other',
                text: 'Logz.io and the ELK stack is a fully customizable solution. Send any type of data and leverage the power of the ELK stack.',
                id: 'other',
                using: false
            }];
            scope.changeUseCases = function () {
                var useCasesArray = [];
                _.forEach(_.concat(scope.useCasesLeft, scope.useCasesRight), function (useCase) {
                    if (useCase.using) {
                        useCasesArray.push(useCase.id);
                    }
                });
                scope.flow.useCases = useCasesArray.join(',');
            };
        }
    };
}]);
/* origin: public/webapp/app/dashboard/welcome/logz-welcome-using-today.js */
angular.module('webApp').directive('logzWelcomeUsingToday', [function () {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/welcome/logz-welcome-using-today.html',
        scope: {
            flow: '='
        },
        link: function (scope) {
            scope.cloudProviders = [{
                name: 'Amazon EC2',
                id: 'ec2',
                label: 'ec2',
                using: false
            }, {
                name: 'Google Cloud',
                id: 'google-cloud',
                label: 'google-cloud',
                using: false
            }, {
                name: 'Microsoft Azure',
                id: 'azure',
                label: 'azure',
                using: false
            }, {
                name: 'Heroku',
                id: 'heroku',
                label: 'heroku',
                using: false
            }, {
                name: 'On premise',
                id: 'on-premise',
                label: 'on-premise',
                using: false
            }, {
                name: 'Other cloud provider',
                id: 'other-cloud-provider',
                label: 'other',
                using: false,
                other: ''
            }];

            scope.changeProviders = function () {
                var providersArray = [];
                _.forEach(scope.cloudProviders, function (provider) {
                    if (provider.using && provider.label === 'other' && scope.otherText) {
                        providersArray.push('other:' + scope.otherText);
                        return;
                    }
                    if (provider.using) {
                        providersArray.push(provider.label);
                    }
                });
                scope.flow.currentCloudProvider = providersArray.join(',');
            };
        }
    };
}]);
/* origin: public/webapp/app/dashboard/welcome/welcome-flow-progress.js */
angular.module('webApp').directive('welcomeFlowProgress', [function() {
    return {
        restrict: 'E',
        templateUrl: 'app/dashboard/welcome/welcome-flow-progress.html',
        scope: {
            activeStep: '='
        }
    };
}]);
/* origin: public/webapp/app/dashboard/welcome/welcome-flow.js */
angular.module('webApp').controller('WelcomeFlowController', function($scope, $state, MarketoService, AccountService, Backend) {

    AccountService.getAccountSettings().then(function(accountSettings) {
        var settings = angular.fromJson(accountSettings);

        if (settings.welcomeFlowCurrentStep === 4)
            $state.go('dashboard.kibana');

        $scope.welcomeFlow = {
            finished: false,
            currentStep: settings.welcomeFlowCurrentStep,
            useCases: '',
            currentLogAnalytics: '',
            currentCloudProvider: '',
            technologies: ''
        };

        MarketoService.associateLead({
            'Use_Cases__c': $scope.welcomeFlow.useCases,
            'Current_Cloud_Provider__c': $scope.welcomeFlow.currentCloudProvider,
            'Current_Log_Analytics__c': $scope.welcomeFlow.currentLogAnalytics,
            'Technologies__c': $scope.welcomeFlow.technologies
        });
    });

    $scope.next = function() {
        $scope.welcomeFlow.currentStep++;

        Backend.POST('/welcome-flow', $scope.welcomeFlow).then(function() {

            MarketoService.associateLead({
                'Use_Cases__c': $scope.welcomeFlow.useCases,
                'Current_Cloud_Provider__c': $scope.welcomeFlow.currentCloudProvider,
                'Current_Log_Analytics__c': $scope.welcomeFlow.currentLogAnalytics,
                'Technologies__c': $scope.welcomeFlow.technologies
            });

            if ($scope.welcomeFlow.currentStep > 4)
                $state.go('dashboard.kibana');
        });
    };
    $scope.back = function() {
        $scope.welcomeFlow.currentStep--;
        Backend.POST('/welcome-flow', $scope.welcomeFlow);
    };

    $scope.later = function() {
        $state.go('dashboard.dataSources');
    };

});
/* origin: public/webapp/app/labs/contribute-object-controller.js */
angular.module('webApp').controller('ContributeObjectController', function($q, $scope, $timeout, ngDialog, Backend, AuthService, LabsService, AnalyticsService, AccountService) {

    $q.all([
        AuthService.getUser(),
        AccountService.getAccountLogTypes()
    ]).then(function (res) {
        $scope.accountId = res[0].data.accountId;
        $scope.products = res[1];
    });

    $scope.isAdmin = AuthService.isAuthenticated() && AuthService.isAdmin();

    if ($scope.isAdmin) {
        var randomVotes = Math.floor(Math.random() * (100 - 0));
        var randomInstalls = Math.floor(Math.random() * (60 - 0));
        $scope.ngDialogData.labsObject.numVotes = randomVotes;
        $scope.ngDialogData.labsObject.numInstallations = randomInstalls;
    }

    $scope.nameMaxLength = 50;
    $scope.nameRegex = [ '.{0,', $scope.nameMaxLength, '}' ].join('');

    $scope.descriptionMaxLength = 1000;
    $scope.descriptionRegex = [ '.{0,', $scope.descriptionMaxLength, '}' ].join('');

    $scope.publishing = false;
    $scope.publish = function() {
        $scope.contributeForm['ngDialogData.labsObject.logType'].$setTouched();

        if ($scope.contributeForm.$invalid) {
            return;
        }

        if ($scope.publishing) return;
        $scope.publishing = true;

        var copiedLabsObject = _.cloneDeep($scope.ngDialogData.labsObject);
        delete copiedLabsObject.upVoted;
        if (copiedLabsObject.adminProduct) {
            copiedLabsObject.logType = copiedLabsObject.adminProduct;
            delete copiedLabsObject.adminProduct;
        }

        LabsService.contributeObject(copiedLabsObject).then(function() {
            $scope.closeThisDialog();

            AnalyticsService.report('publish-contribute', {
                category: 'contribute',
                object: JSON.stringify(copiedLabsObject)
            });

            openThankYouMessage(copiedLabsObject);
        }).finally(function() {
            $scope.publishing = false;
        });
    };

    var openThankYouMessage = function(labObject) {
        ngDialog.open({
            template: 'app/labs/thank-you-dialog.html',
            controller: [function() { }],
            width: '515px',
            data: { labsObject:labObject },
            closeByEscape: true,
            showClose: false
        });
    };
});
/* origin: public/webapp/app/labs/hide-overflow.js */
angular.module('webApp').directive('hideOverflow', [function() {
    return {
        restrict: 'A',
        link: function(scope, element) {

            var moreLink = undefined;

            var checkOverflow = function() {
                var isOverflowing = element[0].scrollHeight > element[0].clientHeight;

                if (isOverflowing) {
                    if (moreLink) return;
                    moreLink = angular.element('<span>see more</span>').addClass('more-link');
                    moreLink.on('click', function() {
                        element.css('overflow', 'auto').css('max-height', 'none');
                        moreLink.addClass('ng-hide');
                    });
                    element.append(moreLink);
                }
                else {
                    if (!moreLink) return;
                    moreLink.remove();
                    moreLink = undefined;
                }
            };
            checkOverflow();

            var watcher = scope.$watch(function() {
                return element[0].innerHTML;
            }, checkOverflow);

            scope.$on('$destroy', function() {
                if (watcher) watcher();
                if (moreLink) moreLink.unbind();
            });
        }
    };
}]);
/* origin: public/webapp/app/labs/labs-add-button.js */
angular.module('webApp').directive('labsAddButton', function($rootScope, ElasticSearchService, $state, Backend, ngDialog, $timeout, AccountService, AuthService, AnalyticsService, UserTokensService) {

    var html = '<div class="add-button labs-button" ng-class="{\'clickable\':!loading, \'loading\':loading, \'preview\':previewMode}" ng-click="act()">' +
        '<span ng-show="!loading && !added">Install</span>' +
        '<span ng-show="loading"><i class="fa fa-spinner fa-spin"></i></span>' +
        '<span ng-show="added">Open</span>' +
        '</div>';

    var typeToOpen = {
        search: '/discover/',
        visualization: '/visualize/edit/',
        dashboard: '/dashboard/'
    };

    return {
        restrict: 'E',
        template: html,
        scope: {
            loading: '=?',
            added: '=?',
            previewMode: '@?'
        },
        link: function(scope, element, attrs) {
            var objectId = attrs['objectId'];
            var objectType = attrs['objectType'];
            var logType = attrs['logType'];

            var isAuthenticated = AuthService.isAuthenticated();

            if (isAuthenticated) {
                AccountService.getAccountLogTypes().then(function(data) {
                    scope.userLogTypes = data;
                });
            }

            scope.act = function() {
                if (!scope.loading && !scope.added)
                    return scope.addObject();
                else if (scope.added)
                    return scope.openObject();
            };

            scope.addObject = function() {
                if (scope.previewMode) return;

                if (scope.loading) return;
                scope.loading = true;

                if (isAuthenticated) {
                    if (!_.find(scope.userLogTypes, function(userLogType) { return userLogType === logType; })) {
                        ngDialog.open({
                            template: 'app/labs/ship-logs-dialog.html',
                            controller: ['$scope', function($scope) {
                                $scope.continue = function() {
                                    $scope.closeThisDialog();
                                    installObject();
                                };
                                $scope.shipLogs = function() {
                                    $scope.closeThisDialog();
                                    $state.go('dashboard.dataSources');
                                };
                            }],
                            data: {objectType: objectType},
                            width: '500px',
                            closeByEscape: true,
                            showClose: false
                        });

                        $timeout(function() {
                            scope.loading = false;
                        }, 1000);
                        return;
                    }

                    $rootScope.$emit('Labs_InstallInteraction');
                    installObject();
                }
                else {
                    ngDialog.open({
                        template: 'app/outer/register/registration-dialog.html',
                        controller: 'RegistrationDialogController',
                        width: '586px',
                        closeByEscape: true,
                        showClose: false
                    });
                    scope.loading = false;
                }
            };

            var installObject = function(override) {
                scope.loading = true;

                override = override || 'STOP_ON_CONFLICT';

                // this is a hack to make it look like we're doing heavy work :)
                scope.fakeWait = true;
                var fakePromise = $timeout(function() {
                    scope.fakeWait = false;
                }, 3500);

                Backend.POST('/labs/install', {id: objectId, overrideStrategy: override}).then(function() {

                    ElasticSearchService.refreshMapping('install app', 'ELK Apps');

                    fakePromise.then(function() {
                        scope.added = true;
                        scope.loading = false;
                    });
                }).catch(function(err) {
                    if (err.status === 409) {
                        ngDialog.open({
                            template: 'app/labs/apps-override-dialog.html',
                            controller: ['$scope', function($scope) {
                                $scope.installObject = function(action) {
                                    $scope.closeThisDialog();
                                    installObject(action);
                                };
                            }],
                            data: {objectType: objectType},
                            width: '500px',
                            closeByEscape: true,
                            showClose: false
                        });
                    }

                    fakePromise.then(function() {
                        scope.loading = false;
                    });
                });

                AnalyticsService.report('apps', {
                    event: 'install',
                    appId: objectId
                });
            };

            scope.openObject = function() {
                if (objectType === 'alert') {
                    $state.go('dashboard.alerts.definitions');
                    return;
                }

                var indexPrefix = UserTokensService.getIndexPrefix();
                var query = {size: 1, query: { term: { _logzioOriginalAppId: objectId}}};

                Backend.POST('/kibana/elasticsearch/kibana-' + indexPrefix + '/_search', query).then(function (res) {
                    var id = res.data.hits.hits[0]._id;
                    var type = objectType.toLowerCase();
                    var route = typeToOpen[type];
                    if (!route) {
                        console.log('type: ' + type + ' is invalid type');
                        return;
                    }


                    $state.go('dashboard.kibana', {kibanaRoute: [route, id].join('')});

                });
            };
        }
    };
});

/* origin: public/webapp/app/labs/labs-block.js */
angular.module('webApp').directive('labsBlock', function($timeout, AuthService, LabsService, AccountService, ImpersonationService) {
    return {
        restrict: 'E',
        templateUrl: 'app/labs/labs-block.html',
        scope: {
            model:'=ngModel',
            contributor: '=?',
            previewMode: '=?'
        },
        link: function(scope, element) {
            var showObject = function() {
                element.find('.masonry-brick').addClass('enter-animation');
            };
            if (scope.previewMode) {
                showObject();
            }
            else {
                $timeout(showObject, 0);
            }

            scope.model.hide = false;
            scope.isAdmin = AuthService.isAdmin();
            scope.isImpersonating = ImpersonationService.isImpersonating();
            scope.objectType = scope.model.objectType.substr(0, 1) + scope.model.objectType.substr(1).toLowerCase();
            scope.model.upVoted = scope.model.upVoted || false;

            scope.isAuthenticated = AuthService.isAuthenticated();

            if (scope.isAuthenticated) {
                AccountService.getAccountLogTypes().then(function(data) {
                    scope.notSendingLogs = !_.find(data, function(logType) {
                        return logType === scope.model.logType;
                    });
                });
            }
            else {
                scope.notSendingLogs = true;
            }

            scope.loading = false;
            scope.approve = function() {
                if (!AuthService.isAdmin()) return;
                if (scope.loading) return;
                scope.loading = true;
                LabsService.approveObject(scope.model.id).then(function() {
                    scope.model.status = 'approved';
                }).finally(function() {
                    scope.loading = false;
                });
            };
            scope.reject = function() {
                if (!AuthService.isAdmin()) return;
                if (scope.loading) return;
                scope.loading = true;
                if (!confirm('Are you sure you want to reject this object ?')) {
                    scope.loading = false;
                    return;
                }
                LabsService.rejectObject(scope.model.id).then(function() {
                    scope.model.status = 'rejected';
                }).finally(function() {
                    scope.loading = false;
                });
            };

            scope.editObject = function() {
                LabsService.editObject(scope.model);
            };

            if (scope.previewMode) {
                scope.imageOptions = [
                    {type:'alert', url: 'static/contributed/alert.png'},
                    {type:'search', url: 'static/contributed/search.png'},
                    {type:'search', url: 'static/contributed/search2.png'},
                    {type:'visualization', url: 'static/contributed/visualization_table.png'},
                    {type:'visualization', url: 'static/contributed/visualization_area.png'},
                    {type:'visualization', url: 'static/contributed/visualization_columns.png'},
                    {type:'visualization', url: 'static/contributed/visualization_line.png'},
                    {type:'visualization', url: 'static/contributed/visualization_metric.png'},
                    {type:'visualization', url: 'static/contributed/visualization_pie.png'},
                    {type:'visualization', url: 'static/contributed/visualization_map.png'},
                    {type:'visualization', url: 'static/contributed/visualization_1.png'},
                    {type:'visualization', url: 'static/contributed/visualization_2.png'},
                    {type:'visualization', url: 'static/contributed/visualization_3.png'},
                    {type:'visualization', url: 'static/contributed/visualization_4.png'},
                    {type:'visualization', url: 'static/contributed/visualization_5.png'},
                    {type:'visualization', url: 'static/contributed/visualization_6.png'},
                    {type:'visualization', url: 'static/contributed/visualization_7.png'},
                    {type:'visualization', url: 'static/contributed/visualization_8.png'},
                    {type:'visualization', url: 'static/contributed/visualization_9.png'},
                    {type:'visualization', url: 'static/contributed/visualization_10.png'},
                    {type:'visualization', url: 'static/contributed/visualization_11.png'},
                    {type:'visualization', url: 'static/contributed/visualization_12.png'},
                    {type:'dashboard', url: 'static/contributed/dashboard_1.png'},
                    {type:'dashboard', url: 'static/contributed/dashboard_2.png'},
                    {type:'dashboard', url: 'static/contributed/dashboard_3.png'},
                    {type:'dashboard', url: 'static/contributed/dashboard_4.png'},
                    {type:'dashboard', url: 'static/contributed/dashboard_5.png'},
                    {type:'dashboard', url: 'static/contributed/dashboard_6.png'}
                ];
                var imageOptions = _.filter(scope.imageOptions, function(img) { return img.type === scope.model.objectType.toLowerCase(); });

                scope.allowImageChange = scope.previewMode && imageOptions && imageOptions.length > 1;

                scope.chosenImage = Math.round(Math.random() * (imageOptions.length-1));
                scope.model.imageUrl = imageOptions[scope.chosenImage].url;

                var returnModulo = function(number, modulo) {
                    return ((number % modulo) + modulo) % modulo;
                };

                scope.nextImage = function() {
                    scope.chosenImage =  returnModulo(scope.chosenImage + 1, imageOptions.length);
                    scope.model.imageUrl = imageOptions[scope.chosenImage].url;
                };
                scope.prevImage = function() {
                    scope.chosenImage = returnModulo(scope.chosenImage - 1, imageOptions.length);
                    scope.model.imageUrl = imageOptions[scope.chosenImage].url;
                };
            }

        }
    };
});
/* origin: public/webapp/app/labs/labs-controller.js */
angular.module('webApp').controller('LabsController', function($rootScope, $scope, $state, $stateParams, LabsService, AuthService, ImpersonationService) {

    var labsRetrievalSize = 21;

    $scope.isAdmin = AuthService.isAdmin();
    $scope.isImpersonating = ImpersonationService.isImpersonating();
    $scope.searchQuery = $stateParams.q || '';
    $scope.orderBy = 'mostPopular';

    $scope.isAuthenticated = AuthService.isAuthenticated();

    var getUserInteractions = null;
    var addUserInteractions = function() {
        if (!AuthService.isAuthenticated())
            return;

        if (getUserInteractions === null) {
            getUserInteractions = LabsService.getUserInteractions();
        }

        getUserInteractions.then(function(userInteractions) {
            // mark objects that were voted on
            _.forEach(userInteractions.votedObjectIds, function(voteObjectId) {
                var matchingEntity = _.find($scope.entities, function(entity) { return entity.id === voteObjectId; });
                if (matchingEntity)
                    matchingEntity.upVoted = true;
            });

            // mark installed objects
            _.forEach(userInteractions.installedObjectIds, function(installedObjectId) {
                var matchingEntity = _.find($scope.entities, function(entity) { return entity.id === installedObjectId; });
                if (matchingEntity)
                    matchingEntity.installed = !!matchingEntity;
            });
        });
    };

    var labsVoteInteractionListener = $rootScope.$on('Labs_VoteInteraction', function() {
        getUserInteractions = LabsService.getUserInteractions();
    });
    var labsInstallInteractionListener = $rootScope.$on('Labs_InstallInteraction', function() {
        getUserInteractions = LabsService.getUserInteractions();
    });

    $scope.initialLoading = true;
    $scope.userSearch = false;

    var getEntities = function (page) {
        return LabsService.getEntities($scope.searchQuery, labsRetrievalSize, labsRetrievalSize * (page || 0), $scope.orderBy, $scope.type, $scope.status);
    };

    $scope.finishedLoading = false;
    $scope.loadingMore = false;
    $scope.scrolled = function(page) {
        if ($scope.finishedLoading || $scope.loadingMore || $scope.initialLoading || $scope.searching) return false;

        $scope.loadingMore = true;

        getEntities(page).then(function(searchResults) {
            if (!searchResults.results || !searchResults.results.length) {
                $scope.finishedLoading = true;
                return true;
            }

            $scope.entities = $scope.entities.concat(searchResults.results);
            addUserInteractions();
        }).finally(function() {
            $scope.loadingMore = false;
        });

        return true;
    };

    $scope.filterSelect = function(type) {
        $scope.type = $scope.type === type ? '' : type;
        $scope.search();
    };

    $scope.orderBySelect = function(orderBy) {
        $scope.orderBy = orderBy;
        $scope.search();
    };

    $scope.searching = false;
    $scope.lastSearchQuery = '';
    $scope.lastOrderBy = $scope.orderBy;
    $scope.lastType = $scope.type = '';
    $scope.lastStatus = $scope.status = '';

    $scope.clearSearch = function() {
        $scope.searchQuery = '';
        $scope.search();
    };

    $scope.search = function() {
        if ($scope.searching || $scope.initialLoading || $scope.loadingMore || ($scope.searchQuery === $scope.lastSearchQuery && $scope.orderBy === $scope.lastOrderBy && $scope.type === $scope.lastType && $scope.status === $scope.lastStatus)) {
            return;
        }

        $scope.emptySearchResults = false;
        $scope.entities = [];
        $scope.searching = true;
        $scope.userSearch = true;
        $scope.finishedLoading = false;
        $rootScope.$emit('infinite-scroll:page-clear');

        getEntities().then(function(searchResults) {
            $scope.entities = searchResults.results;
            $scope.searching = false;
            $scope.lastSearchQuery = $scope.searchQuery;
            $scope.lastOrderBy = $scope.orderBy;
            $scope.lastType = $scope.type;
            $scope.lastStatus = $scope.status;
            $scope.emptySearchResults = !$scope.entities || !$scope.entities.length;
        }).finally(function() {
            $scope.searching = false;
            addUserInteractions();
        });
    };

    var statusWatcher = $scope.$watch('status', $scope.search);

    $scope.requesting = false;
    $scope.request = function() {
        if ($scope.requesting || !$scope.requestType ||
            $scope.requestType.trim().length <= 0 || !$scope.isAuthenticated)
            return;

        $scope.requesting = true;

        LabsService.requestType($scope.requestType).then(function() {
            alert('Your request has been sent.');
            $scope.requestType = '';
            $scope.requesting = false;
        });
    };

    $scope.$on('$destroy', function() {
        if (labsInstallInteractionListener) labsInstallInteractionListener();
        if (labsVoteInteractionListener) labsVoteInteractionListener();
        if (statusWatcher) statusWatcher();
        getUserInteractions = null;
    });

    var initialLoad = function() {
        $scope.entities = [];
        getEntities().then(function(searchResults) {
            $scope.entities = searchResults.results;
            $scope.lastSearchQuery = $scope.searchQuery;
            $scope.emptySearchResults = !$scope.entities || !$scope.entities.length;
        }).finally(function() {
            $scope.initialLoading = false;
            addUserInteractions();
        });
    };
    initialLoad();

});
/* origin: public/webapp/app/labs/labs-service.js */
angular.module('webApp').service('LabsService', function($q, Backend, AuthService, UserService, ngDialog) {

    var charsToEscape = [ '\\', '+', '-', '=', '&&', '||', '>', '<', '!', '(', ')', '{', '}', '[', ']', '^', '"', '~', '*', '?', ':', '\/' ];
    var getEscapedSearchQuery = function (query) {
        var escapedQuery = query;
        _.forEach(charsToEscape, function (char) {
            escapedQuery = escapedQuery.replace(char, [ '\\', char ].join(''));
        });

        return escapedQuery;
    };

    this.getEntities = function (query, size, from, orderBy, type, status) {
        var d = $q.defer();

        var request = {
            searchRequest: {
                q: getEscapedSearchQuery(query),
                size: size,
                from: from
            },
            orderBy: orderBy,
            type: type && type.length > 0 ? type.toUpperCase() : null,
            status: status && status.length > 0 ? status.toUpperCase() : null
        };

        Backend.POST('/labs/get-objects', request).then(function (res) {
            d.resolve(res.data);
        });

        return d.promise;
    };

    this.getUserInteractions = function() {
        var d = $q.defer();
        Backend.GET('/labs/user-interactions').then(function(res) {
            d.resolve(res.data);
        });
        return d.promise;
    };

    this.contribute = function (object) {
        UserService.getSummary().then(function (res) {
            var summary = res.data;

            ngDialog.open({
                template: 'app/labs/contribute-dialog.html',
                controller: 'ContributeObjectController',
                width: '978px',
                data: { labsObject: object, contributor: summary.accountName },
                closeByEscape: true,
                showClose: false
            });
        });
    };

    this.contributeObject = function(object) {
        return Backend.POST('/labs/contribute', object);
    };

    this.approveObject = function(id) {
        return Backend.POST('/labs/approve', { id: id });
    };
    this.rejectObject = function(id) {
        return Backend.POST('/labs/reject', { id: id });
    };

    this.editObject = function(labObject) {
        Backend.POST('/labs/get-object', { id:labObject.id }).then(function(labObject) {
            ngDialog.open({
                template: 'app/labs/edit-lab-object-dialog.html',
                controller: ['$scope', 'Backend', 'LabsService', function($scope, Backend, LabsService) {
                    $scope.save = function() {
                        LabsService.updateObject(labObject.data).then($scope.closeThisDialog);
                    };
                }],
                data: { labObject: labObject.data },
                width: '740px',
                closeByEscape: true,
                showClose: false
            });
        });
    };

    this.updateObject = function(labObject) {
        return Backend.POST('/labs/update-object', labObject);
    };

    this.requestType = function(type) {
        return Backend.POST('/apps/request', { type: type });
    };
});
/* origin: public/webapp/app/livetail/livetail-controller.js */
angular.module('webApp').controller('LivetailController', function ($scope, $timeout, $location, $element, livetailStream, windowFocus, livetailError, LogzConfig, AnalyticsService, $rootScope) {
    var maxAllowedPendingLogs = LogzConfig.livetail.maxPending;
    var maxVisibleChars = LogzConfig.livetail.maxBufferSize;

    var pendingLogsTimer;
    var sliceTimer;

    var visibleLogsQueue = [];
    var pendingLogsQueue = [];

    var displayTimestamp;

    var stream = new livetailStream(addPendingLog, addMessage, error, onStreamClose);
    $scope.isRunning = false;
    $scope.filtersSettings = {
        onStop: function () {
            addMessage('Connection terminated.\r\n');
            stream.close();
            $scope.isRunning = false;

            AnalyticsService.report('livetail:stop');
        },
        onStart: function (includeRegex, excludeRegex) {
            filtersApi.autoScrollerApi().attach();
            resetPendingLogs();
            addMessage('Requesting Live Tail access...');

            stream.openConnection(includeRegex, excludeRegex);
            $scope.isRunning = true;

            AnalyticsService.report('livetail:start', {
                includeRegex: includeRegex,
                excludeRegex: excludeRegex
            });
        },
        onClear: function () {
            visibleLogsQueue.length = 0;
            logzMark.clear();

            AnalyticsService.report('livetail:clear');
        },
        onTimestampDisplay: function (isDisplay) {
            displayTimestamp = isDisplay;
            logzMark.renderAllText();
        },
        autoScrollerSettings: {
            contentElement: $element.find('pre'),
            parentElement: $element.find('.console')
        },
        onMx: mx
    };

    var filtersApi = $scope.filtersApi = {};

    $scope.logzMarkSettings = {
        name: 'livetail',
        getText: function () {
            return visibleLogsQueue.map(getLogText).join('\r\n') + '\r\n';
        }};

    var logzMark = $scope.logzMark = {};

    $scope.debug = function () { return $location.search().debug; };
    $scope.debugData = function () {
        return 'pending: ' + pendingLogsQueue.length + ' | visible: ' + visibleLogsQueue.length
            + ' | total: ' + visibleLogsQueue.length
            + ' | focused: ' + windowFocus.isFocused
            + ' | timestamp: ' + displayTimestamp
            + ' | length: ' + getVisibleQueueCharsLength();
    };

    $scope.$on('$destroy', function() {
        if (stream)
            stream.close();
    });

    function onStreamClose() {
        resetPendingLogs();
        filtersApi.setRunning(false);
    }

    function addPendingLog(text, timestamp) {
        var log = {
            text: text,
            timestamp: timestamp
        };

        if (stream.isLive && pendingLogsQueue.length > maxAllowedPendingLogs) {
            error('6429');
            stream.close();
            return;
        }

        pendingLogsQueue.push(log);

        if (windowFocus.isFocused) {
            slicer();
        }
        else {
            shiftPendingLog(true);
            sliceIfNeeded();
            return;
        }

        if (!pendingLogsTimer) {
            pendingLogsTimer = $timeout(shiftPendingLog, 20);
        }
    }

    function addMessage(text) {
        visibleLogsQueue.push({text: text});
        append(text);
    }

    function shiftPendingLog(supressTimer) {
        if (!stream.isLive || pendingLogsQueue.length === 0) {
            pendingLogsTimer = null;
            return;
        }

        //array shifting is expensive, and we might move to an
        //external queue library, but for now it's pretty meaningless
        var log = pendingLogsQueue.shift();
        visibleLogsQueue.push(log);
        append(getLogText(log));

        if (!supressTimer)
            pendingLogsTimer = $timeout(shiftPendingLog, 20);
    }

    function slicer() {
        if (!sliceTimer)
            $timeout(sliceIfNeeded, 200);
    }

    function sliceIfNeeded() {
        if (stream.isLive && getVisibleQueueCharsLength() > maxVisibleChars) {
            visibleLogsQueue = visibleLogsQueue.slice(visibleLogsQueue.length / 4);
            visibleLogsQueue.unshift({text: '(Truncated previous logs)'});
            logzMark.renderAllText();
        }

        sliceTimer = null;
    }

    function error(errorCode, defaultCode) {
        addMessage('Error: ' + livetailError.getErrorMessage(errorCode, defaultCode) + '\r\n');
        $scope.isRunning = false;
    }

    function append(text) {
        logzMark.appendLine(text);
        filtersApi.autoScrollerApi().scrollIfAttached();
    }

    function resetPendingLogs() {
        pendingLogsQueue = [];
        $timeout.cancel(pendingLogsTimer);
        pendingLogsTimer = null;
    }

    function getLogText(log) {
        return (displayTimestamp && log.timestamp ? log.timestamp + ' ' : '') + log.text;
    }

    function getVisibleQueueCharsLength() {
        return visibleLogsQueue
            .map(function (x) {
                if (x && x.text)
                    return x.text.length;
                return 0;
            })
            .reduce(function (a, b) {
                return a + b;
            }, 0);
    }


    var mxi, mxx, mxy;
    function mx() {
        if (mxi || mxx || mxy) {
            closeMx();
            return;
        }
        AnalyticsService.report('livetail:matrix');

        var width = Math.floor($element.find('pre').width() / 9);
        var act = [];
        mxi = setInterval(x, 20);
        stream.close();
        logzMark.clear();
        mxx = setTimeout(function() {
            clearInterval(mxi);

            for (var ii=0;ii<60;ii++) {
                var logz = _.concat(_.fill(Array(ii % 11), ' '), _.fill(Array(50), 'logz.io   ')).join('').slice(0, width);
                append(logz);
            }

            mxy = setTimeout(function() {
                closeMx();
                append('Congratulations. You got out of The Matrix.');
            }, 5000);
        }, 15000);
        $rootScope.additionalContainerClasses.push('mx');
        function x() {

            if (_.random(0, 100) > 50) {
                var amount = _.random(1, 2);
                for (var j=0; j<amount;j++) {
                    var location = _.random(0, width - 1);
                    if (act[location])
                        continue;

                    act[location] = _.random(20, 30);
                }
            }

            var str = '';
            for (var i =0; i < width;i++) {
                if (act[i]) {
                    act[i]--;
                    str += makeid();
                }
                else {
                    str += ' ';
                }
            }
            append(str);
        }

        function makeid() {
            var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-=+_~';
            return possible.charAt(Math.floor(Math.random() * possible.length));
        }
    }

    function closeMx() {
        clearInterval(mxi);
        clearTimeout(mxx);
        clearTimeout(mxy);
        mxi = mxx = mxy = null;
        logzMark.clear();
        _.pull($rootScope.additionalContainerClasses, 'mx');
    }
});

/* origin: public/webapp/app/livetail/livetail-errors-service.js */
angular.module('webApp').factory('livetailError', function() {

    var errors = {
        //Token request failures
        '6402': 'You\'re currently not allowed to create new Live Tail sessions.',
        '6403': 'You\'ve exceeded the number of allowed Live Tail sessions. If you want to run more sessions simultaneously please upgrade your account',
        '6500': 'Failed to connect to the server, please wait a few minutes and try again.',
        '6000': '~6500',
        '4221': 'Your "match" regex is invalid.',
        '4222': 'Your "ignore" regex is invalid.',

        //Pending logs full
        '6429': 'The amount of logs you\'ve asked to tail is too large, please refine your filter.',

        '6100': 'Couldn\'t start a Live Tail session. Please try again later or contact support.',
        '6400': 'The Live Tail session ended unexpectedly.',
        '6140': '~6400',

        '4000': 'The Live Tail session has expired. You can restart it at any time by clicking the play button.',
        '4001': '~6429',
        '4002': 'Your connection is too slow and can\'t catch up with the amount of logs you have filtered.',

        //timeouts
        '1001': '~4000',
        '1006': '~4000'
    };

    Object.keys(errors)
        .filter(function(key) { return errors[key].startsWith('~'); })
        .forEach(function(key) { errors[key] = errors[errors[key].slice(1)]; });

    return {
        getErrorMessage: function(errorCode, defaultErrorCode) {
            console.log('error: ' + errorCode + ', ' + defaultErrorCode);

            if (errorCode)
                errorCode = errorCode.toString();

            if (defaultErrorCode)
                defaultErrorCode = defaultErrorCode.toString();

            var errorMessage;

            if (errors.hasOwnProperty(errorCode))
                errorMessage = errors[errorCode];
            else if (defaultErrorCode && errors.hasOwnProperty(defaultErrorCode))
                errorMessage = errors[defaultErrorCode];
            else
                errorMessage ='An unknown error occurred. Please try again or contact our support.';

            errorMessage = errorMessage + ' [' + (errorCode || defaultErrorCode || '') + ']';

            if (typeof ga === 'function')
                ga('send', 'exception', { exDescription: errorMessage, exFatal: false });

            return errorMessage;
        }
    };
});
/* origin: public/webapp/app/livetail/livetail-filters.js */
angular.module('webApp').directive('livetailFilters', function (gabby) {
    return {
        restrict: 'E',
        templateUrl: 'app/livetail/livetail-filters.html',
        scope: gabby.scope(),
        controller: 'livetailFiltersController'
    };
}).controller('livetailFiltersController', function ($scope, logzSearchTerms, ColorService, gabby, $rootScope, hotkeys, $element, localStorageService, Logger, AnalyticsService, $timeout) {
    gabby.for($scope)
        .settings({
            onTimestampDisplay: function () { },
            onStart: function () { },
            onStop: function () { },
            onClear: function () { },
            autoScrollerSettings: {}
        })
        .api({
            setRunning: function(isRunning) {
                $scope.isRunning = isRunning;
            },
            autoScrollerApi: function() { return $scope.autoScroller; }
        });

    $scope.showSettings = false;
    var showSettingsWatch = $scope.$watch('showSettings', function() {
        if ($scope.showSettings)
            focusHighlights();
    });

    $scope.isRunning = false;
    $scope.displayTimestamp = true;

    var timestampWatch = $scope.$watch('displayTimestamp', function () {
        $scope.onTimestampDisplay($scope.displayTimestamp);
    });
    var themeCacheKey = 'livetail-theme';

    $scope.theme = localStorageService.get(themeCacheKey) || { lightMode: false };
    $scope.lightMode = function () { $scope.theme.lightMode = true; };

    $scope.darkMode = function () { $scope.theme.lightMode = false; };
    $scope.isFindOpen = (window.innerWidth > 1390);

    $scope.toggleFind = function() {
        $scope.isFindOpen = !$scope.isFindOpen;
    };
    var lightModeWatch = $scope.$watch('theme.lightMode', function () {
        var classes = $rootScope.additionalContainerClasses;
        var themeClass = 'light-theme';
        if ($scope.theme.lightMode) {
            classes.push(themeClass);
        }
        else {
            _.pull(classes, themeClass);
        }
        localStorageService.set(themeCacheKey, $scope.theme);
    });

    $scope.getHighlights = function () {
        return (logzSearchTerms.terms['livetail'] || [])
            .filter(function (x) { return !x.isQuery; });
    };

    $scope.highlightsInputKey = function (event) {
        if (event.keyCode !== 13)
            return;

        if (!$scope.highlightInput)
            return; //some error

        addHighlight($scope.highlightInput.toLowerCase());
    };

    $scope.removeHighlight = function (highlight) {
        logzSearchTerms.removeTerm('livetail', highlight);
        focusHighlights();
    };

    $scope.startOnEnter = function (event) {
        if (event.keyCode === 13) {
            $scope.start();
        }
    };

    var stopStartTimeout;
    $scope.start = function () {
        if (stopStartTimeout)
            return;

        if ($scope.isRunning) {
            $scope.stop();
            stopStartTimeout = $timeout(function () {
                stopStartTimeout = null;
                $scope.start();
            }, 700);
            return;
        }

        $scope.isRunning = true;
        $scope.onStart($scope.includeRegex, $scope.excludeRegex);
    };

    $scope.stop = function () {
        $scope.isRunning = false;
        $scope.onStop();
    };

    $scope.clear = function() { $scope.onClear(); };

    $scope.$on('$destroy', function() {
        timestampWatch();
        lightModeWatch();
        showSettingsWatch();
    });

    setHotkeys();

    function setHotkeys() {
        var allowIn = ['INPUT', 'SELECT', 'TEXTAREA'];
        var base = 'ctrl+alt+';
        hotkeys.bindTo($scope)
            .add({combo: base + 's', description: 'Start a new Live Tail connection', callback: $scope.start, allowIn: allowIn})
            .add({combo: base + 'z', description: 'Stop the current Live Tail connection', callback: $scope.stop, allowIn: allowIn})
            .add({combo: base + 'x', description: 'Clear the output window', callback: $scope.clear, allowIn: allowIn})
            .add({combo: base + 't', description: 'Toggle settings', callback: function() { $scope.showSettings = !$scope.showSettings; }, allowIn: allowIn})
            .add({combo: base + 'a', description: 'Toggle scroll-to-bottom', callback: function(){ $scope.autoScroller.toggle();}, allowIn: allowIn })
            .add({combo: base + 'h', description: 'Toggle light and dark themes', callback: function(){  $scope.theme.lightMode  = !$scope.theme.lightMode;}, allowIn: allowIn })
            .add({combo: base + 'm', description: 'Enter The Matrix', callback: function(){  $scope.onMx();}, allowIn: allowIn });
        $scope.toggleHotkeysCheatSheet = hotkeys.toggleCheatSheet;
    }

    function addHighlight(highlightText) {
        if (_.find(logzSearchTerms.terms['livetail'], ['text', highlightText]))
            return; //some error

        var id = 0;
        do {
            id++;
        } while (_.find(logzSearchTerms.terms['livetail'], ['id', id.toString()]));


        var color = ColorService.colorScheme[id - 1];
        var rgba = ColorService.convertHexToRgba(color, '0.5');

        logzSearchTerms.addTerm('livetail', {
            text: highlightText,
            id: id.toString(),
            class: 'highlight-' + id,
            style: 'background-color: ' + rgba + ';'
        });

        $scope.highlightInput = '';

        AnalyticsService.report('livetail:add-highlight', { term: highlightText });
    }

    function focusHighlights() {
        $element.find('.highlights .filter-input').focus();
    }
});

/* origin: public/webapp/app/livetail/livetail-stream-service.js */
angular.module('webApp').factory('livetailStream', function (Backend, CookiesService, AnalyticsService, $websocket, Logger) {
    var service = function (logHandler, messageHandler, errorHandler, onClose) {
        this.logHandler = logHandler;
        this.messageHandler = messageHandler;
        this.errorHandler = errorHandler;
        this.onClose = onClose;

        this.websocket = null;
        this.isLive = false;
    };

    service.prototype.openConnection = function (includeRegex, excludeRegex) {
        var self = this;
        self.close();
        var data = [];
        self.applyFilter(data, includeRegex, 'INCLUDE');
        self.applyFilter(data, excludeRegex, 'EXCLUDE');
        self.isLive = true;
        return Backend.POST('/live-tail', data).then(function (data) {
            if (!self.isLive)
                return;

            var token = data.data.token;
            self.messageHandler('Access granted. Opening connection...');
            CookiesService.setCookie('logzio-live-tail-token', token, true);

            try {
                self.websocket = $websocket(data.data.url);
                self.websocket.onMessage(function (env) {
                    if (!self.isLive)
                        return;

                    JSON.parse(env.data).forEach(function (line) {
                        var timestamp = line.timestamp && typeof line.timestamp === 'string'
                            ? line.timestamp.replace('T', ' ') + ' '
                            : '[INVALID TIMESTAMP]';

                        self.logHandler(line.message, timestamp);
                    });
                });
                self.websocket.onError(function (event) {
                    console.log('socket error', event);
                    self.close((event && event.code) || '6400');
                });
                self.websocket.onClose(function (event) {
                    console.log('socket closing', event);
                    self.close((event && event.code) || '6140');
                });
                self.messageHandler('Connected. Tailing...');
            }
            catch (error) {
                self.errorHandler('6100');
            }
        }, function(errorResponse) {
            var statusCode = errorResponse.status;
            var errorData = errorResponse.data;
            Logger.log('token request error', errorData, statusCode);

            if (errorData && errorData.code)
                self.close(errorData.code);
            else if (statusCode === 402)
                self.close('6402');
            else if (statusCode === 500)
                self.close('6500');
            else
                self.close('6000');

            AnalyticsService.report('livetail:error', {
                statusCode: statusCode,
                category: 'livetail',
                error: errorData
            });
        });
    };

    service.prototype.close = function (errorCode) {
        var self = this;
        if (!self.isLive)
            return;

        self.isLive = false;

        if (self.websocket) {
            self.websocket.onclose
                = self.websocket.onerror
                = self.websocket.onmessage
                = angular.noop;

            self.websocket.close();
            self.websocket = null;
        }

        if (errorCode)
            self.errorHandler(errorCode);

        self.onClose();
    };

    service.prototype.applyFilter = function (data, regex, type) {
        if (!regex)
            return regex;

        regex = regex.replace(new RegExp('^\/+(.+?)\/*$'), '$1');
        this.messageHandler(type + ' /' + regex + '/');
        data.push({'filterType': type, 'filterRegex': regex});
        return regex;
    };

    return service;
});

/* origin: public/webapp/app/outer/forgot-password/forgot-password.js */
angular.module('webApp').controller('ForgotPasswordCtrl', function($rootScope, $scope, $state, $stateParams, Backend) {

    $rootScope.bodyClass = 'white-bg';
    $scope.forgotPassword = true;

    $scope.user = { email: $stateParams.email || '' };
    $scope.emailSent = false;
    $scope.requestProcessing = false;

    $scope.submitForgotPassword = function() {
        $scope.errorMessage = undefined;
        if ($scope.forgotPasswordForm.$invalid)
            return;

        if ($scope.requestProcessing)
            return;

        $scope.requestProcessing = true;
        Backend.POST('/reset-password', { username: $scope.user.email }).then(function() {
            $scope.emailSent = true;
            $scope.requestProcessing = false;
        }).catch(function(err) {
            if (err && err.status === 400 && err.data) {
                $scope.errorMessage = err.data;
            }
            $scope.requestProcessing = false;
        });
    };

    $scope.goToLogin = function() {
        $state.go('login', { email: $scope.user.email });
    };
});


/* origin: public/webapp/app/outer/forgot-password/validate-reset-password.js */
angular.module('webApp').controller('ValidateResetPasswordController', function($rootScope, $scope, $stateParams, $state, AuthService, Backend, cacheService, isNewUser) {

    $rootScope.bodyClass = 'white-bg';
    $scope.isNewUser = isNewUser;
    $scope.resetInProgress = false;

    $scope.token = $stateParams.token;
    $scope.username = '';
    $scope.newPassword = '';

    function validateToken() {
        Backend.POST('/test-reset-password-token', {
            token: $scope.token
        }).then(function(res) {
            if (_.get(res, 'data') !== 'ok') {
                invalidToken();
            }

            // clean all local cache
            cacheService.clearAllCache();

        }).catch(function() {
            invalidToken();
        });
    }

    function invalidToken() {
        $state.go('login', {
            messageTitle: 'Password reset failed',
            messageBody: 'Please try again.'
        });
    }

    validateToken();

    $scope.submitValidateForm = function() {

        if ($scope.validateResetPasswordForm.$invalid || $scope.resetInProgress)
            return;

        $scope.resetInProgress = true;

        var postUrl = isNewUser
            ? '/validate-new-user-token'
            : '/validate-reset-password';

        Backend.POST(postUrl, {
            token: $scope.token,
            username: $scope.username,
            newPassword: $scope.newPassword || $('#new-password').val()
        }).then(function() {
            $state.go('login', {
                messageTitle: 'Your password has now been changed',
                messageBody: 'Please login with your new password.'
            });
        }).catch(function() {
            $scope.errorMessage = 'An error occurred while resetting your password.';
            $scope.resetInProgress = false;
        });
    };
});
/* origin: public/webapp/app/outer/login/login.js */
angular.module('webApp').controller('LoginCtrl', function ($rootScope, $scope, $state, $stateParams, $timeout, $window, AuthService, Backend, AccountService, Focus, MarketoService, Auth0Wrapper) {

    if ($stateParams.id && $stateParams.token && $stateParams.timestamp) {
            // this will redirect the user with a valid auth token if credentials are correct
        AuthService.herokuSsoValidation($stateParams.id, $stateParams.token, $stateParams.timestamp);
        return;
    }

    $scope.messageTitle = $stateParams.messageTitle;
    $scope.messageBody = $stateParams.messageBody;

    var errorCodeToMessage = {
        'a0.mfa_invalid_code': 'The MFA entered is not valid.',
        'unauthorized': 'You are trying to log in from a restricted IP address. Please consult your account admin should you need additional help.',
        'invalid_login': 'Invalid username/password or Google sign in is required',
        'access_denied': 'Google login denied.'
    };

    if ($stateParams.error) {
        $scope.errorMessage = errorCodeToMessage.hasOwnProperty[$stateParams.error] ?
            errorCodeToMessage[$stateParams.error] : $stateParams.error;
    }

    $rootScope.bodyClass = 'white-bg';
    $scope.user = {email: $stateParams.email || ''};
    $scope.showUsernamePassword = true;

    $scope.requestProcessing = false;
    $scope.login = function () {
        if ($scope.requestProcessing)
            return;

        if ($scope.showUsernamePassword && $scope.loginForm.$invalid)
            return;

        if (!$scope.showUsernamePassword && $scope.verificationForm.$invalid)
            return;

        $scope.requestProcessing = true;

        $scope.errorMessage = '';

        Auth0Wrapper.login({
            email: $scope.user.email,
            password: $scope.user.password,
            mfa_code: $scope.showUsernamePassword ? undefined : $scope.passcode,
            callbackUrl: getAuth0CallbackUrl()
        }, handleAuth0Response);
    };

    var handleAuth0Response = function (err, result) {
        if (!err && result && result.idTokenPayload) {
            loginToServer(result.idToken);
            return;
        }

        if (err && (err.code === 'a0.mfa_registration_required' || err.code === 'a0.mfa_required')) {
            $scope.showUsernamePassword = false;
            Focus('login-verification-input');
            $scope.qrCodeUrl = err.code === 'a0.mfa_registration_required'
                    ? err.details.mfa_settings.qr
                    : '';
        }
        else {
            $scope.errorMessage = err && err.code && (errorCodeToMessage[err.code] || 'Unexpected failure. Please try again.');
        }

        finishedLoading();
    };

    var loginToServer = function (idToken) {
        Backend.POST('/login/jwt', {jwt: idToken}).then(function (webSession) {
            AuthService.loggedIn(webSession.data);

            MarketoService.associateLead({
                'Email': $scope.user.email
            });

            if ($stateParams.redirect) {
                $window.location.href = [ window.location.protocol, '//', window.location.host, decodeURIComponent($stateParams.redirect) ].join('');
                return;
            }

            AccountService.getAccountSettings().then(function (settings) {

                var accountSettings = angular.fromJson(settings);
                if (accountSettings.welcomeFlowCurrentStep < 4)
                    $state.go('dashboard.welcome-flow');
                else
                    $state.go('dashboard.kibana');
            });
        }).catch(function (err) {
            $scope.errorMessage = err.message || err.data;
            finishedLoading();
        });
    };

    var finishedLoading = function () {
        $timeout(function() {
            $scope.requestProcessing = false;
        });
    };

    $scope.forgotPassword = function () {
        $state.go('forgotPassword', {email: $scope.user.email});
    };

    $scope.goToSignUp = function () {
        $state.go('register');
    };

    $scope.googleLogin = function () {
        Auth0Wrapper.login({
            connection: 'google-oauth2',
            callbackUrl: getAuth0CallbackUrl(),
            scope: 'openid email name connection'
        }, handleAuth0Response);
    };

    var getAuth0CallbackUrl = function () {
        var baseUrl = [ window.location.protocol, '//', window.location.host ].join('');
        var redirectQueryString = $stateParams.redirect ? [ '&redirectAfterLogin=', $stateParams.redirect ].join('') : '';

        // on success the user is redirected to /login/auth0code by auth0
        return [ baseUrl, '/login/auth0code?baseUrl=', baseUrl, redirectQueryString ].join('');
    };
});
/* origin: public/webapp/app/outer/register/register.js */
angular.module('webApp').controller('RegisterCtrl', function ($rootScope, $scope, $state, $stateParams, $cookies, AuthService, AccountService, MarketoService, Auth0Wrapper, Backend) {

    // Check if the user registered from an external site (i.e.: our marketing site)
    var logzSessionCookie = $cookies.get('logz-session');
    if (!_.isNil(logzSessionCookie)) {
        AuthService.setAuthToken(JSON.parse(logzSessionCookie).sessionToken);
        $cookies.remove('logz-session');
        Backend.GET('/session').then(function () {
            // redirect to login page (and the user should be logged in already)
            $state.go('dashboard.welcome-flow');
        });
    }

    $rootScope.bodyClass = 'white-bg';

    $scope.user = {};
    if ($stateParams.socialSignup) {
        $scope.socialSignup = true;
        if (!$stateParams.username) {
            $scope.errorMessage = 'Error retrieving email!';
            $scope.socialSignup = false;
        }
    }

    if ($stateParams.username) $scope.user.email = $stateParams.username;
    if ($stateParams.fullName) $scope.user.fullName = $stateParams.fullName;
    if ($stateParams.password) $scope.user.password = $stateParams.password;
    if ($stateParams.company) $scope.user.company = $stateParams.company;
    if ($stateParams.phone) $scope.user.phone = $stateParams.phone;
    if ($stateParams.error) $scope.errorMessage = $stateParams.error;

    $scope.signUp = function () {
        if ($scope.registrationInProgress)
            return;

        if ($scope.registerForm.$invalid) {
            return;
        }

        $scope.registrationInProgress = true;
        $scope.errorMessage = '';

        if ($scope.socialSignup) {
            completeGoogleSignUp();
        }
        else {
            signUpWithCredentials();
        }
    };

    $scope.goToLogin = function () {
        $state.go('login');
    };

    function signUpWithCredentials() {
        Auth0Wrapper.signup({
            email: $scope.user.email,
            password: $scope.user.password,
            fullName: $scope.user.fullName,
            company: $scope.user.company,
            phone: $scope.user.phone || ''
        }, function (err, result) {
            if (err) {
                $scope.$apply(function () {
                    $scope.registrationInProgress = false;
                    $scope.errorMessage = err.message || 'An unknown error has occurred.';
                });
                return;
            }
            result;
            reportToMarketo();
            Auth0Wrapper.login({
                email: $scope.user.email,
                password: $scope.user.password
            }, handleAuth0Response);
        });
    }

    var handleAuth0Response = function (err, result) {
        if (!err && result && result.idTokenPayload) {
            Backend.POST('/login/jwt', {jwt: result.idToken}).then(function (webSession) {
                AuthService.loggedIn(webSession.data);
                $state.go('dashboard.welcome-flow');
            }).catch(function (error) {
                $scope.$apply(function () {
                    $scope.registrationInProgress = false;
                    $scope.errorMessage = _.get(error, 'message', 'An unknown error has occurred [xA72nh1].');
                });
            });

            return;
        }

        $scope.$apply(function () {
            $scope.registrationInProgress = false;
            $scope.errorMessage = _.get(err, 'message', 'An unknown error has occurred [xJ21Iy].');
        });
    };

    function completeGoogleSignUp() {
        //at this point the user already logged in with google and auth0,
        //and just needs to complete his registration with us

        Backend.POST('/social-signup', {
            username: $scope.user.email,
            fullName: $scope.user.fullName,
            company: $scope.user.company,
            phone: $scope.user.phone || '',
            jwt: $stateParams.jwt
        }).then(function () {
            reportToMarketo();
            loginToGoogle();
        }).catch(function (err) {
            if (err.data === 'jwt expired') {
                loginToGoogle();
                return;
            }

            $scope.registrationInProgress = false;
            $scope.errorMessage = 'An unknown error has occurred.';
        });
    }

    function reportToMarketo() {
        MarketoService.associateLead({
            'Email': $scope.user.email,
            'fullName': $scope.user.fullName,
            'Company': $scope.user.company,
            'Phone': $scope.user.phone,
            'Plan__c': 'Trial'
        });
    }

    function loginToGoogle() {
        var baseUrl = [ window.location.protocol, '//', window.location.host ].join('');
        Auth0Wrapper.login({
            connection: 'google-oauth2',
            callbackUrl: [ window.location.origin, '/login/auth0code?baseUrl=', baseUrl ].join(''),
            scope: 'openid email name connection'
        });
    }
});
/* origin: public/webapp/app/outer/register/registration-dialog-controller.js */
angular.module('webApp').controller('RegistrationDialogController', function ($scope, $state) {
    $scope.goToRegister = function () {
        $scope.closeThisDialog();
        $state.go('register');
    };

    $scope.goToLogin = function () {
        $scope.closeThisDialog();
        $state.go('login');
    };
});
/* origin: public/webapp/app/purchase/purchase-validation.js */
angular.module('webApp').controller('PurchaseValidationController', function($rootScope, $scope, $stateParams, Backend) {

    document.getElementsByTagName('body')[0].style.backgroundColor = 'white';
    window.top.document.getElementById('checkout-frame').style.height = '300px';

    var planTypes = {
        2: 'STANDARD',
        3: 'PRO'
    };

    $scope.planType = planTypes[$stateParams.planTypeId].toLowerCase();
    $scope.retention = $stateParams.retention;
    $scope.maxVolume = $stateParams.maxVolume;

    Backend.POST('/purchase/validate', {

        invoiceId: $stateParams.invoiceId,
        mainProductId: $stateParams.mainProductId,
        retention: $stateParams.retention,
        maxVolume: $stateParams.maxVolume,
        planType: planTypes[$stateParams.planTypeId],
        authKey: $stateParams.authKey

    }).then(function() {

        $scope.successful = true;
        $rootScope.$emit('plan-details-updated');

    }).catch(function() {

        $scope.failure = true;

    });

});
/* origin: public/webapp/app/styleguide/app/styleguide-controller.js */
/* eslint-disable max-lines */
angular.module('webApp').controller('AppStyleguideController', function ($element, $scope, $location) {

    $scope.sideMenu = {
        selected: 'buttons',
        pages: ['buttons', 'toggle', 'input', 'select', 'menu', 'group buttons', 'radio buttons', 'date time range picker',
            'plus minus counter', 'app-checkbox', 'app-table', 'app-tooltip']
    };

    $scope.jumpToSection = function (section) {
        $scope.sideMenu.selected = section;
        $location.url('#'+section);
    };

    // This will add ng-dirty to all components. that is required for the invalid buttons to work (ng-dirty is added automatically after touching it, here I don't demand that but in a regular form it is required.
    (function addNgDirty(element) {
        if (element.className) {
            element.className += ' ng-dirty';
        }

        if (element.children) {
            var childrens = typeof element.children === 'object' ? element.children : element.children();
            for (var i = 0; i < childrens.length; i++) {
                addNgDirty(childrens[i]);
            }
        }
    })($element);

    $scope.appToggle = {
        callback: function (value) {
            console.log(['app toggle change callback - ', value].join(''));
        },
        uiData: {
            leftOption: {
                label: 'Dark',
                value: 1
            },
            rightOption: {
                label: 'Light',
                value: 0
            },
            value: 'Dark'
        },
        uiDataOneSided: {
            leftOption: {
                label: 'Show Some',
                value: true
            },
            rightOption: {
                value: false
            },
            value: 'show'
        }

    };

    $scope.appSelectFloating = {
        value: 'sheker',
        options: [{
            text: 'Hey',
            value: 'sheker'
        }, {
            text: 'Hello',
            value: 'shesh2',
        }, {
            text: 'ARAIS',
            value: 'shesh22',
        }, {
            text: 'HAGIGA',
            value: 'shesh6',
        }]
    };

    $scope.appSelectExpandable = {
        expansion: 'app/styleguide/app/app-selector-templates/app-selector-expand.html',
        changeCallback: function (value) {
            console.log(['app select expandable change callback - ', value].join(''));
        },
        expansionCallback: function (value) {
            console.log(['app select expandable expansion callback - ', value].join(''));
        },
        options: [{
            text: 'I am not expandable',
            value: 'sheker'
        }, {
            text: 'Im disabled',
            value: 'balagan',
            disabled: true
        }, {
            text: 'I AM EXPANDABLE!',
            value: 'wowowowow',
            expand: true
        }, {
            text: 'Look! he has a Token prefix',
            value: 'shesh',
            expand: true
        }, {
            prefix: 'Token',
            text: 'I have a prefix to my left',
            value: 'putzatz',
            expand: true
        }, {
            text: 'Sheesh, click me',
            value: 'balagan2',
        }, {
            text: 'YOU CANT TOUCH ME',
            value: 'wowowowow2',
            disabled: true
        }, {
            text: 'Im good for clicking',
            value: 'shesh2',
            expand: true
        }, {
            text: 'Im good for clicking2',
            value: 'shesh22',
            expand: true
        }, {
            text: 'Im good for clicking3',
            value: 'shesh6',
            expand: true
        }]
    };

    $scope.appSelectCustomOptions = {
        ngHide: true,
        model: 'shesh',
        changeCallback: function (value) {
            console.log([ 'app select custom options change callback - ', value ].join(''));
        },
        options: [{
            text: 'Sheker',
            value: 'sheker'
        }, {
            text: 'I scream', // Must have - for filter, you can leave it '' if you don't want to find it in filter
            templateUrl: 'app/styleguide/app/app-selector-templates/app-selector-custom-option.html',
            customAction: function () {
                alert('Im a custom option action!');
            },
            customClass: 'styleguide-app-selector-custom-option',
            dontCloseMenu: true
        }, {
            text: 'WOWOWOWOWOW',
            value: 'wowowowow',
        }, {
            text: 'I scream too!', // Must have - for filter, you can leave it '' if you don't want to find it in filter
            templateUrl: 'app/styleguide/app/app-selector-templates/app-selector-custom-option2.html',
            customAction: function () {
                alert('Im a custom option SHTAIM action!');
            },
            customClass: 'styleguide-app-selector-custom-option',
            dontCloseMenu: true
        },  {
            prefix: 'Token',
            text: 'Putzatz',
            value: 'putzatz',
        }, {
            text: 'But I set a value',
            value: 'I AM VALUE',
            templateUrl: 'app/styleguide/app/app-selector-templates/app-selector-custom-option3.html',
            customClass: 'styleguide-app-selector-custom-option',
        }, {
            text: 'Shesh6',
            value: 'shesh6',
        }, {
            // No need to pass value!
            text: 'And I reset ngModel',
            templateUrl: 'app/styleguide/app/app-selector-templates/app-selector-custom-option4.html',
            customClass: 'styleguide-app-selector-custom-option',
        }, {
            text: 'Shesh',
            value: 'shesh',
        }]
    };

    $scope.appSelectCustomWidthAndStyle = {
        model: 'shesh',
        changeCallback: function (value) {
            console.log([ 'app select custom width & style change callback - ', value ].join(''));
        },
        options: [{
            text: 'Sheker',
            value: 'sheker'
        }, {
            text: 'Balagan',
            value: 'balagan',
            disabled: true
        }, {
            text: 'WOWOWOWOWOW',
            value: 'wowowowow',
        }, {
            separator: true
        }, {
            prefix: 'Token',
            text: 'Putzatz',
            value: 'putzatz',
        }, {
            text: 'Shesh',
            value: 'shesh',
        }]
    };

    $scope.appSelectCustomDom = {
        customDom: 'app/styleguide/app/app-selector-templates/app-selector-custom-dom.html',
        changeCallback: function (value) {
            console.log([ 'app select custom DOM change callback - ', value ].join(''));
        },
        options: [{
            text: 'Sheker',
            value: 'sheker'
        }, {
            text: 'Balagan',
            value: 'balagan',
            disabled: true
        }, {
            text: 'WOW',
            value: 'wowowowow',
        }, {
            separator: true
        }, {
            text: 'Putzatz',
            value: 'putzatz',
        }, {
            text: 'Shesh',
            value: 'shesh',
        }]
    };

    $scope.appSelectCustomDomLeftAlignment = {
        customDom: 'app/styleguide/app/app-selector-templates/app-selector-custom-dom.html',
        changeCallback: function (value) {
            console.log([ 'app select custom DOM change callback - ', value ].join(''));
        },
        options: [{
            text: 'Sheker',
            value: 'sheker'
        }, {
            text: 'Balagan',
            value: 'balagan',
            disabled: true
        }, {
            text: 'WOWOWOWOW',
            value: 'wowowowow',
        }, {
            separator: true
        }, {
            text: 'Putzatz',
            value: 'putzatz',
        }, {
            text: 'Shesh',
            value: 'shesh',
        }]
    };

    $scope.appSelectCustomDomCheckboxes = {
        model: [ 'sheker', 'putzatz' ],
        customDom: 'app/styleguide/app/app-selector-templates/app-selector-custom-dom.html',
        header: 'app/styleguide/app/app-selector-templates/app-selector-header.html',
        changeCallback: function (value) {
            console.log([ 'app select custom DOM with checkboxes change callback - ', value ].join(''));
        },
        options: [{
            text: 'Sheker',
            value: 'sheker'
        }, {
            text: 'Balagan',
            value: 'balagan',
            disabled: true
        }, {
            text: 'WOWOWOWOWOW',
            value: 'wowowowow',
        }, {
            separator: true
        }, {
            prefix: 'Token',
            text: 'Putzatz',
            value: 'putzatz',
        }, {
            text: 'Shesh',
            value: 'shesh',
        }]
    };

    $scope.appSelectCheckboxes = {
        model: ['sheker', 'shesh'],
        changeCallback: function (value) {
            console.log(['app select checkboxes change callback - ', value].join(''));
        },
        options: [{
            text: 'Sheker',
            value: 'sheker'
        }, {
            text: 'Balagan',
            value: 'balagan',
            disabled: true
        }, {
            text: 'LOOK HERE IS A SEPARATOR!',
            value: 'wowowowow',
        }, {
            separator: true
        }, {
            prefix: 'Token',
            text: 'Putzatz',
            value: 'putzatz',
        }, {
            text: 'Shesh',
            value: 'shesh',
        }]
    };

    $scope.appSelectResetAndNew = {
        model: 'shesh',
        changeCallback: function (value) {
            console.log(['app select reset and new change callback - ', value].join(''));
        },
        options: [{
            text: 'Sheker',
            value: 'sheker'
        }, {
            text: 'Balagan',
            value: 'balagan',
            disabled: true
        }, {
            text: 'WOWOWOWOWOW',
            value: 'wowowowow',
        }, {
            separator: true
        }, {
            prefix: 'Token',
            text: 'Putzatz',
            value: 'putzatz',
        }, {
            text: 'Shesh',
            value: 'shesh',
        }]
    };

    $scope.appSelectHover = {
        changeCallback: function (value) {
            console.log(['app select hover change callback - ', value].join(''));
        },
        options: [{
            text: 'Sheker',
            value: 'sheker'
        }, {
            text: 'Balagan',
            value: 'balagan',
            disabled: true
        }, {
            text: 'WOWOWOWOWOW',
            value: 'wowowowow',
        }, {
            separator: true
        }, {
            prefix: 'Token',
            text: 'Putzatz',
            value: 'putzatz',
        }, {
            text: 'Shesh',
            value: 'shesh',
        }]
    };

    $scope.appSelectFooterAndMaxHeight = {
        footer: 'app/styleguide/app/app-selector-templates/app-selector-footer.html',
        changeCallback: function (value) {
            console.log(['app select footer and custom max height change callback - ', value].join(''));
        },
        options: [{
            text: 'Sheker',
            value: 'sheker'
        }, {
            text: 'Balagan',
            value: 'balagan',
            disabled: true
        }, {
            text: 'Im expandable',
            value: 'wowowowow',
            expand: true
        }, {
            separator: true
        }, {
            prefix: 'Token',
            text: 'I am expandable',
            value: 'putzatz',
            expand: true
        }, {
            text: 'Expandable',
            value: 'shesh',
            expand: true
        }, {
            text: 'Expandable #2',
            value: 'she3sh',
            expand: true
        }, {
            text: 'She2sh',
            value: 'sh78esh',
        }, {
            text: 'She1sh',
            value: 'she11sh',
        }, {
            text: 'She6sh',
            value: 'sh6esh',
        }, {
            text: 'She65sh',
            value: 'sh5esh',
        }, {
            text: 'She4sh',
            value: 'sh2esh',
        }]
    };

    $scope.appSideMenu = {
        selected: 'Sheker',
        pages: ['Sheker', 'Balagan', 'WOWOWOWOW', 'Very long text for multi line effect', 'Shesh', 'Putzatz']
    };

    $scope.groupButtonsData = {
        callback: function (value) {
            console.log([ 'group buttons callback value - ', value ].join(''));
        },
        uiData: {
            data: [{
                label: 'Alert',
                value: 'alert',
            }, {
                label: 'Nina',
                value: 'nina',
            }, {
                label:'Continuous aggregation',
                value: 'continuous_aggregation',
            }],
            value: 'nina',
            disabledBtnsList: ['alert']
        }
    };

    $scope.severity = 'MEDIUM';

    /************************************************************************************************
     *                                  Date time range picker                                      *
     ************************************************************************************************/

    $scope.rangePicker = {};
    $scope.rangePicker.format = 'MMM DD YYYY';
    $scope.rangePicker.divider = '-';
    $scope.rangePicker._startDate = moment().subtract(90, 'days');
    $scope.rangePicker._endDate = moment();
    $scope.rangePicker.rangeValue = {
        startDateAsMoment: $scope.rangePicker._startDate,
        startDate: $scope.rangePicker._startDate.format($scope.rangePicker.format),
        endDateAsMoment: $scope.rangePicker._endDate,
        endDate: $scope.rangePicker._endDate.format($scope.rangePicker.format),
    };
    $scope.rangePicker.onSelectListener = function (range) {
        console.log('Selected date range:');
        console.log(range);
    };

    /************************************************************************************************
     *                                      App-Checkbox                                            *
     ************************************************************************************************/

    $scope.appCheckbox = {};
    $scope.appCheckbox.isIndeterminate = true;
    $scope.appCheckbox.isDisabled = false;
    $scope.appCheckbox.toggleIndeterminate = function () {
        $scope.appCheckbox.isChecked
            ? $scope.appCheckbox.isIndeterminate = true
            : $scope.appCheckbox.isIndeterminate = !$scope.appCheckbox.isIndeterminate;

        $scope.appCheckbox.isChecked = false;
    };

    /************************************************************************************************
     *                                        App-Table                                             *
     ************************************************************************************************/
    $scope.appTable = {};
    $scope.appTable.apiObj = {};
    $scope.appTable.sortEventHandler = function (field, descending) {
        console.log(field, descending);
    };

    $scope.appTable.totalResults = 467;
    $scope.appTable.pageNumber = 3;
    $scope.appTable.pageSize = 10;
    $scope.appTable.onPageChange = function (pageNumber) {
        console.log('Page change to page no\' ' + pageNumber);
    };

    $scope.appTable.rows = [
        {
            name: 'Amir Tugendhaft',
            status: 'Active',
            eventType: 'Event',
            assignee: '@amir.tugi',
            tag: 'Bug',
            severity: 'Medium',
            lastSeen: '2017-10-13',
            occurrencesOverTime: 2,
            hash: 'body-row-1'
        },
        {
            name: 'Alon Mizrahi',
            status: 'Resolved',
            eventType: 'Logception',
            assignee: '@alon.miz',
            tag: 'Anomaly',
            severity: 'High',
            lastSeen: '2017-10-15',
            occurrencesOverTime: 23,
            hash: 'body-row-2'
        }];

});
/* eslint-enable max-lines */
/* origin: public/webapp/app/values.js */
/**
 * Created by amirtugi on 30/07/2017.
 */
angular.module('webApp').value('dialogValues', {
    'switchUserDialog': false
});
/* origin: public/webapp/constants.js */
angular.module('webApp').constant('enums', {
    ACCOUNT_STATES: {
        BLOCKED: 0,
        ACTIVE: 1
    },
    USER_STATES: {
        SUSPEND: 0,
        ACTIVE: 1
    },
    USER_ROLES: {
        REGULAR: 'USER_ROLE_ACCOUNT_REGULAR',
        ADMIN: 'USER_ROLE_ACCOUNT_ADMIN'
    }
});

/* origin: public/webapp/directives/alert-webhooks/upsert-notification-endpoint-controller.js */
/* eslint-disable max-lines */
angular.module('webApp').controller('UpsertNotificationEndpointController', function ($scope, $timeout, NotificationEndpointService, AnalyticsService) {

    var createNoteWithLink = function (templateName, address, fieldName) {
        return {
            beforeLink: 'Please refer to the',
            link: {
                address: address,
                text: [ templateName, 'documentation' ].join(' ')
            },
            afterLink: [ 'to learn how to set up the', fieldName ].join(' ')
        };
    };

    $scope.urlNgPattern = '^(http|https):\/\/.*';
    $scope.templatesData = {
        'Custom': {
            userData: {
                params: {
                    method: 'GET'
                }
            },
            urlPlaceHolder: 'eg: https://my.third-party-service.com/integration-key/KSJ329aB8F'
        },
        'Slack': {
            userData: {
                params: {}
            },
            uiControls: [{
                name: 'URL',
                placeholder: 'eg: https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXX',
                modelPath: 'userData.params',
                modelPropertyName: 'url',
                note: createNoteWithLink('Slack', 'https://api.slack.com/incoming-webhooks', 'URL'),
                ngPattern: $scope.urlNgPattern
            }]
        },
        'PagerDuty': {
            userData: {
                params: {
                    url: 'https://events.pagerduty.com/generic/2010-04-15/create_event.json', // Hidden from the user, should always be sent to Services
                    bodyTemplate: { }
                }
            },
            uiControls: [{
                name: 'Service Key',
                placeholder: 'eg: 9c0f784f97a14f269b299756fc062b66',
                modelPath: 'userData.params.bodyTemplate',
                modelPropertyName: 'service_key',
                note: createNoteWithLink('PagerDuty', 'https://support.pagerduty.com/hc/en-us/articles/202830340-Creating-a-Generic-API-Integration', 'service key')
            }]
        },
        'Datadog': {
            url: 'https://app.datadoghq.com/api/v1/events?api_key=',
            manipulationBeforeEdit: function () {
                $scope.templatesData['Datadog'].apiKey = $scope.templatesData['Datadog'].userData.params.url.split($scope.templatesData['Datadog'].url)[1];
            },
            manipulationBeforeUpsert: function () {
                $scope.templatesData['Datadog'].userData.params.url = [ $scope.templatesData['Datadog'].url, $scope.templatesData['Datadog'].apiKey ].join('');
            },
            userData: {
                params: {}
            },
            uiControls: [{
                name: 'API Key',
                placeholder: 'eg: ea8a6fe8021e1cdfe87614089b0a3b38',
                modelPropertyName: 'apiKey',
                note: createNoteWithLink('Datadog', 'https://app.datadoghq.com/account/settings#api', 'api key')
            }]
        },
        'BigPanda': {
            url: 'https://api.bigpanda.io/data/v2/alerts?access_token=',
            manipulationBeforeEdit: function () {
                $scope.templatesData['BigPanda'].token = $scope.templatesData['BigPanda'].userData.params.url.split($scope.templatesData['BigPanda'].url)[1];
            },
            manipulationBeforeUpsert: function () {
                $scope.templatesData['BigPanda'].userData.params.url = [ $scope.templatesData['BigPanda'].url, $scope.templatesData['BigPanda'].token ].join('');
            },
            userData: {
                params: {
                    bodyTemplate: { }
                }
            },
            uiControls: [{
                name: 'Token',
                placeholder: 'eg: ccc0d7a2ce50b365ffca653e80d52ceb',
                modelPropertyName: 'token',
                note: createNoteWithLink('BigPanda', 'https://www.bigpanda.io/docs/display/BD/Alerts+API', 'token')
            }, {
                name: 'App Key',
                placeholder: 'eg: 72ea2ed8ae331fbc80c7bdaffabc8f76',
                modelPath: 'userData.params.bodyTemplate',
                modelPropertyName: 'app_key',
                note: createNoteWithLink('BigPanda', 'https://www.bigpanda.io/docs/display/BD/Alerts+API', 'app key')
            }]
        }
    };

    var clonedNotificationEndpointToEdit = _.cloneDeep($scope.notificationEndpointToEdit);
    if (clonedNotificationEndpointToEdit) {
        $scope.title = clonedNotificationEndpointToEdit.title;
        $scope.description = clonedNotificationEndpointToEdit.description;

        $scope.templateName = clonedNotificationEndpointToEdit.templateName;
        $scope.chosenTemplateName = $scope.templateName;
        $scope.templatesData[$scope.templateName].userData = clonedNotificationEndpointToEdit;
        if ($scope.templatesData[$scope.templateName].manipulationBeforeEdit) {
            $scope.templatesData[$scope.templateName].manipulationBeforeEdit();
        }

        if ($scope.templateName === 'Custom' && $scope.templatesData[$scope.templateName].userData.params.bodyTemplate) {
            // Model to JSON string, in custom mode the user configure the body
            $scope.templatesData[$scope.templateName].userData.params.bodyTemplate = angular.toJson($scope.templatesData[$scope.templateName].userData.params.bodyTemplate, true);
        }
    }

    var forceTemplateTypesToShow = $scope.forceTemplateTypesToShow || [];
    NotificationEndpointService.getAllNotificationEndpointTemplates().then(function (response) {
        $scope.availableTemplateTypes = [];
        _.forEach(response.data, function (notificationEndpointTemplate) {
            var templateName = notificationEndpointTemplate.templateName;
            $scope.availableTemplateTypes.push(templateName);

            $scope.templatesData[templateName].userData.type = notificationEndpointTemplate.notificationType;
            $scope.templatesData[templateName].userData.internal_type = notificationEndpointTemplate.notificationType;

            var servicesData = angular.fromJson(notificationEndpointTemplate.template);
            $scope.templatesData[templateName].userData.params.method = servicesData.method || $scope.templatesData[templateName].userData.params.method;

            if ($scope.templateName === 'Custom' && clonedNotificationEndpointToEdit) {
                // Editing a custom endpoint, shouldn't override his body template
                return;
            }
            $scope.templatesData[templateName].userData.params.bodyTemplate = templateName === 'Custom'
                ? angular.toJson(servicesData.bodyTemplate, true)
                : _.merge($scope.templatesData[templateName].userData.params.bodyTemplate, servicesData.bodyTemplate);
        });

        $scope.availableTemplateTypes.sort();
        var customIndex = $scope.availableTemplateTypes.indexOf('Custom');
        if (customIndex < 0) {
            return; // No custom option
        }
        $scope.availableTemplateTypes.splice(customIndex, 1); // Custom should be the last option in the list
        $scope.availableTemplateTypes.push('Custom');
        if (forceTemplateTypesToShow.length) {
            $scope.availableTemplateTypes = forceTemplateTypesToShow;
        }
    });

    // Set each UI control modelPath to the object it self (string dotnotation to object reference)
    // We can't combine modelPath and modelPropertyName to one object reference because it's a string value
    // and JS doesn't pass it as reference but by value (in this following array node example, not by passing to function)
    var templateNames = Object.keys($scope.templatesData);
    _.forEach(templateNames, function (templateName) {
        _.forEach($scope.templatesData[templateName].uiControls, function (uiControl) {
            var nodes = uiControl.modelPath ? uiControl.modelPath.split('.') : [];
            uiControl.modelPath = $scope.templatesData[templateName];
            _.forEach(nodes, function (node) {
                uiControl.modelPath = uiControl.modelPath[node];
            });
        });
    });

    var saveInProcess = false;
    $scope.saveNotificationEndpoint = function() {
        $scope.notificationSaveError = false;
        angular.forEach($scope.upsertNotificationEndpoint.$error, function (field) {
            angular.forEach(field, function(errorField){
                if (errorField.$error.required && errorField.$modelValue && errorField.$modelValue.length >= 0) {
                    errorField.$setValidity('required', true);
                    return;
                }

                errorField.$setTouched();
            });
        });

        if ($scope.upsertNotificationEndpoint.$invalid) {
            return;
        }

        if (saveInProcess) {
            return;
        }
        saveInProcess = true;

        var templateData = $scope.templatesData[$scope.templateName];
        if (templateData.userData.params.method === 'GET') {
            delete templateData.userData.params.bodyTemplate;
        }

        if (templateData.manipulationBeforeUpsert) {
            templateData.manipulationBeforeUpsert();
        }

        var upsertEndpointData = _.merge(clonedNotificationEndpointToEdit, templateData.userData);
        upsertEndpointData = _.cloneDeep(upsertEndpointData); // To avoid manipulation effecting the UI
        if (upsertEndpointData.params.bodyTemplate) {
            upsertEndpointData.params.bodyTemplate = angular.fromJson(upsertEndpointData.params.bodyTemplate);
        }

        upsertEndpointData.templateName = $scope.templateName;
        upsertEndpointData.title = $scope.title;
        upsertEndpointData.description = $scope.description;
        NotificationEndpointService.saveNotificationEndpoint(upsertEndpointData).then(function (response) {

            if (!clonedNotificationEndpointToEdit) {
                AnalyticsService.report('alerts:save-notification-endpoint', {
                    category: 'alerts',
                    endPoint: $scope.templateName
                });
                $scope.notificationEndpoints.push(response.data);
                $scope.closeThisDialog();
                return;
            }
            else {
                AnalyticsService.report('alerts:edit-notification-endpoint', {
                    category: 'alerts',
                    endPoint: $scope.templateName
                });
            }

            _.forEach($scope.notificationEndpoints, function (notificationEndpoint, index) {
                if (notificationEndpoint.id === clonedNotificationEndpointToEdit.id) {
                    $scope.notificationEndpoints[index] = clonedNotificationEndpointToEdit;
                    $scope.notificationEndpoints[index].templateName = $scope.templateName;
                    $scope.notificationEndpoints[index].title = $scope.title;
                    $scope.notificationEndpoints[index].description = $scope.description;
                }
            });
            $scope.closeThisDialog();
        }).catch(function () {
            saveInProcess = false;
            $scope.notificationSaveError = 'Error occurred while saving your notification endpoint. Please check your input and try again.';
        });
    };

    $scope.cancel = function() {
        $scope.dialogNotificationEndpoint = {};
        $scope.closeThisDialog();
    };

    var switchTemplateTimer;
    var switchTemplateTimerRunning = false;
    var watchSelectTemplate = $scope.$watch('chosenTemplateName', function (newValue, oldValue) {
        if (newValue === oldValue) {
            return;
        }

        if (oldValue !== undefined && !$scope.shouldAddTransitionDelay) {
            $scope.shouldAddTransitionDelay = true; // When moving between templates and not choosing one for the first time, we need to add a transition delay for closing & then opening effect (one after another)
        }


        // We keep templateName and chosenTemplateName as separated models due to the 400 ms $timeout
        if (!$scope.shouldAddTransitionDelay) {
            $scope.templateName = $scope.chosenTemplateName;
            return;
        }

        // Wait for the hide transition of of user data to be applied before changing the template value (which will change the user data in the UI)
        if (switchTemplateTimerRunning) {
            $timeout.cancel(switchTemplateTimer);
        }

        switchTemplateTimerRunning = true;
        switchTemplateTimer = $timeout(function () {
            $scope.templateName = $scope.chosenTemplateName;
            switchTemplateTimerRunning = false;
        }, 400);
    });

    var customEndpointBodyValidator = $scope.$watch('templatesData.Custom.userData.params.bodyTemplate', function () {
        if (!$scope.upsertNotificationEndpoint || !$scope.upsertNotificationEndpoint['templatesData.Custom.userData.params.bodyTemplate']) {
            return;
        }

        var valid = true;
        if (typeof $scope.templatesData['Custom'].userData.params.bodyTemplate !== 'string') {
            valid = true;
        }
        else {
            try {
                JSON.parse($scope.templatesData['Custom'].userData.params.bodyTemplate);
            }
            catch (e) {
                valid = false;
            }
        }

        $scope.upsertNotificationEndpoint['templatesData.Custom.userData.params.bodyTemplate'].$setValidity('validJson', valid);
    });



    $scope.$on('$destroy', function() {
        if (watchSelectTemplate) watchSelectTemplate();
        if (customEndpointBodyValidator) customEndpointBodyValidator();
    });
});
/* origin: public/webapp/directives/app-actions-popover/app-actions-popover.js */
angular.module('webApp').directive('appActionsPopover', function () {
    return {
        scope: {
            actionType: '@',
            model: '=',
            applyActionCallbackFunction: '='
        },
        controller: 'appActionsPopoverController',
        compile: function(element, attributes){
            var typeToTemplate = {
                appMultiselectCheckbox: {
                    attr: 'checkboxes',
                    value: 'copiedModel',
                    element: '<app-multiselect-checkbox>'
                },
                appSimpleMultiCheckbox: {
                    attr: 'checkboxes',
                    value: 'copiedModel',
                    element: '<app-simple-multi-checkbox>'
                }
            };
            var type = typeToTemplate[attributes.actionType];
            var typeElement = $(type.element).attr(type.attr, type.value);
            element.find('.app-actions-popover-container').append(typeElement);
        },
        templateUrl: 'directives/app-actions-popover/app-actions-popover.html'
    };
}).controller('appActionsPopoverController', function ($scope, $element) {
    if ($scope.model) {
        $scope.copiedModel = _.cloneDeep($scope.model);
    }

    $scope.apply = function () {
        $scope.model = $scope.copiedModel;
        $scope.$parent.closeCallback();
        if ($scope.applyActionCallbackFunction) $scope.applyActionCallbackFunction();
    };

    $scope.close = function () {
        $scope.$parent.closeCallback();
    };

    //because this element is destroyed from the popover directive and sharing the same scope,
    //it is not destroyed till the popover is destroyed.
    //hence, we can listen to the ELEMENT destroy event and force the scope to be destroyed
    $element.on('$destroy', function () {
        $scope.$destroy();
    });
});
/* origin: public/webapp/directives/app-actions-popover/app-multiselect-checkbox/app-multiselect-checkbox.js */
angular.module('webApp').component('appMultiselectCheckbox', {
    bindings: {
        plural: '@',
        checkboxes: '='
    },
    templateUrl: 'directives/app-actions-popover/app-multiselect-checkbox/app-multiselect-checkbox.html',
    controller: function () {
        var that = this;
        this.setSelectedCount = function () {
            var checkboxesSelected = _.filter(that.checkboxes, {model: true});
            that.checkboxesSelectedCount = checkboxesSelected.length;
            that.checkboxesFilteredCount = _.filter(that.checkboxes, that.isFiltered).length;
            that.checkboxesFilteredSelectedCount = _.filter(checkboxesSelected, that.isFiltered).length;
            that.isIndeterminate = that.checkboxesFilteredSelectedCount > 0 && that.checkboxesFilteredSelectedCount < that.checkboxesFilteredCount;
            that.checkAll = that.checkboxesFilteredSelectedCount === that.checkboxesFilteredCount; //TODO create method
        };

        this.clearAll = function () {
            _.forEach(that.checkboxes, function (checkbox) {
                checkbox.model = false;
            });
        };

        this.selectAllToggle = function () {
            var filtered = getFilteredCheckboxes();
            if (that.checkboxesFilteredSelectedCount === that.checkboxesFilteredCount) {
                _.forEach(filtered, function (checkbox) {
                    checkbox.model = false;
                });
                that.checkAll = false;
            }
            else {
                _.forEach(filtered, function (checkbox) {
                    checkbox.model = true;
                });
                that.checkAll = true;
            }
            that.setSelectedCount();
        };

        this.deselectItem = function (value) {
            var item = _.find(that.checkboxes, {value: value});
            if (item) {
                item.model = false;
            }
            that.setSelectedCount();
        };

        this.isFiltered = function (item) {
            return that.filterValue ? new RegExp(['(', that.filterValue, ')'].join(''), 'gi').test(item.label) : true;
        };

        function getFilteredCheckboxes() {
            return _.filter(that.checkboxes, that.isFiltered);
        }
        this.$onInit = function () {
            this.setSelectedCount();
        };

    }
});

//TODO hover if truncated

//TODO select all should select only the ones that are filtered
//TODO design hover mode
//TODO design selected mode
//TODO Clear all in the selected list
//TODO design filter input
//TODO plural
/* origin: public/webapp/directives/app-actions-popover/app-simple-multi-checkbox/app-simple-multi-checkbox.js */
angular.module('webApp').component('appSimpleMultiCheckbox', {
    bindings: {
        checkboxes: '='
    },
    templateUrl: 'directives/app-actions-popover/app-simple-multi-checkbox/app-simple-multi-checkbox.html'
});
/* origin: public/webapp/directives/app-checkbox-menu/app-checkbox-menu.js */
/**
 * @param checkboxes - {
 *                       ID: {
 *                              label: {string}
 *                              value: {boolean}
 *                           }
 *                     }
 */
// TODO: Add to style-guide
angular.module('webApp')
    .directive('appCheckboxMenu', function() {
        return {
            restrict: 'E',
            transclude: true,
            scope: {
                menuTitle: '@',
                checkboxes: '=',
                changeListener: '='
            },
            templateUrl: 'directives/app-checkbox-menu/app-checkbox-menu.html',
            controller: 'appCheckboxMenuCtrl'
        };
    })
    .controller('appCheckboxMenuCtrl', function($scope) {
        $scope.showMenu = false;

        $scope.clickOutsideMenu = function() {
            $scope.showMenu = false;
        };
    });
/* origin: public/webapp/directives/app-checkbox/app-checkbox.js */
angular.module('webApp')
    .directive('appCheckbox', function($compile) {
        return {
            restrict: 'A',
            scope: {
                label: '@',
                indeterminate: '<?'
            },
            link: function (scope, element, attrs) {

                element.addClass('app-checkbox');

                attrs.$set('id', attrs.id || ['app-checkbox-', scope.$id].join(''));
                scope.inputId = attrs.id;

                var label = angular.element('<label for="{{inputId}}" class="app-checkbox-label" ng-class="{\'indeterminate\': indeterminate}">{{label}}</label>');
                label.insertAfter(element);
                $compile(label)(scope);
            }
        };
    });
/* origin: public/webapp/directives/app-count-to-number/app-count-to-number.js */
angular.module('webApp').component('appCountToNumber', {
    bindings: {
        number: '<',
        timeToRender: '@',
        delay: '@'
    },
    replace: true,
    controllerAs: 'vm',
    template: '<span>{{vm.displayedNumber}}</span>',
    controller: function ($interval, $timeout) {
        var vm = this;

        var options = {
            timeToRender: 1.5 * 1000,
            changesCycleInterval: 50,
            delay: 800,
            number: 0
        };

        function _startCounting() {
            var currentStep = 0;
            var interval = $interval(function () {
                if (currentStep <= options.timeToRender) {
                    currentStep += options.changesCycleInterval;
                    vm.displayedNumber = Math.round(options.number * (Math.sqrt(currentStep / options.timeToRender)));
                    return;
                }
                _stopInterval(interval);
                vm.displayedNumber = Math.round(options.number);
            }, options.changesCycleInterval);
        }

        function _stopInterval(interval) {
            $interval.cancel(interval);
        }

        this.$onChanges = function () {
            //todo recount when number has changed
            // console.log('changes');
        };

        this.$onInit = function () {
            vm.displayedNumber = '';

            options.timeToRender = Number(vm.timeToRender) || options.timeToRender;
            options.delay = Number(vm.delay) || options.delay;
            options.number = Number(vm.number) || options.number;

            $timeout(_startCounting, options.delay);
        };

    }
});
/* origin: public/webapp/directives/app-data-table/app-data-table-controller.js */
angular.module('webApp')
    .controller('appDataTableCtrl', function($scope) {

        // TODO: Support for multiple sorts

        $scope.activeSort = null;
        $scope.sortEventHandler = $scope.sortEventHandler || function() { console.warn('Sort is enabled, but sortEventHandler is not passed'); };

        /**
         * REMARK: Sorting requires 'field' key to appear in the header. Otherwise, the listener will not be able to know which field is sorting.
         * @param key - The hash of the header so we can identify which header is sorting
         * @param header
         */
        $scope.toggleSort = function(key, header) {
            if (!header.sortable) { return; }

            if ($scope.activeSort !== key) {
                // Reset the toggle of the previous sorter
                if ($scope.activeSort !== null) { $scope.headers[$scope.activeSort]._descending = true; }

                $scope.activeSort = key;
                $scope.headers[$scope.activeSort]._descending = true;
            }
            else {
                // If the same sort, just toggle
                header._descending = !header._descending;
            }

            $scope.sortEventHandler(header.sortFieldName || header.title, header._descending);
        };

        var isJson = function(element) {
            return !Array.isArray(element) && (typeof element === 'object');
        };

        $scope.filterHeaders = function (headers) {
            var filteredHeaders = {};

            for (var key in headers) {
                if (headers.hasOwnProperty(key) && headers[key].show === true) {
                    filteredHeaders[key] = headers[key];
                }
            }

            return filteredHeaders;
        };

        /**
         * Turn 'camelCase.camelCase' into 'Camel Case, Camel Case'
         */
        var prettifyTitle = function(title) {
            return title.split('.')
                .map(function(section) { return section.split(/(?=[A-Z])/g).join(' ');})
                .map(function(x) { return x[0].toUpperCase() + x.slice(1); }).join(' - ');
        };

        /**
         * Use either 'title' or prettify the 'field' key
         * BUT EITHER WAY, EACH HEADER WILL HAVE A 'title' FIELD.
         */
        var initHeaders = function() {
            $scope.headers = {};

            if ($scope._headers) {
                for (var key in $scope._headers) {
                    if ($scope._headers.hasOwnProperty(key)) {
                        var header = $scope._headers[key];

                        header.title = header.title || prettifyTitle(header.field);
                        header._descending = header.sortable ? true : null;
                        $scope.headers[key] = header;

                        // Activate sort if wanted in the config
                        if (header.sorted) { $scope.toggleSort(key, header); }
                    }
                }

                return;
            }

            // Create the headers by analyzing the first content record
            var firstElement = $scope.content && $scope.content[0];

            if (firstElement && isJson(firstElement)) {
                $scope.headers = Object.keys(firstElement).map(function(x) { return { title: prettifyTitle(x), field: x };});
            }
            else {
                $scope.headers = firstElement ? firstElement.map(function(x) { return { title: prettifyTitle(x) };}) : [];
            }
        };

        var json2Matrix = function() {
            var newContent = [];
            $scope.content.forEach(function(cell) {
                var dataRow = [];

                for (var key in $scope.headers) {
                    if ($scope.headers.hasOwnProperty(key)) {
                        var field = $scope.headers[key];
                        if (field['decorate']) {
                            field = field['decorate'](_.get(cell, field['field']), cell);
                            dataRow.push(field);
                            continue;
                        }

                        dataRow.push(_.get(cell, field['field']));
                    }
                }
                newContent.push(dataRow);
            });

            $scope._content = newContent;
        };

        var initContent = function() {
            if (!Array.isArray($scope.content)) {
                console.warn('Content received is not an array. Doing your job for you...');
                $scope.content = $scope.content ? [$scope.content] : [];
            }

            // create array matrix from content
            if (isJson($scope.content && $scope.content[0])) {
                json2Matrix();
            }
        };

        // Initialization
        (function() {
            initHeaders();
            // Watch for any change in content (i.e - for pagination)
            $scope.$watch('content', initContent);
            // Could actually be called twice if the controller of the directive is constructed before the parent controller
            // TODO: Make UTs run with compiling the directive, and not with building the controller
            initContent();
        })();
    });
/* origin: public/webapp/directives/app-data-table/app-data-table.js */
angular.module('webApp')
    .directive('appDataTable', function() {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                // _headers is private since we receive the headers as JSON but we export a list
                _headers: '=?headers',
                content: '=',
                sortEventHandler: '=?'
            },
            templateUrl: 'directives/app-data-table/app-data-table.html',
            controller: 'appDataTableCtrl'
        };
    });
/* origin: public/webapp/directives/app-date-time-range-picker/app-date-time-range-picker-controller.js */
angular.module('webApp').controller('AppDateTimeRangePickerCtrl', function () {

    var self = this;

    self.dateRangeListener = function (range) {

        // Always take the day's end of the endDate (so 4-5 will show both 4th and 5th and not just what's in-between)
        range.endDateAsMoment = range.endDateAsMoment.endOf('day');
        range.endDate = range.endDateAsMoment.format(self.format);

        self.onSelectListener({range: range});
    };

    self.$onInit = function () {
        self.divider = self.divider || '-';
        self.format = self.format || 'YYYY-MM-DD';
        self._defaultStartDate = moment();
        self._defaultEndDate = moment();
        self.minDate = self.minDate ? self.minDate.format(self.format) : undefined;
        self.maxDate = self.maxDate ? self.maxDate.format(self.format) : undefined;
        self.ngModel = self.ngModel || {
            startDateAsMoment: self._defaultStartDate,
            startDate: self._defaultStartDate.format(self.format),
            endDateAsMoment: self._defaultEndDate,
            endDate: self._defaultEndDate.format(self.format)
        };

        // Since the directive does not support initial ngModel, we pass it as a string in its ng-model
        self.ngModel = [self.ngModel.startDate, ' ', self.divider, ' ', self.ngModel.endDate].join('');
    };
});
/* origin: public/webapp/directives/app-date-time-range-picker/app-date-time-range-picker.js */
// REMARK - did not add support for all attributes. Add them as needed.

angular.module('webApp').component('appDateTimeRangePicker', {
    templateUrl: 'directives/app-date-time-range-picker/app-date-time-range-picker.html',
    controller: 'AppDateTimeRangePickerCtrl',
    bindings: {
        ngModel: '=',
        format: '@',
        divider: '@',
        // Has to be moment
        // TODO: Support not 'moment' objects
        maxDate: '<?',
        // Has to be moment
        minDate: '<?',
        onSelectListener: '&'
    }
});
/* origin: public/webapp/directives/app-full-page-breadcrumbs/app-full-page-breadcrumbs-controller.js */
angular.module('webApp').controller('AppFullPageBreadcrumbsController', function ($scope) {
    var vm = this;

    vm.breadcrumbs = $scope.breadcrumbs;
});
/* origin: public/webapp/directives/app-full-page-breadcrumbs/app-full-page-breadcrumbs.js */
angular.module('webApp').directive('appFullPageBreadcrumbs', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/app-full-page-breadcrumbs/app-full-page-breadcrumbs.html',
        controller: 'AppFullPageBreadcrumbsController',
        controllerAs: 'vm',
        scope: {
            breadcrumbs: '='
        }
    };
});
/* origin: public/webapp/directives/app-group-buttons/app-group-buttons.js */
angular.module('webApp')
    .directive('appGroupButtons', function () {
        return {
            restrict: 'E',
            templateUrl: 'directives/app-group-buttons/app-group-buttons.html',
            controller: 'AppGroupButtonsController',
            scope: {
                buttonsData: '=',
                changeCallback: '&'
            },
            link: function($scope){
                $scope.mapValueToId = {};

                //parse value to id
                _.forEach($scope.buttonsData.data, function(button){
                    $scope.mapValueToId[button.value] = _.replace(_.snakeCase(button.value), '_', '-');
                });
            }
        };
    })
    .controller('AppGroupButtonsController', function ($scope) {

        $scope.buttonClick = function(selectedButton){
            $scope.buttonsData.value = selectedButton.value;

            if ($scope.changeCallback) {
                $scope.changeCallback({ value: $scope.buttonsData.value });
            }
        };

        $scope.isDisabled = function(value){
            if(!$scope.buttonsData.disabledBtnsList) return;

            return !$scope.buttonsData.disabledBtnsList.indexOf(value);
        };
    });
/* origin: public/webapp/directives/app-highchart/app-highchart.js */
angular.module('webApp').component('appHighchart', {
    controller: 'appHighchartCtrl',
    controllerAs: 'vm',
    template: '<div></div>',
    bindings: {
        config: '<',
        api: '=?'
    }
}).controller('appHighchartCtrl', function ($element, $timeout) {
    var vm = this;

    function initApi(api) {
        api.addSeries = function (seriesArr) {
            _.forEach(seriesArr, function (singleSeries) {
                var existingSeries = singleSeries.id ? vm.chart.get(singleSeries.id) : false;
                if (existingSeries) {
                    existingSeries.setData(singleSeries.data, false);
                }
                else {
                    vm.chart.addSeries(singleSeries, false);
                }
            });
            vm.chart.reflow();
            vm.chart.redraw();
        };
        api.removeSingleSeriesById = function (id, redraw) {
            var seriesToRemove = vm.chart.get(id);
            if (!seriesToRemove || !seriesToRemove.remove) return;
            seriesToRemove.remove(id, redraw);
        };
        api.removeSeries = function (ids) {
            if (_.isArray(ids)) {
                _.forEach(ids, function (id) {
                    api.removeSingleSeriesById(id, false);
                });
                vm.chart.redraw();
            }
            else {
                api.removeSingleSeriesById(ids, true);
            }
        };
        api.applyVerticalLines = function (data) {
            vm.chart.xAxis[0].plotLines = [];
            _.forEach(data, function (line) {
                vm.chart.xAxis[0].addPlotLine(line);
            });
            vm.chart.reflow();
            vm.chart.redraw();
        };
        api.setExtremes = function (startDate, endDate) {
            var xAxis = _.get(vm.chart, 'xAxis[0]');
            if (!xAxis) return;
            xAxis.setExtremes(startDate, endDate);
        };
        api.showLoading = function (loadingText) {
            vm.chart.showLoading(loadingText);
        };
        api.hideLoading = function () {
            vm.chart.hideLoading();
        };
    }

    this.$onInit = function () {
        vm.chart = Highcharts.chart($element[0], vm.config);

        // Adjust the chart to the div (when the container changes size after the chart is generated)
        $timeout(function () {vm.chart.reflow();}, 0);
        if (vm.api) initApi(vm.api);
    };
});
/* origin: public/webapp/directives/app-icon-toggle-animation/app-icon-toggle-animation.js */
angular.module('webApp')
    .directive('appIconToggleAnimation', function () {
        return {
            restrict: 'A',
        };
    });
/* origin: public/webapp/directives/app-multifilter/app-multifilter.js */
angular.module('webApp').directive('appMultiFilter', function () {
    return {
        restrict: 'E',
        scope: {
            api: '=',
            filterChangeCallback: '=',
            selectedFilters: '=',
            filterMultiselectGroup: '=',
        },
        controller: 'appMultiFilterCtrl',
        templateUrl: 'directives/app-multifilter/app-multifilter.html',
    };
}).controller('appMultiFilterCtrl', function ($scope, $compile) {

    $scope.api = $scope.api || {};

    var mapFilterIdToMultiselectItem = {};

    $scope.api.elementRemoved = function (item, bulkDelete) {
        if (item.data.isEmpty(item.data.data)) return;
        _.forEach(item.data.data, function (value) {
            value.model = false;
        });
        $scope.api.changeElementName(item, item.data.name);
        if (!bulkDelete) $scope.filterChangeCallback();
    };

    $scope.api.elementAddedCallback = function (item, element) {
        compileFilterPopover(item, element);
    };

    $scope.api.clearMultiFilter = function () {
        _.forEach(mapFilterIdToMultiselectItem, function (item) {
            $scope.api.removeElement(item, true);
        });
        $scope.filterChangeCallback();
    };

    function filterCloseCallbackFunction(popoverScope) {
        //check if filter data is empty, if do, remove it
        var filterData = popoverScope.data;
        var filterItem = mapFilterIdToMultiselectItem[filterData.id];

        if (filterData.isEmpty(filterData.data) && filterItem) {
            $scope.api.removeElement(filterItem);
        }
        else {
            var newName = filterData.getDisplayedName();
            $scope.api.changeElementName(filterItem, newName);
        }
    }

    function concat(string, options) {
        _.forEach(options, function (optionValue, optionName) {
            string = string.replace(new RegExp('{' + optionName + '}', 'g'), optionValue);
        });
        return string;
    }
    
    function compileFilterPopover(item, element) {
        var titleElement = angular.element(element[0].querySelector('.item-title'));
        var elementString = '<div logz-popover ' +
                                'ng-click="$event.stopPropagation()"' +
                                'popover-data="filterObject.{itemId}" ' +
                                'popover-open-on-creation="true" ' +
                                'popover-apply-callback="applyFilter" ' +
                                'popover-transclude="true" ' +
                                'popover-close-callback-function="filterCloseCallbackFunction" ' +
                                'popover-width="{itemWidth}">' +
                                '<app-actions-popover   action-type="{filterType}" model="data.data" ' +
                                                        'apply-action-callback-function="popoverApplyCallback">' +
                                '</app-actions-popover>' +
                            '</div>';
        var options = {
            itemId :item.data.id,
            itemWidth: item.data.width || '400',
            filterType: item.data.filterType
        };
        var popoverElement = angular.element(concat(elementString, options));
        popoverElement.css({
            width: 'calc(100% + 10px)',
            marginLeft: '-10px',
            height: '100%',
            position: 'absolute',
            backgroundColor: 'transparent',
            top: 0
        });
        mapFilterIdToMultiselectItem[item.data.id] = item;
        $scope.$parent.filterCloseCallbackFunction = filterCloseCallbackFunction;
        $compile(popoverElement)($scope.$parent);

        titleElement.append(popoverElement);
    }

});

//todo make the opening position from the start of the element

/* origin: public/webapp/directives/app-on-outside-element-click/app-on-outside-element-click.js */
angular.module('webApp').directive('appOnOutsideElementClick', ['$document',
    function($document) {
        return {
            restrict: 'A',
            scope: {
                'onOutsideElementClick': '='
            },
            link: function(scope, element) {

                function _docClick() {
                    // Using apply because otherwise there will be a delay until the next digest will happen.
                    scope.$apply(scope.onOutsideElementClick);
                }

                element.on('click', function(e) {
                    e.stopPropagation();

                    // Only bind click event when clicking on the element, and do not add another one if exists
                    if (_.findIndex($._data($document[0], 'events').click, {'handler': _docClick}) === -1) {
                        $document.on('click', _docClick);
                    }
                });


                scope.$on('$destroy', function() {
                    $document.off('click', scope.onOutsideElementClick);
                });
            }
        };
    }
]);
/* origin: public/webapp/directives/app-paginator/app-paginator.js */
// TODO: Support pages and not just from-to indices

angular.module('webApp')
    .directive('appPaginator', function() {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                pageNumber: '=',
                pageSize: '@',
                numOfResults: '@',
                pageChangedEvent: '='
            },
            templateUrl: 'directives/app-paginator/app-paginator.html',
            controller: 'appPaginatorCtrl'
        };
    })
    .controller('appPaginatorCtrl', function($scope) {
        $scope.firstPageItemIndex = function() {
            return $scope.pageSize * ($scope.pageNumber - 1) + 1;
        };

        $scope.lastPageItemIndex = function() {
            var lastIndex = +($scope.pageSize * ($scope.pageNumber));
            return Math.min(lastIndex, $scope.numOfResults);
        };

        $scope.prevPage = function () {
            if ($scope.pageNumber <= 1)
                return;

            $scope.pageNumber--;

            // Call the event handler for page change
            $scope.pageChangedEvent($scope.firstPageItemIndex(), $scope.lastPageItemIndex());
        };

        $scope.nextPage = function () {
            if ($scope.pageNumber >= ($scope.numOfResults / $scope.pageSize))
                return;

            $scope.pageNumber++;

            // Call the event handler for page change
            $scope.pageChangedEvent($scope.firstPageItemIndex(), $scope.lastPageItemIndex());
        };

        // Initialization
        (function() {
            $scope.pageSize = $scope.pageSize || 15;
            $scope.pageNumber =  $scope.pageNumber || 1;
            $scope.numOfResults = $scope.numOfResults || 0;
        })();
    });
/* origin: public/webapp/directives/app-select/app-select-controller.js */
/* eslint-disable max-lines */
angular.module('webApp').controller('AppSelectController', function ($q, $scope, $element, $document, $timeout, $attrs) {

    var vm = this;

    var getBooleanValue = function (value, defaultValue) {
        if (value === undefined) {
            return defaultValue;
        }

        return value !== 'false';
    };

    // Please notice - formName cannot have the letter '-'! otherwise we can't access it from $scope, camel case <3
    vm.formName = $scope.formName || [ 'appSelect', $scope.$id ].join('');

    vm.floatingMode = $scope.floatingMode;
    vm.menuAlign = $scope.menuAlign;
    vm.changeCallback = $scope.changeCallback;
    vm.emptyValueText = $scope.emptyValueText;
    vm.expansionCallback = $scope.expansionCallback;
    vm.addResetButton = getBooleanValue($scope.addResetButton, false); // Default value false
    vm.placeholder = $scope.placeholder;
    vm.customDomTemplateUrl = $scope.customDomTemplateUrl;
    vm.headerTemplateUrl = $scope.headerTemplateUrl;
    vm.footerTemplateUrl = $scope.footerTemplateUrl;
    vm.expansionTemplateUrl = $scope.expansionTemplateUrl;

    vm.options = $scope.options;

    vm.allowNew = getBooleanValue($scope.allowNew, false);
    vm.inputPlaceholder = $scope.inputPlaceholderOverride !== undefined
        ? $scope.inputPlaceholderOverride
        : vm.allowNew ? 'Type to filter / enter new' : 'Type to filter';

    var openOnHover = getBooleanValue($scope.openOnHover, false); // Default value false
    vm.arrayMode = getBooleanValue($scope.arrayMode, false); // Default value false
    vm.addCheckboxesToOptions = getBooleanValue($scope.addCheckboxesToOptions, false); // Default value false
    var closeMenuOnOptionClick = vm.arrayMode ? false : getBooleanValue($scope.closeMenuOnOptionClick, true); // True in checkbox mode, other than that default value true

    var initOptions = function (value) {
        vm.chosenOption = vm.arrayMode ? (ngModel.$modelValue || []) : (_.find(vm.options, { value: ngModel.$modelValue }) || {});
        markOptionsCheckedState();

        $timeout(function() {
            vm.selectedTitle = vm.arrayMode ? getSelectedTitleForArrayMode() : _.get(vm.chosenOption, 'text') || value || ngModel.$modelValue || vm.emptyValueText;
        }, 0);
    };
    var ngModel = $element.controller('ngModel'); // Hack to get NgModelController in the controller and not link function
    ngModel.$formatters.unshift(function (value) {
        initOptions(value);
        runNgModelValidations(value);
    });

    ngModel.$parsers.unshift(function (value) {
        runNgModelValidations(value);
        return vm.arrayMode ? vm.chosenOption : _.get(vm.chosenOption, 'value') || value;
    });

    var runNgModelValidations = function (value) {
        var invalid = false;
        if ($attrs.required) {
            invalid = invalid || _.isNil(value); // First operation but still, if invalid is true it will stay true else it will take validation value
            $scope[vm.formName].$setValidity('required', _.isNil(value)); // Set required validation value regardless to invalid value which may be different
        }

        vm.invalid = invalid;
    };

    var optionsContainer = $element.find('.options-container');
    var menuContainer = $element.find('.menu-container');

    var userInteractOpenMenu = function () {
        if (vm.ngDisabled || vm.active || vm.ngReadonly) return;

        $scope[vm.formName].$setDirty(); // For invalid marking

        optionsContainer[0].scrollTop = 0;

        openMenu();

        if (!openOnHover) {
            $timeout(function() {
                $document.on('click', documentClick);
            }, 0);
        }
    };

    var userInteractCloseMenu = function (event) {
        if (!vm.active) return;

        if (!openOnHover) {
            closeMenu();
            return;
        }

        var hoveredElement = event.toElement;
        if (hoveredElement && isDescendant($element[0], hoveredElement)) {
            return; // Hovering between children DOMs, shouldn't close menu
        }

        closeMenu();
    };

    if (openOnHover) {
        $element.bind('mouseover', userInteractOpenMenu);
        $element.bind('mouseout', userInteractCloseMenu);
    }
    else {
        var openMenuContainer = $element.find('.open-menu-container');
        openMenuContainer.click(function () {
            vm.active ? userInteractCloseMenu() : userInteractOpenMenu();
        });
    }

    var documentClick = function (e) {
        var clickedOnDropDown = menuContainer[0] === e.target || menuContainer.find(e.target).length > 0;
        if (clickedOnDropDown) {
            return;
        }

        closeMenu();
    };

    var isDescendant = function (parent, child) {
        var node = child.parentNode;
        while (node !== null) {
            if (parent === node) {
                return true;
            }

            node = node.parentNode;
        }
        return false;
    };

    var updateNgModelAndSelectedTitle = function (option) {
        var text = option.text;
        var isReset = _.isNil(option.value);

        vm.selectedTitle = isReset
            ? vm.emptyValueText || ''
            : vm.arrayMode ? getSelectedTitleForArrayMode() : text;

        var viewValue = isReset
            ? null
            : vm.arrayMode ? vm.selectedTitle : text;
        ngModel.$setViewValue(viewValue);
        ngModel.$commitViewValue();

        if (vm.changeCallback) {
            var callbackValue = isReset
                ? null
                : vm.arrayMode ? vm.chosenOption : option.value;
            vm.changeCallback({ value: callbackValue });
        }
    };

    var setActiveFlag = function (active) {
        // Need $timeout with 0 seconds to make sure this will have an affect on UI immediately (on next cycle)
        $timeout(function () { vm.active = active; }, 0);
    };

    var focusTimeout;
    var focusTimeoutRunning;
    var focusInput = function () {
        if (!_.get(valueInput[0], 'focus')) return;

        focusTimeoutRunning = true;
        focusTimeout = $timeout(function () {
            valueInput[0].focus();
            focusInput();
        }, 500);
    };

    var stopFocusInput = function () {
        if (focusTimeoutRunning) {
            focusTimeoutRunning = false;
            $timeout.cancel(focusTimeout);
        }
    };

    var openMenu = function () {
        focusInput();
        setActiveFlag(true);

        $timeout(function () {
            calculateWidthForFloatingMode(8);
        }, 100);

        // Subtract another pixel because we want the border-top of the menu list to be over the bottom line of our element
        menuContainer.css({
            top: [ $element.outerHeight(true) - appSelectBorderBottom - 1 + parsePxToInt($scope.menuMarginTop),  'px' ].join(''),
        });
    };

    var closeMenu = function (avoidNewValueHandling) {
        stopFocusInput();
        setActiveFlag(false);

        $timeout(function () {
            vm.newValue = '';
            calculateWidthForFloatingMode();
        }, vm.floatingMode ? 50 : 300); // Making the animation smooth

        // Subtract a pixel less than openMenu() because I want the close animation to avoid going over our element
        menuContainer.css({
            top: [ $element.outerHeight(true) - appSelectBorderBottom + parsePxToInt($scope.menuMarginTop),  'px' ].join(''),
        });

        $document.off('click', documentClick);

        if (!avoidNewValueHandling && vm.allowNew && vm.inInputMode) {
            vm.chosenOption = vm.newValue;
            updateNgModelAndSelectedTitle({ text: vm.newValue, value: vm.newValue });
        }

        vm.inInputMode = false;
        vm.hoveredOption = undefined;
        vm.expandedOption = undefined;

        vm.noMatchingOptionsForFilter = false;

        resetMenuWidth();
        $timeout(function () {
            optionsContainer.css({ height: '' });

            _.forEach(vm.options, function (option) {
                option.filtered = false;
            });

            $timeout(function () {
                resetMenuHeight();
            }, 200); // Reset expanded DOMs only after the unfilter animations, otherwise the height caulculation will be wrong
        }, 250); // Avoid showing the unfilter to the user, 250 MS is enough time to make the menu close animation almost done and the user wont notice the unfilter effect
    };

    vm.resetButtonClick = function (event) {
        if (vm.ngDisabled || vm.ngReadonly) return;

        event.stopPropagation();
        $scope[vm.formName].$setDirty(); // For invalid marking

        vm.chosenOption = vm.arrayMode ? [] : {};
        markOptionsCheckedState();
        updateNgModelAndSelectedTitle({});
    };

    vm.hoverOption = function (option) {
        vm.hoveredOption = option;
    };

    var getSelectedTitleForArrayMode = function () {
        return _.map(_.filter(vm.options, { checked: true }), 'text').join(', ');
    };

    vm.getNgClassForOption = function (option) {
        var ngClass = {
            'hover': vm.hoveredOption === option,
            'disabled': option.disabled,
            'separator': option.separator,
            'hide-option': option.filtered,
            'expanded-option': vm.expandedOption === option
        };

        if (option.customClass) {
            ngClass[option.customClass] = true;
            ngClass['custom-option'] = true;
        }

        return ngClass;
    };

    var markOptionsCheckedState = function () {
        if (!vm.arrayMode) return;

        _.forEach(vm.options, function (option) {
            option.checked = vm.chosenOption.indexOf(option.value) >= 0;
        });
    };

    vm.optionClick = function (option) {
        if (vm.ngDisabled || vm.ngReadonly || option.disabled || option.separator) return;

        if (option.customAction) {
            option.customAction();
            return;
        }
        else if (vm.expansionTemplateUrl && option.expand) {
            expandMenu(option);
            return;
        }
        else if (vm.arrayMode) {
            if (option.checked) {
                var valueIndex = vm.chosenOption.indexOf(option.value);
                if (valueIndex >= 0) {
                    vm.chosenOption.splice(valueIndex, 1);
                }
            }
            else {
                vm.chosenOption.push(option.value);
            }

            option.checked = !option.checked;
        }
        else {
            vm.chosenOption = _.isNil(option.value) ? undefined : option;
        }

        updateNgModelAndSelectedTitle(option);

        if (closeMenuOnOptionClick && !option.dontCloseMenu) {
            closeMenu(true);
        }
    };


    $scope.$watch('options', function () {
        vm.options = $scope.options;

        initOptions();
    });
    var optionsChangeWatcher = $scope.$watch(function () { return vm.options.length; }, function () {
        initOptions();
    });

    vm.elementKeyDown = function (event) {
        if (event.keyCode === 38 || event.keyCode === 40) {
            event.preventDefault(); // Don't let the browser handle the navigation keys press in select, we will handle it in elementKeyUp()
        }

        calculateWidthForFloatingMode();
    };

    vm.elementKeyUp = function (event) {
        if (!vm.active || vm.expandedOption) return;

        $timeout(function () {
            filterOptions();
            vm.inInputMode = _.get(vm, 'newValue.length') > 0;

            // Enter
            if (event.keyCode === 13) {
                if (vm.hoveredOption) {
                    vm.optionClick(vm.hoveredOption);
                }
                else if (vm.allowNew && vm.inInputMode) {
                    closeMenu();
                }
            }

            if (event.keyCode === 38 || event.keyCode === 40) {
                handleOptionsArrowUpDown(event.keyCode === 38);
            }
            else if (vm.allowNew) {
                // Because of enter functionality, user must use the arrow keys every time
                // to pick from list instead of entering a new input
                vm.hoveredOption = undefined;
            }
        }, 0);
    };

    if ($element[0].tabIndex === -1) {
        // Ugly hack to in order to listen to keydown on a non-input DOM
        $element[0].tabIndex = 6;
    }
    $element.keydown(vm.elementKeyDown);
    $element.keyup(vm.elementKeyUp);

    var handleOptionsArrowUpDown = function (goUp) {
        if (vm.expandedOption) {
            return; // Menu is expanded - navigation is locked
        }

        var hoverableOptions = [];
        _.forEach(vm.options, function (option) {
            if (option.disabled || option.separator || option.filtered) return;

            hoverableOptions.push(option);
        });

        if (!hoverableOptions.length) return;

        var currentHoverIndex = _.indexOf(hoverableOptions, vm.hoveredOption);
        if (currentHoverIndex === -1) {
            currentHoverIndex = goUp ? hoverableOptions.length - 1 : 0;
        }
        else {
            currentHoverIndex += goUp ? -1 : 1;
            if (hoverableOptions.length === currentHoverIndex) {
                currentHoverIndex = 0;
            }
            else if (currentHoverIndex === -1) {
                currentHoverIndex = hoverableOptions.length - 1;
            }
        }

        vm.hoveredOption = hoverableOptions[currentHoverIndex];
    };

    var containsEnteredInput = function (value) {
        if (!value || !vm.newValue) {
            return false;
        }

        return value.toLowerCase().indexOf(vm.newValue.toLowerCase()) >= 0;
    };

    var getFilterEffectArray = function (value) {
        var filterStartIndex = value.toLowerCase().indexOf(vm.newValue.toLowerCase());
        var beforeFilter = value.substring(0, filterStartIndex);
        var filter = value.substring(filterStartIndex, filterStartIndex + vm.newValue.length);
        var afterFilter = value.substring(filterStartIndex + vm.newValue.length);

        return [{
            value: beforeFilter,
            space: beforeFilter.endsWith(' ') || filter.startsWith(' ')
        }, {
            bold: true,
            value: filter,
            space: filter.endsWith(' ') || afterFilter.startsWith(' ')
        }, {
            value: afterFilter,
            space: afterFilter.startsWith(' ')
        }];
    };

    var filterOptions = function () {
        vm.noMatchingOptionsForFilter = true;

        _.forEach(vm.options, function (option) {
            var containsText = containsEnteredInput(option.text);
            var containsPrefix = containsEnteredInput(option.prefix);
            option.filtered = vm.newValue && (option.separator || (!containsText && !containsPrefix));

            if (option.filtered) {
                option.textFilterParts = [];
                option.prefixFilterParts = [];
            }
            else {
                vm.noMatchingOptionsForFilter = false;
                option.textFilterParts = containsText
                    ? getFilterEffectArray(option.text)
                    : [ { value: option.text } ];
                option.prefixFilterParts = containsPrefix
                    ? getFilterEffectArray(option.prefix)
                    : [ { value: option.prefix } ];
            }
        });
    };

    var resetMenuWidth = function () {
        var addNgHide = false;
        if ($element.hasClass('ng-hide')) {
            $element.removeClass('ng-hide');
            addNgHide = true;
        }

        // Get current width
        var initialWidth = [ menuContainer.outerWidth(true), 'px' ].join('');  // border-right & border-left

        // Remove any css value for width
        menuContainer.css({
            width: ''
        });

        // Calculate the free spirit menuContainer width (without expansion values)
        // outerWidth(true) - border-right & border-left
        // Minimum 85 width for "No match" filter message
        var newWidth = Math.round(Math.max(menuContainer.outerWidth(true), 85));
        var newWidthPx = [ newWidth, 'px' ].join('');

        if (addNgHide) {
            $element.addClass('ng-hide');
        }

        // Apply the old width back
        menuContainer.css({
            width: initialWidth
        });

        // And now it's show time, without $timeout there will be no animation
        $timeout(function () {
            menuContainer.css({
                width: newWidthPx
            });
        }, 0);
    };

    var parsePxToInt = function (value) {
        if (value === undefined) {
            return 0;
        }

        return parseInt(value.replace(/px.*/, ''));
    };

    var resetMenuHeight = function () {
        optionsContainer.css({
            'max-height': optionsContainerMaxHeight
        });

        var headerHeight = vm.headerTemplateUrl ? headerContainer.outerHeight(true) : 0;
        var footerHeight = vm.footerTemplateUrl ? footerContainer.outerHeight(true) : 0;
        var menuContainerHeightAddon = parsePxToInt(menuContainer.css('border-top-width')) + parsePxToInt(menuContainer.css('border-bottom-width'));
        var newHeight = [ parsePxToInt(optionsContainerMaxHeight) + menuContainerHeightAddon + headerHeight + footerHeight, 'px' ].join('');

        menuContainer.css({
            'max-height': newHeight
        });
    };

    if ($scope.menuCustomWidth) {
        optionsContainer.css({ width: $scope.menuCustomWidth });
    }

    var expansionContainer;
    var headerContainer;
    var footerContainer;

    var appSelectDivContainer = $element.find('.app-select');
    var appSelectBorderBottom = parsePxToInt(appSelectDivContainer.css('border-bottom-width'));

    var setMenuAlignment = function () {
        var borderLeftWidth = appSelectDivContainer.css('border-left-width');
        var borderRightWidth = appSelectDivContainer.css('border-right-width');

        if (vm.menuAlign === 'center') {
            var offsetLeft = parsePxToInt(borderLeftWidth) + ((menuContainer.outerWidth(true) - $element.width()) / 2);
            menuContainer.css({ left: [ '-', offsetLeft, 'px' ].join('') });
        }
        else if (vm.menuAlign === 'right') {
            menuContainer.css({ right: [ '-', borderRightWidth, ].join('') });
        }
        else {
            menuContainer.css({ left: [ '-', borderLeftWidth, ].join('') });
        }
    };

    var valueInput;
    var valueContainer;
    $timeout(function () {
        valueInput = $element.find('.value-input');
        valueContainer = $element.find('.value-container')[0];
        $timeout(function () {
            calculateWidthForFloatingMode();
        }, 100);

        if (!$scope.menuCustomWidth && !vm.floatingMode) {
            var substractFromWidth = parsePxToInt(menuContainer.css('border-left-width')) + parsePxToInt(menuContainer.css('border-right-width'));
            var elementWidth = [ $element.width() - substractFromWidth, 'px' ].join('');
            optionsContainer.css({ width: $scope.menuCustomWidth || elementWidth });
        }

        setMenuAlignment();

        if (vm.expansionTemplateUrl) {
            expansionContainer = $element.find('.expansion-container');
            expansionContainer.css({
                left: [ optionsContainer.width(), 'px' ].join('')
            });
        }
        if (vm.headerTemplateUrl) {
            headerContainer = $element.find('.header-container');
            headerContainer.css({ width: elementWidth });
        }

        if (vm.footerTemplateUrl) {
            footerContainer = $element.find('.footer-container');
            footerContainer.css({ width: elementWidth });
        }

        resetMenuWidth();
        resetMenuHeight();
    }, 0);

    var optionsContainerMaxHeight = $scope.menuMaxHeight || '236px';
    optionsContainer.css({ 'max-height': optionsContainerMaxHeight });
    var expandMenu = function (option) {
        var alreadyExpanded = vm.expandedOption !== undefined;

        vm.expandedOption = option;
        vm.newValue = vm.expandedOption.text;

        calculateWidthForFloatingMode();

        if (alreadyExpanded) {
            return;
        }

        stopFocusInput();

        var widthAddon = parsePxToInt(menuContainer.css('border-left-width')) + parsePxToInt(menuContainer.css('border-right-width')) + parsePxToInt(expansionContainer.css('border-left-width'));
        var newWidth = menuContainer.width() + expansionContainer.width() + widthAddon;
        var headerHeight = vm.headerTemplateUrl ? headerContainer.outerHeight(true) : 0;
        var footerHeight = vm.footerTemplateUrl ? footerContainer.outerHeight(true) : 0;

        menuContainer.css({
            width: [ newWidth, 'px' ].join(''),
            'max-height': [ expansionContainer.height(), 'px' ].join('')
        });

        optionsContainer.css({
            'max-height': [ optionsContainer.outerHeight(true), 'px' ].join(''),
        });

        $timeout(function () {
            optionsContainer.css({
                'max-height': [ expansionContainer.height() - footerHeight - headerHeight, 'px' ].join(''),
                height: [ expansionContainer.height() - footerHeight - headerHeight, 'px' ].join('')
            });
        }, 0);
    };

    vm.doneWithExpansion = function (objectToPass) {
        vm.expansionCallback({ value: objectToPass });

        updateNgModelAndSelectedTitle(vm.expandedOption);
        closeMenu(true);
    };

    var calculateWidthForFloatingMode = function (hardWidth) {
        $timeout(function () {
            if (!vm.floatingMode) {
                return;
            }

            $element.css('width', '');
            var scrollWidth = valueContainer.scrollWidth;
            if (!vm.active) {
                scrollWidth--; // IDK WHY BUT MY OCD WANTS THIS ANIMATION PERFECT, SO scrollWidth-- IT IS!
            }
            var width = (hardWidth || Math.max(scrollWidth, 8)) + 28; // 8 due to padding and +28 due to svg arrow down
            $element.css('width', [ width, 'px' ].join(''));
        }, 100);
    };

    var disabledWatcher = $scope.$watch('ngDisabled', function () {
        vm.ngDisabled = $scope.ngDisabled;

        if (vm.ngDisabled) {
            closeMenu();
        }
    });

    var readonlyWatcher = $scope.$watch('ngReadonly', function () {
        vm.ngReadonly = $scope.ngReadonly;

        if (vm.ngReadonly) {
            closeMenu();
        }
    });

    var hideArrowWatcher = $scope.$watch('hideArrowDown', function () {
        vm.hideArrowDown = $scope.hideArrowDown;
    });

    var setInvalidWatcher = $scope.$watch('setInvalid', function () {
        vm.setInvalid = $scope.setInvalid;
        vm.invalid = vm.invalid || vm.setInvalid; // If setInvalid is true vm.invalid (Josh) equals true - otherwise vm.invalid equals false
        $scope[vm.formName].$setValidity('setInvalid', !vm.invalid);
    });

    $scope.$on('$destroy', function () {
        if ($element) $element.unbind();
        if (optionsChangeWatcher) optionsChangeWatcher();
        if (setInvalidWatcher) setInvalidWatcher();
        if (disabledWatcher) disabledWatcher();
        if (readonlyWatcher) readonlyWatcher();
        if (hideArrowWatcher) hideArrowWatcher();

        stopFocusInput();

        $document.off('click', documentClick);
    });
});
/* eslint-enable max-lines */
/* origin: public/webapp/directives/app-select/app-select.js */
angular.module('webApp').directive('appSelect', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/app-select/app-select.html',
        controller: 'AppSelectController',
        controllerAs: 'vm',
        require: 'ngModel',
        scope: {
            // Notice - any change here should be copied to the styleguide arguments list


            // Should be an array of objects like this
            // [{
            //     text: 'Giggs',
            //     value: giggs'
            // }, {
            //    text: 'Dota',
            //    value: 'dota',
            //    expand: true
            // }, {
            //    separator: true
            // }, {
            //     text: 'Click me', // Must have - for filter, you can leave it '' if you don't want to find it in filter
            //     templateUrl: 'app/styleguide/app/app-selector-templates/app-selector-custom-option.html',
            //     customAction: function () {
            //         alert('Im a custom option action!');
            //     },
            //     customClass: 'styleguide-app-selector-custom-option',
            //     dontCloseMenu: true
            // }, {
            //     text: 'But I set a value',
            //     value: 'I AM VALUE',
            //     templateUrl: 'app/styleguide/app/app-selector-templates/app-selector-custom-option3.html',
            //     customClass: 'styleguide-app-selector-custom-option',
            // }, {
            //     text: 'Shesh6',
            //     value: 'shesh6',
            // }, {
            //     text: 'And I reset ngModel',
            //     // No need to pass value!
            //     templateUrl: 'app/styleguide/app/app-selector-templates/app-selector-custom-option4.html',
            //     customClass: 'styleguide-app-selector-custom-option',
            // }]
            options: '=',

            // Form name, if not specified - appSelect + $scope.$id will be used
            formName: '<',

            // Famous and wonderful floating mode (no borders no hardcoded width)
            floatingMode: '<',

            // Menu alignment compared to $element, default is left but you can use 'center' & 'right' as well
            menuAlign: '@',

            // ngModel is an array of selected options
            arrayMode: '@',

            // This has an effect only if arrayMode is set true
            addCheckboxesToOptions: '@',

            // Callback to fire every time the ngModel value is updated
            changeCallback: '&',

            // Flag to set & style select as disabled
            ngDisabled: '=',

            // Flag to set select as readonly (clicking it wont do anything)
            ngReadonly: '=',

            // Text to display as long as no option was selected
            emptyValueText: '<',

            // Hide arrow down svg in input box
            hideArrowDown: '=',

            // Whether to close the menu after an option has been clicked, default value is true
            closeMenuOnOptionClick: '@',

            // Whether to add the X gray button to remove the selected value without choosing another option, default value is false
            addResetButton: '@',

            // Flag to set & style select as invalid on demand
            setInvalid: '=',

            // Text to display while no option was chosen
            placeholder: '@',

            // Text to display when filtering
            inputPlaceholderOverride: '@',

            // Open menu on hover (DOH), default value is false
            openOnHover: '@',

            // Allow the user to enter new values that aren't in options, this should be set true only if allowFilter is true as well
            allowNew: '@',

            // Menu margin top addon (to make the menu be a few pixels underneath the opener DOM)
            menuMarginTop: '@',

            // Menu maximum height (before expansion), default is 236px - 7 options
            menuMaxHeight: '@',

            // Menu custom width (before expansion), default is element width (you can change it using your less file)
            menuCustomWidth: '@',

            // Custom DOM template url (instead of the regular input box with arrow), TEMPLATE WIDTH MUST BE A NATURAL NUMBER (i.e not 87.5px like an app-btn with text "Click Me")
            customDomTemplateUrl: '=',

            // Header template url
            headerTemplateUrl: '=',

            // Footer template url
            footerTemplateUrl: '=',

            // Expansion template url
            expansionTemplateUrl: '=',

            // Expansion callback to call with entered expansion inputs after user is done
            // Expansion templates must have a button that calls vm.doneWithExpansion()
            // and pass whatever value you want to be used when calling expansionCallback()
            expansionCallback: '&'
        }
    };
});
/* origin: public/webapp/directives/app-severity/app-severity.js */
angular.module('webApp').component('appSeverity', {
    templateUrl: 'directives/app-severity/app-severity.html',
    bindings: {
        severity: '='
    },
    controllerAs: 'vm',
    controller: function () {
        this.mapSeverityToTitle = {
            'HIGH': 'Critical',
            'MEDIUM': 'Important',
            'LOW': 'Notable'
        };
    }
});
/* origin: public/webapp/directives/app-support-access-change-panel/app-support-access-change-panel-controller.js */
angular.module('webApp').controller('appSupportAccessChangePanelController', function ($q, $scope, Backend) {
    var vm = this;
    var initSupportAccessEnd = function () {
        vm.supportAccessEnd = $scope.supportAccessEnd * 1000; // services returns this in seconds count, in JS we work with milliseconds
    };
    initSupportAccessEnd();
    vm.editingModel = $scope.editingModel;

    vm.supportAccessOptions = [{
        text: '1 day',
        value: function () {
            var date = new Date();
            date.setDate(date.getDate() + 1);
            return date;
        }
    }, {
        text: '2 days',
        value: function () {
            var date = new Date();
            date.setDate(date.getDate() + 2);
            return date;
        }
    }, {
        text: '1 week',
        value: function () {
            var date = new Date();
            date.setDate(date.getDate() + 7);
            return date;
        }
    }, {
        text: '1 month',
        value: function () {
            var date = new Date();
            date.setMonth(date.getMonth() + 1);
            return date;
        }
    }, {
        text: 'Forever',
        value: function () {
            // 16/12/2037 17:02:37, MySql DateTime supports max value of 1/1/2038 00:00:00
            // Till we upgrade our MySql -> this is it, BTW this is Ori Riechman's birthday!
            return new Date(2144588557000);
        }
    }];
    vm.supportAccessModel = vm.supportAccessOptions[0].value;

    var setForever = function () {
        vm.forever = Math.abs(new Date(vm.supportAccessEnd - new Date()).getUTCFullYear() - 1970) > 5; // More than 5 years? OK this is forever for us
    };

    var initSupportAccessToggleModelValue = function () {
        vm.supportAccessToggleData.value = $scope.supportAccessEnd !== undefined;
        setForever();
    };

    vm.supportAccessToggleData = {
        leftOption: {
            label: 'Enabled',
            value: true
        },
        rightOption: {
            label: 'Disabled',
            value: false
        }
    };
    initSupportAccessToggleModelValue();

    vm.optionsCallback = function (value) {
        vm.supportAccessEnd = value().getTime();
        setForever();
    };

    vm.toggleEditChangeCallback = function (value) {
        vm.supportAccessToggleData.value = value;

        if (value) {
            // Enable mode - option picked
            vm.optionsCallback(vm.supportAccessModel);
            vm.editingModel.value = true;
            return;
        }

        // Disable mode
        var alreadyDisabled = $scope.supportAccessEnd === undefined;

        $scope.supportAccessEnd = undefined;
        vm.editingModel.value = false;
        initSupportAccessEnd();
        setForever();

        if (!alreadyDisabled) {
            Backend.POST('/support-access/disable');
        }
    };

    vm.cancelEdit = function () {
        vm.editingModel.value = false;
        initSupportAccessEnd();
        initSupportAccessToggleModelValue();
    };

    vm.submitEdit = function () {
        $scope.supportAccessEnd = vm.supportAccessEnd / 1000; // services returns this in seconds count, in JS we work with milliseconds
        vm.editingModel.value = false;

        var chosenDate = new Date(vm.supportAccessEnd);
        var diffMs = chosenDate - new Date();
        var diffMins = diffMs / 1000 / 60;
        var data = {
            durationInMinutes: Math.round(diffMins)
        };
        Backend.POST('/support-access/enable', data);
    };
});

/* origin: public/webapp/directives/app-support-access-change-panel/app-support-access-change-panel.js */
angular.module('webApp').directive('appSupportAccessChangePanel', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/app-support-access-change-panel/app-support-access-change-panel.html',
        controller: 'appSupportAccessChangePanelController',
        controllerAs: 'vm',
        scope: {
            supportAccessEnd: '=',
            editingModel: '='
        }
    };
});
/* origin: public/webapp/directives/app-switch/app-switch.js */
angular.module('webApp').component('appSwitch', {
    templateUrl: 'directives/app-switch/app-switch.html',
    transclude: true,
    require: {
        ngModel: '^ngModel'
    },
    bindings: {
        updateCallback: '<'
    },
    controllerAs: 'vm',
    controller: function () {

        var self = this;
        self.$onInit = function () {
            self.ngModel.$render = function () {
                self.model = self.ngModel.$viewValue;
            };
            self.updateCallback = self.updateCallback || function () {};
        };
        self.$onChanges = function (changes) {
            self.ngModel.$setViewValue(changes.ngModel);
        };

        self.toggle = function () {
            self.model = !self.model;
            self.updateCallback(self.model);

            self.ngModel.$setViewValue(self.model);
        };

    }

})
;
/* origin: public/webapp/directives/app-table/app-table-cell/app-table-cell-component.js */
angular.module('webApp').component('appTableCell', {
    transclude: true,
    templateUrl: 'directives/app-table/app-table-cell/app-table-cell.html',
});
/* origin: public/webapp/directives/app-table/app-table-component.js */
angular.module('webApp').component('appTable', {
    controller: 'appTableCtrl',
    controllerAs: 'vm',
    templateUrl: 'directives/app-table/app-table.html',
    transclude: {
        header: 'appTableHeader'
    },
    bindings: {
        apiObj: '=?'
    }
});
/* origin: public/webapp/directives/app-table/app-table-controller.js */
angular.module('webApp').controller('appTableCtrl', function () {
    var self = this;

    self.$onInit = function () {
        self.apiObj = self.apiObj || {};
        self.apiObj.rows = {};
        self.apiObj.sections = {};
    };
});
/* origin: public/webapp/directives/app-table/app-table-expansion-panel/app-table-expansion-panel-component.js */
angular.module('webApp').component('appTableExpansionPanel', {
    controller: 'appTableExpansionPanelCtrl',
    controllerAs: 'vm',
    transclude: true,
    require: {
        row: '^appTableRow'
    },
    templateUrl: 'directives/app-table/app-table-expansion-panel/app-table-expansion-panel.html'
});
/* origin: public/webapp/directives/app-table/app-table-expansion-panel/app-table-expansion-panel-controller.js */
angular.module('webApp').controller('appTableExpansionPanelCtrl', function ($element, $timeout) {
    var self = this;

    /**
     * Apply the content height as a 'height' attribute (for the height animation)
     * @private
     */
    self._applyContentHeight = function () {
        self.$_element.css({
            height: self.element.scrollHeight + 'px'
        });
    };

    self.$onInit = function () {
        self.$_element = $element.find('.app-table-expansion-panel-container');
        self.element = self.$_element[0];

        // Calculate height for the expansion animation
        $timeout(self._applyContentHeight, 0);
    };

    self.$onDestroy = function () {
        // Important - We want to add this class to the ng-if element, so the height of our element won't be auto anymore.
        self.$_element.closest('.app-table-row-expansion').addClass('ng-leave');
        // Calculate height for the expansion animation
        self._applyContentHeight();

        // Reset the height of the element - for the animation
        self.$_element.css({
            height: 0
        });
    };

});
/* origin: public/webapp/directives/app-table/app-table-header-cell/app-table-header-cell-component.js */
angular.module('webApp').component('appTableHeaderCell', {
    controller: 'appTableHeaderCellCtrl',
    controllerAs: 'vm',
    transclude: true,
    templateUrl: 'directives/app-table/app-table-header-cell/app-table-header-cell.html',
    require: {
        header: '^appTableHeader'
    },
    bindings: {
        sortField: '@?',
        /**
         * ~ Requires `sort-field` to be present ~
         * Is the cell already sorted?
         * Options:
         *      - descending
         *      - ascending
         */
        sorted: '@?'
    }
});
/* origin: public/webapp/directives/app-table/app-table-header-cell/app-table-header-cell-controller.js */
angular.module('webApp').controller('appTableHeaderCellCtrl', function () {

    var self = this;

    self.shouldShowSortIcon = function () {
        return self.sortField !== undefined && self.isDescending() !== undefined;
    };

    self._validateSorted = function () {
        if (self.sorted !== undefined && self.sortField === undefined) {
            console.warn('`sort-field` is not defined while `sorted` is. This will cause sorting not to work as expected.');
            return false;
        }
        else if (self.sortField !== undefined) {
            return true;
        }

        return false;
    };

    self._sortedStringToBoolean = function () {
        return self.sorted === 'descending';
    };

    self.isSorted = function () {
        return _.get(self.header.getSortField(), 'field') === self.sortField;
    };

    self.isDescending = function () {
        return self.isSorted() ? self.header.getSortField().isDescending : null;
    };

    /**
     *
     * @param optionalIsDescending - Basically only for the $onInit, when we might pass a isDescending = false,
     *                               but we still want the next time we toggle the sorting on the field after having sorted
     *                               a different field, to be descending
     *                               e.g - Starting on field 'a' with sorted='ascending'. Now I click field 'b' and it's
     *                                     sorting is 'descending'. Now I click field 'a', and I want it to be descending,
     *                                     and not ascending.
     */
    self.setSorted = function (optionalIsDescending) {
        if (self.sortable) {
            var isDescending = optionalIsDescending !== undefined ? optionalIsDescending : true;

            if (self.isSorted()) {
                isDescending = !self.isDescending();
            }

            self.header.setSortField(self.sortField, isDescending);
        }
    };

    self.$onInit = function () {
        self.sortable = self._validateSorted();

        // Set the cell as sorted if you're requested to in the beginning
        if (self.sorted !== undefined) {
            self.setSorted(self._sortedStringToBoolean());
        }
    };
});
/* origin: public/webapp/directives/app-table/app-table-header/app-table-header-component.js */
angular.module('webApp').component('appTableHeader', {
    controller: 'appTableHeaderCtrl',
    controllerAs: 'vm',
    transclude: true,
    templateUrl: 'directives/app-table/app-table-header/app-table-header.html',
    require: {
        appTable: '^appTable'
    },
    bindings: {
        /**
         * ~Required if you want to sort columns~
         *
         * This handler is called whenever a sortable field is toggled for sorting.
         * The handler's function receives the name of the field that is being toggled
         * (by the inner <app-table-cell sort-field='<name>'>)
         * The function also receives the direction of the sorting (Boolean: true - descending, false - ascending)
         * Example of usage:
         *
         * <app-table-header sort-event-handler='vm.sortHandler(fieldName, isDescending)'>
         *     <app-table-cell sort-field='@timestamp'></app-table-cell>
         * </app-table-header>
         */
        sortEventHandler: '&?',
    }
});
/* origin: public/webapp/directives/app-table/app-table-header/app-table-header-controller.js */
angular.module('webApp').controller('appTableHeaderCtrl', function () {

    var self = this;

    /**
     * A wrapper for the sort event handler
     * @private
     */
    self._sortEventHandler = function (field, isDescending) {
        self.sortEventHandler({field: field, isDescending: isDescending});
    };

    /**
     * Basically able to hold only the latest caller who says it's the sorted field
     * @param field
     * @param isDescending
     */
    self.setSortField = function (field, isDescending) {
        // To not trigger the event one the beginning
        var isInitialAssignment = (self._sortField === null);

        self._sortField = {
            field: field,
            isDescending: isDescending
        };

        if (!isInitialAssignment) {
            self._sortEventHandler(self._sortField.field, self._sortField.isDescending);
        }
    };

    self.getSortField = function () {
        return self._sortField;
    };

    self.$onInit = function () {
        self._sortField = null;
    };
});
/* origin: public/webapp/directives/app-table/app-table-pagination/app-table-pagination-component.js */
angular.module('webApp').component('appTablePagination', {
    templateUrl: 'directives/app-table/app-table-pagination/app-table-pagination.html',
    controller: 'appTablePaginationCtrl',
    controllerAs: 'vm',
    bindings: {
        pageSize: '@?',
        totalResults: '@?',
        pageNumber: '@?page',
        onPageChange: '&'
    }
});
/* origin: public/webapp/directives/app-table/app-table-pagination/app-table-pagination-controller.js */
angular.module('webApp').controller('appTablePaginationCtrl', function () {
    var self = this;

    self.firstIndexOfPage = function() {
        return self.pageSize * (self.pageNumber - 1) + 1;
    };

    self.lastIndexOfPage = function() {
        var lastIndex = +(self.pageSize * (self.pageNumber));
        return Math.min(lastIndex, self.totalResults);
    };

    self.prevPage = function () {
        if (self.hasReachedMin()) {
            return;
        }

        self.pageNumber--;

        // Call the event handler for page change
        self.onPageChange({ pageNumber: self.pageNumber });
    };

    self.nextPage = function () {
        if (self.hasReachedMax()) {
            return;
        }

        self.pageNumber++;

        // Call the event handler for page change
        self.onPageChange({ pageNumber: self.pageNumber });
    };

    self.hasReachedMax = function () {
        return self.pageNumber >= (self.totalResults / self.pageSize);
    };

    self.hasReachedMin = function () {
        return self.pageNumber <= 1;
    };

    self.$onInit = function () {
        self.pageSize = self.pageSize || 15;
        self.pageNumber =  self.pageNumber || 1;
        self.totalResults = self.totalResults || 0;
    };
});
/* origin: public/webapp/directives/app-table/app-table-row/app-table-row-component.js */
angular.module('webApp').component('appTableRow', {
    controller: 'appTableRowCtrl',
    controllerAs: 'vm',
    templateUrl: 'directives/app-table/app-table-row/app-table-row.html',
    require: {
        appTable: '^appTable',
        section: '^?appTableSection'
    },
    transclude: {
        expansion: '?appTableExpansionPanel'
    },
    bindings: {
        hash: '@?'
    }
});
/* origin: public/webapp/directives/app-table/app-table-row/app-table-row-controller.js */
angular.module('webApp').controller('appTableRowCtrl', function ($element, $transclude) {
    var self = this;

    self.toggleExpansion = function () {
        if (!self.hasExpansionPanel()) {
            return false;
        }

        self.isExpanded = !self.isExpanded;

        if (self.hasHashForApi) {
            self.rowApi.isExpanded = self.isExpanded;
        }
    };

    self._initializeApiObj = function (container) {
        self.rowApi = container;
        self.rowApi.isExpanded = (self.isExpanded !== undefined) ? self.isExpanded : false;
    };

    /**
     * Let us know if there's an expansion panel
     */
    self.hasExpansionPanel = function () {
        return $transclude.isSlotFilled('expansion');
    };

    self.$onInit = function () {
        self.hasHashForApi = self.hash;

        if (self.hasHashForApi) {
            if (self.section && self.section.sectionApi) {
                // We can't do this in the initialize since we need to make it a complex type for the reference
                self.section.sectionApi.rows[self.hash] = {};
                self._initializeApiObj(self.section.sectionApi.rows[self.hash]);
            }
            else {
                // We can't do this in the initialize since we need to make it a complex type for the reference
                self.appTable.apiObj.rows[self.hash] = {};
                self._initializeApiObj(self.appTable.apiObj.rows[self.hash]);
            }
        }
    };
});
/* origin: public/webapp/directives/app-table/app-table-section/app-table-section-component.js */
angular.module('webApp').component('appTableSection', {
    controller: 'appTableSectionCtrl',
    controllerAs: 'vm',
    templateUrl: 'directives/app-table/app-table-section/app-table-section.html',
    transclude: {
        title: '?appTableSectionHeader'
    },
    bindings: {
        isExpanded: '<',
        hash: '@?'
    },
    require: {
        appTable: '^appTable'
    }
});
/* origin: public/webapp/directives/app-table/app-table-section/app-table-section-controller.js */
angular.module('webApp').controller('appTableSectionCtrl', function ($element) {
    var self = this;

    self.toggleExpansion = function () {
        // Calculate height for the expansion animation
        // The order is important!! Otherwise the height could be calculated AFTER we remove the ng-hide-remove-active class
        self._applyContentHeight();

        // Hack to remove the 'height: auto !important' for the closing animation
        if (self.isExpanded) {
            self.$_element.addClass('ng-hide-remove-active');
        }

        self.isExpanded = !self.isExpanded;

        if (self.hasHashForApi) {
            self.sectionApi.isExpanded = self.isExpanded;
        }
    };

    /**
     * Apply the content height as a 'height' attribute (for the height animation)
     * @private
     */
    self._applyContentHeight = function () {
        self.$_element.css({
            height: self.element.scrollHeight + 'px'
        });
    };

    self._initializeApiObj = function () {
        self.sectionApi.isExpanded = self.isExpanded;
    };

    self.$onInit = function () {
        self.$_element = $element.find('.app-table-section-content');
        self.element = self.$_element[0];
        self.hasHashForApi = self.hash;

        self.isExpanded = self.isExpanded !== undefined ? self.isExpanded : false;

        if (self.hasHashForApi) {
            self.appTable.apiObj.sections[self.hash] = {};
            self.sectionApi = self.appTable.apiObj.sections[self.hash];
            self.sectionApi.rows = {};
            self._initializeApiObj();
        }
    };
});
/* origin: public/webapp/directives/app-table/app-table-section/app-table-section-header/app-table-section-header-component.js */
angular.module('webApp').component('appTableSectionHeader', {
    controller: 'appTableSectionHeaderCtrl',
    controllerAs: 'vm',
    transclude: {
        'checkbox': '?sectionCheckbox'
    },
    require: {
        section: '^appTableSection'
    },
    templateUrl: 'directives/app-table/app-table-section/app-table-section-header/app-table-section-header.html'
});
/* origin: public/webapp/directives/app-table/app-table-section/app-table-section-header/app-table-section-header-controller.js */
angular.module('webApp').controller('appTableSectionHeaderCtrl', function () {
    // This controller is still being used by the template
});
/* origin: public/webapp/directives/app-toggle/app-toggle-controller.js */
angular.module('webApp').controller('AppToggleController', function ($scope, $element, $timeout) {

    // I want to avoid the initialize animation, should be animated only after first value was set
    $element.addClass('no-animation');
    $timeout(function () {
        $element.removeClass('no-animation');
    }, 0);

    var vm = this;

    vm.leftOption = $scope.toggleData.leftOption;
    vm.rightOption = $scope.toggleData.rightOption;

    $element.click(function () {
        $scope.$apply(function () {
            vm.selectedOption = vm.selectedOption === vm.leftOption
                ? vm.rightOption
                : vm.leftOption;

            $scope.toggleData.value = vm.selectedOption.value;

            if ($scope.changeCallback) {
                $scope.changeCallback({ value: $scope.toggleData.value });
            }
        });
    });

    var valueChangeWatcher = $scope.$watch('toggleData.value', function () {
        vm.selectedOption = vm.leftOption.value === $scope.toggleData.value
            ? vm.leftOption
            : vm.rightOption;
    });

    $scope.$on('$destroy', function () {
        if (valueChangeWatcher) valueChangeWatcher();
    });
});

/* origin: public/webapp/directives/app-toggle/app-toggle.js */
angular.module('webApp').directive('appToggle', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/app-toggle/app-toggle.html',
        controller: 'AppToggleController',
        controllerAs: 'vm',
        scope: {
            toggleData: '=',
            changeCallback: '&'
        }
    };
});
/* origin: public/webapp/directives/app-tooltip/app-tooltip-component.js */
angular.module('webApp').component('appTooltip', {
    controller: 'appTooltipCtrl',
    controllerAs: 'vm',
    templateUrl: 'directives/app-tooltip/app-tooltip.html',
    transclude: true,
    bindings: {
        delay: '@?'
    }
});
/* origin: public/webapp/directives/app-tooltip/app-tooltip-controller.js */
angular.module('webApp').controller('appTooltipCtrl', function ($element, $scope, $timeout, $document) {
    var self = this;

    self.$onInit = function () {
        self.isHovering = false;
        self.delay = self.delay || 0;

        // Override parent css to be able to correctly display the tooltip
        self.parentElement = angular.element($element[0].parentElement);

        self.parentElement.on('mouseenter', function () {
            // Get the location of the original parent
            var targetRect = self.parentElement[0].getBoundingClientRect();
            // And add its co-ordinates to the tooltip
            $element.css({top: (targetRect.bottom + window.pageYOffset), left: targetRect.left});

            // Activate the tooltip with an optional delay
            self.tooltipRequest = $timeout(function () {
                self.isHovering = true;
            }, self.delay);
        });

        self.parentElement.on('mouseleave', function () {
            self.isHovering = false;

            // Cancel any on-going delays of tooltips
            $timeout.cancel(self.tooltipRequest);

            // Let angular know that we've made a change (since we go through the parent element)
            $scope.$apply();
        });

        $element.appendTo($document.find('body'));
    };


    $scope.$on('$destroy', function () {
        self.parentElement.off('mouseover');
        self.parentElement.off('mouseleave');
    });
});
/* origin: public/webapp/directives/asterisk-note-with-dialog/asterisk-note-with-dialog-controller.js */
angular.module('webApp').controller('AsteriskNoteWithDialogController', function ($scope, $document, $timeout, $element) {
    $scope.dialogShouldBeOpened = false;

    $scope.closeDialog = function (event) {
        if (event && $element.has(event.target).length > 0) {
            $document.one('click', $scope.closeDialog);
            return; // Event sent from an inner click within the dialog, shouldn't close
        }

        // Not really sure why, but without the $timeout the close performs after a small delay, doing $scope.$apply isn't a good solution due to $document.one and closeFunc direct calling being called the same time and angular throws an exception
        $timeout(function () {
            $scope.dialogShouldBeOpened = false;
        }, 0);
    };

    $scope.openDialog = function () {
        // Have to use $timeout due to $document.one that might conflict with opening the dialog, this way we make sure the $document.one (close dialog callback) happens before the re-open
        $timeout(function () {
            $scope.dialogShouldBeOpened = true;
            if ($scope.openCallback) {
                $scope.openCallback();
            }

            $document.one('click', $scope.closeDialog);
        }, 0);
    };

    $scope.toggleDialog = function () {
        $scope.dialogShouldBeOpened ? $scope.closeDialog() : $scope.openDialog();
    };
});

/* origin: public/webapp/directives/asterisk-note-with-dialog/asterisk-note-with-dialog.js */
angular.module('webApp').directive('asteriskNoteWithDialog', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/asterisk-note-with-dialog/asterisk-note-with-dialog.html',
        transclude: true,
        controller: 'AsteriskNoteWithDialogController',
        scope: {
            showNote: '=',
            openCallback: '&',
            openToLeft: '='
        }
    };
});
/* origin: public/webapp/directives/auto-focus.js */
angular.module('webApp').directive('autoFocusInput', function() {
    return {
        restrict: 'A',
        controller: function($element) {
            $element.focus();
        }
    };
}).directive('blurOnClick', function() {
    return {
        restrict: 'A',
        controller: function($scope, $element) {
            $element.click(function(){ $element.blur(); });

            $scope.$on('$destroy', function() {
                $element.unbind();
            });
        }
    };
});

/* origin: public/webapp/directives/auto-scroller.js */
angular.module('webApp').directive('autoScroller', function(gabby) {
    return {
        //Ironically, the auto scroller isn't automatic.
        //You have to call "scrollIfAttached" each time you append text on your element.
        restrict: 'E',
        scope: gabby.scope(),
        transclude: true,
        template: '<div class="scroll-to-bottom" ng-click="api.attach()" ng-if="!isAttached" ng-transclude></div>',
        controller: 'autoScrollerController'
    };
}).controller('autoScrollerController', function(gabby, $scope) {
    gabby.for($scope)
        .settings({
            parentElement: {},
            contentElement: {},
            isAttached: true
        })
        .api({
            attach: function() {
                $scope.isAttached = true;
                $scope.api.scrollIfAttached();
            },
            scrollIfAttached: function() {
                if ($scope.isAttached)
                    $scope.parentElement.scrollTop($scope.contentElement.height());
            },
            toggle: function() {
                $scope.isAttached = !$scope.isAttached;
                $scope.api.scrollIfAttached();
            }
        });

    $scope.parentElement.on('scroll', function() {
        $scope.$apply(function() {

            var isCurrentlyScrolledToBottom = $scope.parentElement.scrollTop() + 30 >= $scope.contentElement.height() - $scope.parentElement.height();

            if (!$scope.isAttached) {
                if (isCurrentlyScrolledToBottom)
                    $scope.isAttached = true;
                return;
            }

            if (isCurrentlyScrolledToBottom)
                return;

            $scope.isAttached = false;
        });
    });
});

/* origin: public/webapp/directives/auto-width/auto-width-controller.js */
angular.module('webApp').controller('AutoWidthController', function ($document, $compile, $element, $scope) {

    if (!$scope.autoWidth) {
        return;
    }

    var parsePxToInt = function (value) {
        if (value === undefined) {
            return 0;
        }

        return parseInt(value.replace(/px.*/, ''));
    };

    $scope.$watch(function () { return $element.val(); }, function () {
        var tempSpan = angular.element([ '<span>', $element.val(), '</span>' ].join(''));
        tempSpan.css('visibility', 'hidden');
        tempSpan.css('white-space', 'pre');
        tempSpan.css('font-size', $element.css('font-size'));
        tempSpan.css('font-family', $element.css('font-family'));
        tempSpan.css('position', 'absolute');
        $document.find('body').append(tempSpan);
        $compile(tempSpan)($scope);
        var newWidth = Math.round(tempSpan[0].getBoundingClientRect().width) + parsePxToInt($element.css('padding-left')) + parsePxToInt($element.css('padding-right'));
        $element.css('width', [ Math.max($scope.minWidth, newWidth), 'px' ].join(''));
        tempSpan.remove();
    });
});

/* origin: public/webapp/directives/auto-width/auto-width.js */
angular.module('webApp').directive('autoWidth', function () {
    return {
        restrict: 'A',
        controller: 'AutoWidthController',
        scope: {
            autoWidth: '<',
            minWidth: '<'
        }
    };
});
/* origin: public/webapp/directives/button-dialog/dialogs/delete-alert-dialog.js */
angular.module('webApp').directive('deleteAlertDialog', [function() {
    return {
        restrict: 'E',
        require: '^^logzioButtonDialog',
        templateUrl: 'directives/button-dialog/dialogs/delete-alert-dialog.html',
        link: function(scope, element, attrs, buttonDialog) {

            scope.deleteAndClose = function () {
                scope.closeDialog();
                attrs.controllerAs ? scope[attrs.controllerAs].deleteAlert() : scope.deleteAlert();
            };

            scope.closeDialog = function() {
                buttonDialog.closeDialog();
            };

        }
    };
}]);
/* origin: public/webapp/directives/button-dialog/dialogs/delete-endpoint/delete-endpoint-dialog.js */
angular.module('webApp').directive('deleteEndpointDialog', [function() {
    return {
        restrict: 'E',
        require: '^^logzioButtonDialog',
        templateUrl: 'directives/button-dialog/dialogs/delete-endpoint/delete-endpoint-dialog.html',
        link: function(scope, element, attrs, buttonDialog) {

            scope.closeDialog = function() {
                buttonDialog.closeDialog();
            };

        }
    };
}]);
/* origin: public/webapp/directives/button-dialog/dialogs/delete-sawmill/delete-sawmill-dialog.js */
angular.module('webApp').directive('deleteSawmillDialog', [function() {
    return {
        restrict: 'E',
        require: '^^logzioButtonDialog',
        templateUrl: 'directives/button-dialog/dialogs/delete-sawmill/delete-sawmill-dialog.html',
        link: function(scope, element, attrs, buttonDialog) {

            scope.closeDialog = function() {
                buttonDialog.closeDialog();
            };

        }
    };
}]);
/* origin: public/webapp/directives/button-dialog/dialogs/general-action-dialog.js */
angular.module('webApp').directive('generalActionDialog', [function() {
    return {
        restrict: 'E',
        require: '^^logzioButtonDialog',
        transclude: true,
        templateUrl: 'directives/button-dialog/dialogs/general-action-dialog.html',
        link: function(scope, element, attrs, buttonDialog) {
            var escapeRegExp = function(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            };

            scope.inputModel = '';
            scope.validationPattern = new RegExp('^' + escapeRegExp(scope.inputComparator.toLowerCase()) + '$', 'i');

            scope.performActionAndClose = function(isValid, $event) {
                if (!isValid)
                    return angular.element(element[0]).find('input[type=text]')[0].focus();

                scope.action($event);
                scope.closeDialog();

            };

            scope.closeDialog = function() {
                buttonDialog.closeDialog();
            };

        },
        scope: {
            question: '@',
            action: '=',
            actionTitle: '@',
            inputComparator: '=',
            inputDesc: '@'

        }
    };
}]);


/* origin: public/webapp/directives/button-dialog/logzio-button-dialog.js */
angular.module('webApp').directive('logzioButtonDialog', function ($timeout) {
    return {
        restrict: 'A',
        scope: {
            closeDialog: '&?',
            dialogDisplayed: '&',
            dialogClosed: '&'
        },
        link: function(scope, elem) {

            var backdrop, dialog;

            dialog = elem.find('.logz-button-dialog');
            elem.css('position', 'relative');

            var showDialog = function() {
                // place backdrop
                backdrop = angular.element('<div class="clear-backdrop"></div>');
                elem.append(backdrop);

                // position dialog correctly
                dialog = elem.find('.logz-button-dialog');
                dialog.css({ display: 'inline-block' });
                dialog.css('top', elem.height() + 8);
                dialog.css('left', -1 * ((dialog.width() / 2) + (elem.width() / 2)));

                // bind events
                backdrop.bind('click', destroy);
                scope.closeDialog = destroy;

                // show dialog
                dialog.css({
                    'visibility': 'visible',
                    'opacity': 1,
                    // 'display': 'inline-block',
                    'position': 'absolute'
                });

                scope.dialogDisplayed();
            };

            elem.one('click', showDialog);

            // take care of destroy (return dialog to place, and remove backdrop)
            scope.$on('$destroy', function() {
                destroy();
                elem.unbind();
            });

            var destroy = function() {
                if (backdrop) backdrop.remove();
                dialog.css({'visibility': 'hidden', 'opacity': 0});
                angular.element(document.getElementsByTagName('body')[0]).removeClass('no-scroll');
                $timeout(function() {
                    elem.one('click', showDialog);
                }, 250);
                scope.dialogClosed();
            };
        },
        controller: ['$scope', function ($scope) {

            this.closeDialog = function() {
                $scope.closeDialog();
            };

        }]
    };
});
/* origin: public/webapp/directives/circular-spinner/circular-spinner.js */
angular.module('webApp').directive('circularSpinner', function () {
    return {
        restrict: 'E',
        template:
            '<div class="circular-spinner spin">' +
                '<span class="circle"></span>' +
                '<span class="spinner"></span>' +
            '</div>'
    };
});
/* origin: public/webapp/directives/collapse-expand/collapse-expand-controller.js */
angular.module('webApp').controller('CollapseExpandController', function ($scope, $element, $timeout) {

    var calculateNewHeight = function () {
        var minHeight = $element.css('min-height');
        var maxHeight = $element.css('max-height');
        if (maxHeight === 'none') {
            maxHeight = undefined;
        }

        return $scope.show ?
            [ maxHeight || $element.outerHeight(), 'px' ].join('')
            : minHeight;
    };

    var setHeight = function () {
        var currentHeight = $element.css('height');
        $element.css('height', '');
        var newHeight = calculateNewHeight();
        $element.css('height', currentHeight);

        $timeout(function () {
            $element.css('height', newHeight);
        }, 0);

        return newHeight;
    };

    $element.css('height', calculateNewHeight());

    var currentHeight;
    var showWatcher = $scope.$watch(function () { return [ $scope.show, $scope.calculateHeightWhenChanges, $element[0].childElementCount ].join(';'); }, function () {
        if ($scope.show === undefined || $scope.expandAvailable === false) { // May be undefined
            return;
        }

        // Very ugly, I know... I'm sorry, but has to do it due to optional usage of
        // filters (needs to make sure this happens after the filters is done changing the text
        var newHeight = setHeight();
        if (currentHeight === newHeight) {
            $timeout(function () {
                currentHeight = setHeight();
            }, 0);
        }
        currentHeight = newHeight;
    });

    var scrollHeightWatcher, scrollHeight, offsetHeight;
    if ($scope.checkForExpansionOption) {
        scrollHeightWatcher = $scope.$watch(function () { return [ $element[0].scrollHeight, $element[0].offsetHeight ].join(';'); }, function () {
            $timeout(function () {
                scrollHeight = $element[0].scrollHeight;
                offsetHeight = $element[0].offsetHeight;
                $scope.expandAvailable = $scope.show || (scrollHeight > offsetHeight);
            }, 500); // To make sure we wont fail due to animation (400 ms)
        });
    }

    $scope.$on('$destroy', function () {
        if (showWatcher) showWatcher();
        if (scrollHeightWatcher) scrollHeightWatcher();
    });
});
/* origin: public/webapp/directives/collapse-expand/collapse-expand.js */
angular.module('webApp').directive('collapseExpand', function () {
    return {
        restrict: 'A',
        controller: 'CollapseExpandController',
        scope: {
            show: '=collapseExpand',
            checkForExpansionOption: '=',
            expandAvailable: '=',
            calculateHeightWhenChanges: '='
        }
    };
});
/* origin: public/webapp/directives/container-custom-scrollbar/container-custom-scrollbar-controller.js */
angular.module('webApp').controller('ContainerCustomScrollbarController', [ '$element', '$scope', '$rootScope', function ($element, $scope, $rootScope) {

    $scope.scrollbarContainerClass = $scope.scrollbarContainerClass || 'custom-scrollbar-container';
    $scope.scrollbarThumbClass = $scope.scrollbarThumbClass || 'custom-scrollbar-thumb';

    var thumbContainerDom;
    var thumbDom;

    var documentDom = angular.element(document);

    var thumbOffsetY;

    var getOffsetTop = function (elem) {
        var offsetTop = 0;
        do {
            if (!isNaN(elem.offsetTop)) {
                offsetTop += elem.offsetTop;
            }

            elem = elem.offsetParent;
        } while (elem);

        return offsetTop;
    };

    var calculateScrollTo = function (mouseY, thumbToCursorAlignmentPercentage) {

        // The maximum scrolling length
        var scrollingLength = $element[0].scrollHeight - $element[0].parentElement.offsetHeight;

        // Mouse y compared to the container height as percentage
        var scrollToAsPercentage = mouseY / $element[0].parentElement.offsetHeight;

        // Calculate scrollToAsPercentage in px amount
        var scrollTo = scrollingLength * scrollToAsPercentage;

        // Measure the thumb height in scrollingLength measures
        var thumbHeightInScrollingMeasures = scrollingLength / ($element[0].parentElement.offsetHeight / thumbDom[0].offsetHeight);

        // Calculates the delta needed to be added in order to keep the thumb aligned to the mouse as required by thumbToCursorAlignmentPercentage
        var delta = (scrollToAsPercentage - thumbToCursorAlignmentPercentage) * thumbHeightInScrollingMeasures;

        return scrollTo + delta;
    };

    var documentMouseMove = function ($event) {
        var scrollTo;
        var relativeY = $event.clientY + documentDom.scrollTop();

        var offsetTop = getOffsetTop($element[0]);
        if (relativeY <= offsetTop) {
            // The mouse is above the container, stay at 0
            scrollTo = 0;
            thumbOffsetY = 0;
        }
        else if (relativeY >= offsetTop + $element[0].parentElement.offsetHeight) {
            // The mouse is under the container, stay at max scroll
            scrollTo = $element[0].scrollHeight;
            thumbOffsetY = thumbDom[0].clientHeight;
        }
        else {
            // The mouse Y axis in the thumb container
            var mouseYInThumbContainer = relativeY - offsetTop;

            // The alignment between the mouse Y and the thumb length in percentage
            var thumbToCursorAlignmentPercentage = thumbOffsetY / thumbDom[0].clientHeight;

            scrollTo = calculateScrollTo(mouseYInThumbContainer, thumbToCursorAlignmentPercentage);
        }

        $element.scrollTop(scrollTo);

        return false;
    };

    var thumbContainerMouseUp = function ($event) {
        if (thumbContainerDom[0] !== $event.target) {
            // User clicked on something else than the thumb container (probably on the thumb it self)
            return;
        }

        var scrollTo = calculateScrollTo($event.offsetY, 0.5);
        $element.animate({ scrollTop: scrollTo }, 'fast');
    };

    var documentMouseUp = function () {
        documentDom.unbind('mousemove', documentMouseMove);
        documentDom.unbind('mouseup', documentMouseUp);
    };

    var thumbMouseDown = function ($event) {
        thumbOffsetY = $event.offsetY;

        documentDom.bind('mousemove', documentMouseMove);
        documentDom.bind('mouseup', documentMouseUp);
    };

    var setThumbTopCss = function () {
        // The current scroll position in percentages
        var scrollAsPercentage = $element[0].scrollTop / ($element[0].scrollHeight - $element[0].parentElement.offsetHeight);

        // Max top CSS px amount for thumb
        var maxTopPxAmountForThumb = $element[0].parentElement.offsetHeight - thumbDom.height();

        // The amount of px amount to set for thumb CSS top
        var topPxAmount = maxTopPxAmountForThumb * scrollAsPercentage;

        thumbDom.css('top', [ topPxAmount, 'px' ].join(''));
    };

    $scope.scrollbarShownModel = false;
    var scrollHeightWatcher = $scope.$watch(function () { return [ $element[0].scrollHeight, $element[0].offsetHeight ].join(';'); }, function () {
        var shouldShowScrollbar = $element[0].scrollHeight > $element[0].offsetHeight;
        shouldShowScrollbar ? addScrollbar() : removeScrollbar();
    });

    var removeScrollbar = function () {
        if (!$scope.scrollbarShownModel) {
            return; // Nothing to remove
        }

        thumbDom.remove();
        thumbContainerDom.remove();
        $element.off('scroll', setThumbTopCss);
        $scope.scrollbarShownModel = false;
    };

    var addScrollbar = function () {
        if ($scope.scrollbarShownModel) {
            return; // Scrollbar is already shown
        }

        $scope.scrollbarShownModel = true;

        thumbContainerDom = angular.element([ '<div class=', $scope.scrollbarContainerClass, '></div>' ].join('"'));
        thumbDom = angular.element([ '<div class=', $scope.scrollbarThumbClass, '></div>' ].join('"'));
        thumbContainerDom.append(thumbDom);

        $element.parent().prepend(thumbContainerDom);

        thumbDom.bind('mousedown', thumbMouseDown);
        thumbContainerDom.bind('mouseup', thumbContainerMouseUp);

        setThumbTopCss();
        $element.on('scroll', setThumbTopCss);
    };

    $rootScope.$on($scope.scrollUpEvent, function () {
        $element.animate({ scrollTop: 0 }, 'fast');
    });

    $scope.$on('$destroy', function () {
        if (scrollHeightWatcher) scrollHeightWatcher();

        documentDom.unbind('mousemove', documentMouseMove);
        documentDom.unbind('mouseup', documentMouseUp);
    });
}]);
/* origin: public/webapp/directives/container-custom-scrollbar/container-custom-scrollbar.js */
angular.module('webApp').directive('containerCustomScrollbar', [function() {
    return {
        restrict: 'A',
        controller: 'ContainerCustomScrollbarController',
        scope: {
            scrollbarContainerClass: '@',
            scrollbarThumbClass: '@',
            scrollUpEvent: '@',
            scrollbarShownModel: '=?'
        }
    };
}]);
/* origin: public/webapp/directives/container-scroll-if-out-of-view.js */
angular.module('webApp').directive('containerScrollIfOutOfView', function () {
    return function (scope, element, attributes) {
        var dom = element.parent();

        scope.$watch(function () {
            return scope.$eval(attributes.containerScrollIfOutOfView);
        }, function () {
            if (!scope.$eval(attributes.containerScrollIfOutOfView)) {
                return;
            }

            var offsetTop = _.get(element, '[0].offsetTop') || 0;
            var relativeToScroll = offsetTop - dom.scrollTop();
            var scrollDown = relativeToScroll >= dom.innerHeight();
            var scrollUp = relativeToScroll < 0;

            if (scrollUp) {
                dom.animate({ scrollTop: offsetTop }, 'fast');
            }
            else if (scrollDown) {
                dom.animate({ scrollTop: offsetTop + element.outerHeight(true) - dom.innerHeight() }, 'fast');
            }
        });
    };
});
/* origin: public/webapp/directives/container-scroll-shadow/container-scroll-shadow-controller.js */
angular.module('webApp').controller('ContainerScrollShadowController', [ '$element', function ($element) {
    var SIZE_MAX_AMOUNT = 30;
    var OPACITY_MAX_AMOUNT = 0.15;

    var elementDom = angular.element($element[0]);

    var calculatePxAmount = function (maxAmount, isPercentage) {
        var scrollTop = isPercentage ? $element[0].scrollTop / 100 : $element[0].scrollTop;

        return scrollTop <= maxAmount
            ? scrollTop
            : maxAmount;
    };

    $element.on('scroll', function () {
        var sizePxAmount = calculatePxAmount(SIZE_MAX_AMOUNT, false);
        var opacityAmount = calculatePxAmount(OPACITY_MAX_AMOUNT, true);

        var cssStyles = [
            [ 'background: radial-gradient(at 50% 0, rgba(0,0,0,', opacityAmount, '), transparent 75%)' ].join(''),
            [ 'background-size: 100% ', sizePxAmount, 'px' ].join(''),
            'background-repeat: no-repeat',
            'background-attachment: scroll'
        ];
        elementDom[0].setAttribute('style', cssStyles.join(';'));
    });
}]);
/* origin: public/webapp/directives/container-scroll-shadow/container-scroll-shadow.js */
angular.module('webApp').directive('containerScrollShadow', [function() {
    return {
        restrict: 'A',
        controller: 'ContainerScrollShadowController'
    };
}]);
/* origin: public/webapp/directives/containers-slider/containers-slider-controller.js */
angular.module('webApp').controller('ContainersSliderController', function ($rootScope, $scope, $window, $element, $timeout) {
    var allSliderContainers;
    var sliderContainerDoms;
    var sliderContainerWidth;
    $scope.index = 0;
    var moveContainersToLocation = function (noTransition) {
        for (var i = 0; i < sliderContainerDoms.length; i++) {
            if (noTransition) {
                sliderContainerDoms[i].removeClass('with-transition');
            }
            else {
                sliderContainerDoms[i].addClass('with-transition');
            }

            sliderContainerDoms[i].css('left', [ (i - $scope.index) * sliderContainerWidth, 'px' ].join(''));
        }
    };
    
    var directiveWidth;
    $scope.displayAmount;
    var init = function () {
        allSliderContainers = $element.find('.inner-slider-container');
        sliderContainerDoms = [];
        for (var i = 0; i < allSliderContainers.length; i++) {
            sliderContainerDoms.push(angular.element(allSliderContainers[i]));
        }

        directiveWidth = $element.outerWidth();

        // Amount of samples to display
        $scope.displayAmount = Math.min(allSliderContainers.length, Math.floor(directiveWidth / $scope.minWidth));

        // Width for each sample
        sliderContainerWidth = (1 + ((directiveWidth / $scope.minWidth) - $scope.displayAmount) / $scope.displayAmount) * $scope.minWidth;

        allSliderContainers.css('width', [ sliderContainerWidth, 'px' ].join(''));
        moveContainersToLocation(true);
    };
    $timeout(init);

    angular.element($window).bind('resize', function() {
        init();
    });

    $scope.goLeft = function (dontSendEvent) {
        if ($scope.index === 0) return;

        $scope.index--;
        moveContainersToLocation();

        if (!dontSendEvent && $scope.slideEvent) {
            $rootScope.$broadcast($scope.slideEvent, { element: $element, goRight: false });
        }
    };

    $scope.goRight = function (dontSendEvent) {
        if ($scope.index === sliderContainerDoms.length - $scope.displayAmount) return;

        $scope.index++;
        moveContainersToLocation();

        if (!dontSendEvent && $scope.slideEvent) {
            $rootScope.$broadcast($scope.slideEvent, { element: $element, goRight: true });
        }
    };

    var slideOnEventListener;
    $timeout(function () {
        if ($scope.slideEvent) {
            slideOnEventListener = $rootScope.$on($scope.slideEvent, function (event, eventData) {
                if (eventData.element === $element) return;

                if (eventData.goRight) {
                    $scope.goRight(true);
                }
                else {
                    $scope.goLeft(true);
                }
            });
        }
    });

    $scope.$on('$destroy', function () {
        if (slideOnEventListener) slideOnEventListener();
    });
});
/* origin: public/webapp/directives/containers-slider/containers-slider.js */
angular.module('webApp').directive('containersSlider', function () {
    return {
        restrict: 'A',
        controller: 'ContainersSliderController',
        scope: true,
        link: function ($scope, $element, attrs) {
            $scope.minWidth = attrs.minWidth;
            $scope.slideEvent = attrs.slideEvent;
        }
    };
});
/* origin: public/webapp/directives/copy-on-click/copy-on-click-controller.js */
angular.module('webApp').controller('CopyOnClickController', function ($window, $element, $document, $timeout) {
    var copiedDom = angular.element('<div class="copy-on-click">copied</div>');
    copiedDom.css('display', 'none');

    $element.css('cursor', 'pointer');
    var isWorking = false;
    $element.click(function (e) {
        if (isWorking) return;
        copiedDom.appendTo($document.find('body'));

        isWorking = true;

        copiedDom.removeClass('with-transition');
        copiedDom.css({
            display: 'block',
            left: [ e.pageX - (copiedDom.width() / 2), 'px' ].join(''),
            opacity: 1,
            top: [ e.pageY - 30, 'px' ].join('')
        });

        $timeout(function () {
            copiedDom.addClass('with-transition');
            copiedDom.css({
                opacity: 0,
                top: [ e.pageY - 45, 'px' ].join('')
            });
        }, 0);

        $timeout(function () {
            copiedDom.css('display', 'none');
            isWorking = false;
            copiedDom.remove();
        }, 550); // Based on the css transition

        // Hack to copy the $element, remove all childs and only then get the text
        // (otherwise you get nested inner childs text as well)
        var textToCopy = $element.clone()
            .children()
            .remove()
            .end()
            .text();

        // Hack to add a hidden textarea, put the text to copy inside, run copy command
        // for browser and then remove the textarea
        angular.element('<textarea/>')
            .css({ 'opacity': '0', 'position': 'fixed' })
            .text(textToCopy)
            .appendTo(angular.element($window.document.body))
            .select()
            .each(function() { document.execCommand('copy'); })
            .remove();
    });
});
/* origin: public/webapp/directives/copy-on-click/copy-on-click.js */
angular.module('webApp').directive('copyOnClick', function () {
    return {
        restrict: 'A',
        controller: 'CopyOnClickController'
    };
});
/* origin: public/webapp/directives/dialog-with-triangle/dialog-with-triangle.js */
angular.module('webApp').directive('dialogWithTriangle', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/dialog-with-triangle/dialog-with-triangle.html',
        transclude: true,
    };
});
/* origin: public/webapp/directives/dots-spinner/dots-spinner.js */
angular.module('webApp').directive('dotsSpinner', [function () {
    return {
        restrict: 'E',
        template:
            '<div class="dots-spinner">' +
                '<div class="dot1"></div>' +
                '<div class="dot2"></div>' +
            '</div>',
    };
}]);
/* origin: public/webapp/directives/dropdown/logz-dropdown.js */
angular.module('webApp').directive('logzDropdownTrigger', function($document, $timeout) {
    return {
        restrict: 'A',
        scope: true,
        link: function(scope, element) {
            scope.visible = false;
            element.click(function() {
                scope.visible = true;

                element.css({'position':'relative'});

                var menu = element.find('.logz-dropdown');
                menu.css({
                    top: element.outerHeight(),
                    right: '0px'
                });

                $timeout(function() {
                    $document.one('click', function(e) {
                        var clickedOnDropDown = element.find('.options')[0] === e.target || element.find('.options').find(e.target).length > 0;
                        if (!clickedOnDropDown) {
                            scope.$apply(function() {
                                scope.visible = false;
                            });
                        }
                    });
                }, 200);

                element.find('.item').click(function() {
                    scope.$apply(function() {
                        scope.visible = false;
                    });
                });
            });

            scope.$on('$destroy', function() {
                element.unbind();
            });
        }
    };
});
/* origin: public/webapp/directives/dynamic-select/logz-dynamic-select.js */
angular.module('webApp').directive('logzDynamicSelect', function($document, $timeout) {
    return {
        scope: {
            options: '=',
            optionKey:'@',
            selectedObject:'=?',
            assignedValue:'=',
            enableFirstOptionDefault:'=?'
        },
        template:
            '<div id="logz-dynamic-select" style="">' +
                '<div class="selected-option clearfix" style="padding:8px" ng-click="toggleDropDownVisible()">' +
                    '<span class="selected-title" ng-bind="assignedValue"></span>' +
                    '<i class="fa fa-chevron-down dropdown-icon pull-right"></i>' +
                '</div>' +
                '<div class="options" style="top: 30px;left:-1px;" ng-show="isDropDownVisible">' +
                    '<div ng-repeat="option in options" class="option" ng-click="selectOption(option)">' +
                        '<span ng-bind="option[optionKey]"></span>'+
                        '<img class="template-icon" ng-src="{{option.template.iconSrc}}"></img>'+
                    '</div>' +
                '</div>' +
            '</div>',
        link: function(scope, element) {
            scope.toggleDropDownVisible = function() {
                scope.isDropDownVisible=!scope.isDropDownVisible;
                bindOutsideClick();
            };

            var bindOutsideClick = function() {
                $timeout(function() {
                    $document.one('click', function(e) {
                        var clickedOnDropDown = element.find('.options')[0] === e.target || element.find('.options').find(e.target).length > 0;
                        if (!clickedOnDropDown) {
                            scope.$apply(function() {
                                scope.isDropDownVisible = false;
                            });
                        }
                        else {
                            bindOutsideClick();
                        }
                    });
                }, 200);
            };


            if (scope.enableFirstOptionDefault) {
                var unbindOptionsWatcher = scope.$watch('options', function() {
                    if (scope.options && scope.options.length > 0) {
                        var option = scope.options[0];
                        assignSelectedOption(option);
                        unbindOptionsWatcher();
                    }
                });
            }

            var assignSelectedOption = function(option) {
                scope.selectedObject = option;
                scope.assignedValue = option[scope.optionKey];
            };

            scope.selectOption = function(option) {
                assignSelectedOption(option);
                scope.isDropDownVisible=!scope.isDropDownVisible;
            };
        }
    };
});
/* origin: public/webapp/directives/ensure-regex/ensure-regex-controller.js */
angular.module('webApp').controller('EnsureRegexController', function ($scope) {
    var validate = function () {
        var match = new RegExp($scope.ensureRegex).exec($scope.model);
        $scope.model = match
            ? match[0]
            : $scope.model;
    };
    var watcher = $scope.$watch('model', validate);

    $scope.$on('$destroy', function () {
        if (watcher) watcher();
    });
});
/* origin: public/webapp/directives/ensure-regex/ensure-regex.js */
angular.module('webApp').directive('ensureRegex', [ function () {
    return {
        restrict: 'A',
        require: 'ngModel',
        scope: {
            ensureRegex: '=',
            model: '=ngModel'
        },
        controller: 'EnsureRegexController'
    };
}]);
/* origin: public/webapp/directives/exclamation-mark-note-with-dialog/exclamation-mark-note-with-dialog-controller.js */
angular.module('webApp').controller('ExclamationMarkNoteWithDialogController', function ($scope, $document, $timeout, $element, $window) {
    var vm = this;
    vm.dialogShouldBeOpened = false;

    vm.closeDialog = function (event) {
        if (nodeToCloseMenuOnScroll) nodeToCloseMenuOnScroll.off('scroll', vm.closeDialog);

        if (event && $element.has(event.target).length > 0) {
            $document.one('click', vm.closeDialog);
            return; // Event sent from an inner click within the dialog, shouldn't close
        }

        // Not really sure why, but without the $timeout the close performs after a small delay, doing $scope.$apply isn't a good solution due to $document.one and closeFunc direct calling being called the same time and angular throws an exception
        $timeout(function () {
            vm.dialogShouldBeOpened = false;
        }, 0);
    };

    vm.openDialog = function () {
        if (nodeToCloseMenuOnScroll) nodeToCloseMenuOnScroll.on('scroll', vm.closeDialog);

        // Have to use $timeout due to $document.one that might conflict with opening the dialog, this way we make sure the $document.one (close dialog callback) happens before the re-open
        $timeout(function () {
            vm.dialogShouldBeOpened = true;
            if (vm.openCallback) {
                vm.openCallback();
            }

            $document.one('click', vm.closeDialog);
        }, 0);

        positionDialog();
    };

    vm.toggleDialog = function () {
        vm.dialogShouldBeOpened ? vm.closeDialog() : vm.openDialog();
    };

    var window = angular.element($window);
    var dialogDom = $element.find('.exclamation-mark-dialog-container');
    var positionDialog = function () {
        var targetRect = $element[0].getBoundingClientRect();
        dialogDom.css({
            top: targetRect.top + window.scrollTop(),
            left: targetRect.left
        });
    };

    var nodeToCloseMenuOnScroll;
    if ($scope.closeOnParentScroll) {
        nodeToCloseMenuOnScroll = $element;
        var parentCounter = parseInt($scope.closeOnParentScroll);
        for (var i = 0; i < parentCounter; i++) {
            nodeToCloseMenuOnScroll = nodeToCloseMenuOnScroll.parent();
        }
    }

    $scope.$on('$destroy', function() {
        if (nodeToCloseMenuOnScroll) nodeToCloseMenuOnScroll.off('scroll', vm.closeDialog);
    });

});

/* origin: public/webapp/directives/exclamation-mark-note-with-dialog/exclamation-mark-note-with-dialog.js */
angular.module('webApp').directive('exclamationMarkNoteWithDialog', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/exclamation-mark-note-with-dialog/exclamation-mark-note-with-dialog.html',
        transclude: true,
        controller: 'ExclamationMarkNoteWithDialogController',
        controllerAs: 'vm',
        scope: {
            template: '@',
            closeOnParentScroll: '=',
            callbackFunction: '&',
            parameters: '='
        }
    };
});
/* origin: public/webapp/directives/feature-flag.js */
angular.module('webApp').directive('featureFlag', function (FeatureFlagService) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
            element.addClass('ng-hide');

            FeatureFlagService.isFeatureEnabled(attrs['featureFlag']).then(function (enabled) {
                if (enabled) element.removeClass('ng-hide');
            });
        }
    };
});
/* origin: public/webapp/directives/form-toast/form-toast-controller.js */
angular.module('webApp').controller('formToastCtrl', function ($mdToast) {
    this.$onInit = function() {
        var self = this;

        if (self.highlightAction) {
            self.highlightClasses = [
                'md-highlight',
                self.highlightClass
            ];
        }
    };

    this.resolve = function () {
        $mdToast.hide('dismiss');
    };
});
/* origin: public/webapp/directives/fullstory.js */
angular.module('webApp').directive('fullstory', function($document, AuthService, UserService, currentEnv) {
    return {
        restrict: 'E',
        scope: true,
        template: '',
        link: function($scope) {

            if (currentEnv() !== 'PROD')
                return;

            $scope.isLoggedIn = AuthService.isAuthenticated();
            var isAdmin = AuthService.isAdmin();
            if (!$scope.isLoggedIn || isAdmin)
                return;

            AuthService.getUser().then(function(loggedInUser) {
                UserService.getSummary().then(function(res) {
                    var summary = res.data;
                    var user = loggedInUser.data;
                    var scriptTag = $document[0].createElement('script');
                    scriptTag.type = 'text/javascript';

                    /* eslint-disable */
                    var scriptContent = "try { " +
                        "FS.identify('" + summary.accountId + "', { displayName: '" + user.fullName + "', email: '" + user.username + "', company: '" + summary.accountName + "' });';" +
                        " } catch (ex) { }";
                    scriptTag.text = scriptContent;
                    /* eslint-enable */

                    $document[0].getElementsByTagName('body')[0].appendChild(scriptTag);
                });
            });
        }
    };
});
/* origin: public/webapp/directives/generic-bucket/generic-bucket.js */
angular.module('webApp').directive('genericBucket', function(Backend, UserService) {
    return {
        restrict: 'E',
        templateUrl: 'directives/generic-bucket/generic-bucket.html',
        scope: {
            logType: '@',
            accountId: '&'
        },
        link: function(scope) {

            UserService.getSummary().then(function(res) {
                scope.accountId = res.data.accountId;
            });

            scope.addS3Settings = function() {
                if (!scope.settings)
                    scope.settings = [];

                scope.settings.push({ id:0, logsType:scope.logType });
            };

            Backend.GET('/s3buckets').then(function(settingsList) {
                if (!settingsList.data || !settingsList.data) {
                    alert('There was an error retrieving your s3 settings.\nPlease refresh the page to retry again.');
                }

                settingsList = _.filter(settingsList.data, function(settings) {
                    return settings.logsType === scope.logType;
                });
                scope.settings = settingsList;
            });

        }
    };
});
/* origin: public/webapp/directives/global-notifications.js */
angular.module('webApp').directive('globalNotifications', function($rootScope, $document, $timeout, $animate, Backend, localStorageService, AuthService, UserService) {
    return {
        restrict: 'E',
        scope: true,
        template: '',
        link: function() {

            var currentlyDisplayed = [];

            var storageKey = 'notificationsHistory';

            var alertsWidth = 600;
            var alertsLeft = (document.getElementsByTagName('body')[0].clientWidth / 2) - (alertsWidth / 2);

            var notificationsWrapper = angular.element('<div class="logz-alerts-wrapper" style="width:' + alertsWidth + 'px; left:' + alertsLeft + 'px;"></div>');
            $document.find('body').append(notificationsWrapper);

            var hideNotification = function(id) {
                var notificationsHistory = localStorageService.get(storageKey);
                notificationsHistory.dismissedNotifications.push(id);
                localStorageService.set(storageKey, notificationsHistory);

                var currentDisplayedIndex = currentlyDisplayed.indexOf(id);
                if (currentDisplayedIndex >= 0) {
                    currentlyDisplayed.splice(currentDisplayedIndex, 1);
                }

                $('.alert-wrapper.logz-alert-' + id).remove();

                if ($('.logz-alerts-wrapper .alert-wrapper').length === 0) {
                    $animate.removeClass(notificationsWrapper, 'in-view');
                }
            };

            var addNotification = function(notification) {
                if (currentlyDisplayed.indexOf(notification.id) >= 0) {
                    return;
                }
                else {
                    currentlyDisplayed.push(notification.id);
                }
                var lowerCasedMessageType = _.lowerCase(notification.messageType);
                var newNotification = angular.element('<div class="alert-wrapper logz-alert-' + notification.id + ' ' + lowerCasedMessageType + '"></div>');

                var iconClass = lowerCasedMessageType === 'general' ? 'fa-smile-o' : lowerCasedMessageType === 'warning' ? 'fa-question-circle' : 'fa-exclamation-triangle';
                var icon = angular.element('<i class="fa ' + iconClass + '"></i>');

                var closeIcon = angular.element('<i class="fa fa-times"></i>');
                closeIcon.one('click', function() { hideNotification(notification.id); });

                newNotification.append(icon);
                newNotification.append('<div class="content">' + notification.message + '</div>');
                newNotification.append(closeIcon);

                notificationsWrapper.append(newNotification);
            };
            var showNotifications = function() {
                if ($('.logz-alerts-wrapper .alert-wrapper').length > 0) {
                    $animate.addClass(notificationsWrapper, 'in-view');
                }
            };

            var checkForMessages = function() {
                if (!AuthService.isAuthenticated())
                    return;

                // make call to server
                UserService.getSummary().then(function(userSummary) {
                    userSummary = userSummary.data;
                    var currentUserId = userSummary.userId;

                    Backend.GET('/global-notifications', {}, { dontShowProgressBar: true }).then(function(res) {
                        var notifications = res.data.notifications;
                        var timeToNextPoll = res.data.timeToNextPoll * 1000;

                        // get notifications user saw
                        var notificationsHistory = localStorageService.get(storageKey);
                        if (!notificationsHistory || (notificationsHistory.currentUserId && notificationsHistory.currentUserId !== currentUserId)) {
                            notificationsHistory = {
                                currentUserId: currentUserId,
                                dismissedNotifications: []
                            };
                            localStorageService.set(storageKey, notificationsHistory);
                        }

                        var notificationIds = _.map(notifications, 'id');
                        currentlyDisplayed.forEach(function(displayedNotificationId) {
                            if (notificationIds.indexOf(displayedNotificationId) === -1)
                                hideNotification(displayedNotificationId);
                        });

                        notifications.forEach(function(notification) {
                            if (notificationsHistory.dismissedNotifications.indexOf(notification.id) >= 0)
                                return;

                            addNotification(notification);
                        });

                        showNotifications();

                        $timeout(checkForMessages, timeToNextPoll);
                    });
                });
            };

            $timeout(checkForMessages, 3000);   // first check after 3 seconds

            $rootScope.$on('global-notifications:preview', function(event, notificationObject) {
                addNotification(notificationObject);
                showNotifications();
            });
        }
    };
});
/* origin: public/webapp/directives/google-remarketing-tag/google-remarketing-tag.js */
angular.module('webApp').directive('googleRemarketingTag', function() {
    return {
        restrict: 'E',
        templateUrl: 'directives/google-remarketing-tag/google-remarketing-tag.html'
    };
});
/* origin: public/webapp/directives/heavy-es-queries/heavy-es-queries-controller.js */
angular.module('webApp').controller('HeavyEsQueriesController', function ($interval, $timeout, HttpRequestsService) {
    var vm = this;

    var lastShowMessageTime;
    vm.showMessage = false;
    var showMessage = function (currentTime) {
        vm.showMessage = true;
        lastShowMessageTime = currentTime;
        $timeout(vm.hideMessage, 10000); // Hide after 10 seconds
    };

    vm.hideMessage = function () {
        vm.showMessage = false;
    };

    var checkForHeavyEsQueries = function () {
        if (!HttpRequestsService.kibanaPendingRequests.length) {
            return vm.hideMessage(); // No query running at all
        }

        var currentTime = new Date().getTime();
        var heavyQueryCurrentlyRunning = _.some(HttpRequestsService.kibanaPendingRequests, function (kibanaPendingRequest) {
            return currentTime - kibanaPendingRequest.requestTimestamp >= 30000;
        });

        if (!heavyQueryCurrentlyRunning) {
            return vm.hideMessage(); // No heavy query running
        }

        var timeSinceShowingMessage = currentTime - (lastShowMessageTime || 0); // lastShowMessageTime may be undefined
        if (timeSinceShowingMessage >= 60000) {
            return showMessage(currentTime); // Heavy query currently running and no message shown in the last minute
        }
    };
    $interval(checkForHeavyEsQueries, 1000); // Every second
});
/* origin: public/webapp/directives/heavy-es-queries/heavy-es-queries.js */
angular.module('webApp').directive('heavyEsQueries', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/heavy-es-queries/heavy-es-queries.html',
        controller: 'HeavyEsQueriesController',
        controllerAs: 'vm',
        scope: true
    };
});
/* origin: public/webapp/directives/hover-preview/hover-preview-controller.js */
angular.module('webApp').controller('HoverPreviewController', function ($scope, $element, $document) {
    var hoverDom = angular.element(['<div class="hover-preview-container">', $element.text(), '</div>'].join(''));
    hoverDom.css('display', 'none');
    hoverDom.css('font-family', $element.css('font-family'));

    var mouseMoveHandler = function (e) {
        var isTruncated = $scope.vertical
            ? $element[0].scrollHeight > $element[0].clientHeight
            : $element[0].scrollWidth > $element[0].clientWidth;

        if ($scope.ifTruncated && !isTruncated) {
            hoverDom.css('display', 'none');
            return;
        }

        hoverDom.appendTo($document.find('body'));
        hoverDom.html($element.html());
        hoverDom.css('display', 'block');
        hoverDom.css('top', [e.pageY + 15, 'px'].join(''));
        hoverDom.css('left', [e.pageX + 15, 'px'].join(''));
    };
    $element.on('mousemove', mouseMoveHandler);

    var mouseLeaveHandler = function () {
        hoverDom.css('display', 'none');
        hoverDom.remove();
    };
    $element.on('mouseleave', mouseLeaveHandler);

    $scope.$on('$destroy', function () {
        $element.off('mousemove', mouseMoveHandler);
        $element.off('mouseleave', mouseLeaveHandler);
        if (hoverDom && hoverDom.remove) hoverDom.remove();
    });
});
/* origin: public/webapp/directives/hover-preview/hover-preview.js */
angular.module('webApp').directive('hoverPreview', function () {
    return {
        restrict: 'A',
        controller: 'HoverPreviewController',
        scope: {
            ifTruncated: '<',
            vertical: '@'
        }
    };
});
/* origin: public/webapp/directives/include-replace.js */
angular.module('webApp').directive('includeReplace', function () {
    return {
        require: 'ngInclude',
        restrict: 'A',
        link: function (scope, el) {
            el.replaceWith(el.children());
        }
    };
});
/* origin: public/webapp/directives/infinite-scroll/infinite-scroll.js */
angular.module('webApp').directive('logzInfiniteScroll', function($rootScope, $window, $timeout) {
    return {
        restrict: 'E',
        scope: {
            trigger: '&',
            threshold: '@',
            triggerDelay: '@'
        },
        link: function(scope) {
            scope.currentPage = 1;
            var body = document.body,
                html = document.documentElement;

            var checkThreshold = function() {
                var height = Math.max( body.scrollHeight, body.offsetHeight,
                    html.clientHeight, html.scrollHeight, html.offsetHeight );

                if (height - ($window.innerHeight + $window.scrollY) <= scope.threshold) {
                    var triggerMethod = scope.trigger();
                    if (triggerMethod(scope.currentPage))
                        scope.currentPage++;
                }
            };

            var blocker = undefined;
            var block = false;
            angular.element($window).bind('scroll', function() {
                if (block) return;

                block = true;
                checkThreshold();

                $timeout(function() {
                    block = false;
                }, scope.triggerDelay);
            });

            var pageClear = $rootScope.$on('infinite-scroll:page-clear', function() { scope.currentPage = 0; });

            scope.$on('$destroy', function() {
                angular.element($window).unbind();
                if (blocker) $timeout.cancel(blocker);
                if (pageClear) pageClear();
            });
        }
    };
});
/* origin: public/webapp/directives/information-tooltip/information-tooltip.js */
angular.module('webApp').directive('informationTooltip', function($compile) {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            if (!attrs.informationTooltip) return;

            var cssClasses = [ 'field-header' ];
            if (attrs.informationTooltipNgdialog && attrs.informationTooltipNgdialog.toLowerCase() === 'true') {
                cssClasses.push('ngdialog-tooltip');
            }

            var requiredSpan = angular.element([ '<div logz-tooltip hide-on-click=\'false\' tooltip-css-class=\'', cssClasses.join(','), '\' tooltip-text=\'', attrs.informationTooltip, '\' class=\'fa fa-info-circle\'></div>' ].join(''));
            element.append($compile(requiredSpan)(scope));
        }
    };
});
/* origin: public/webapp/directives/input-enter.js */
angular.module('webApp').directive('enterKey', [function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.bind('keypress', function(event) {
                if (!$(element).is(':focus'))
                    return;

                if (event.which === 13) {
                    scope.$apply(function() {
                        scope.$eval(attrs.enterKey, { 'event': event });
                    });

                    event.preventDefault();
                }
            });

            scope.$on('$destroy', function() {
                element.unbind();
            });
        }
    };
}]);
/* origin: public/webapp/directives/input-esc.js */
angular.module('webApp').directive('escapeKey', [function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.bind('keyup', function(event) {
                if (!$(element).is(':focus'))
                    return;

                if (event.which === 27) {
                    scope.$apply(function() {
                        scope.$eval(attrs.escapeKey, { 'event': event });
                    });

                    event.preventDefault();
                }
            });

            scope.$on('$destroy', function() {
                element.unbind();
            });
        }
    };
}]);
/* origin: public/webapp/directives/intercomio.js */
angular.module('webApp').directive('intercomIo', function($document, $window, $rootScope, $timeout, $q, AuthService, UserService, UpgradeService, appEmbedded, Backend) {
    return {
        restrict: 'E',
        scope: true,
        template: '',
        link: function($scope) {
            var register = function() {
                if (!AuthService.isAuthenticated())
                    return;

                $q.all([
                    AuthService.getUser(),
                    UserService.getSummary()
                ]).then(function(responses) {

                    var summary = responses[1].data;
                    var user = responses[0].data;

                    if (!summary.accountName || !summary.accountId || !summary.planType)
                        return;

                    if (!user || !user.username || !user.fullName || !user.userId) {
                        var d = new Date();
                        user = {
                            username: d.getTime() + '@undefined.com',
                            fullName: d.getTime(),
                            userId: d.getTime()
                        };
                    }

                    Backend.GET('/intercom/user-hash').then(function (res) {
                        var userHash = res.data;

                        var userRegisteredTime = (user && user.userRegistered) ? user.userRegistered / 1000 : undefined;
                        var accountCreatedDate = (summary && summary.accountCreatedDate) ? summary.accountCreatedDate / 1000 : undefined;
                        var scriptTag = $document[0].createElement('script');
                        scriptTag.type = 'text/javascript';

                        var companyObject = '{ name:"' + summary.accountName + '", id:"' + summary.accountId + '", plan: "' + summary.planType + '", created_at: "' + accountCreatedDate + '" }';
                        scriptTag.text = 'window.Intercom("boot", { app_id: "bkz9ugqv", name: "' + user.fullName + '", email: "' + user.username + '", created_at: ' + userRegisteredTime + ', user_id: "' + user.userId + '", user_hash: "' + userHash + '", company: ' + companyObject + ' });';
                        $document[0].getElementsByTagName('body')[0].appendChild(scriptTag);
                    });
                });
            };

            if (appEmbedded)
                return;

            var loggedInListener = $rootScope.$on('user-logged-in', register);
            var registeredListener = $rootScope.$on('user-registered', register);

            $scope.isLoggedIn = AuthService.isAuthenticated();
            var isAdmin = AuthService.isAdmin();
            if (!$scope.isLoggedIn || isAdmin)
                return;

            $timeout(register, 2500);

            $scope.$on('$destroy', function() {
                if (loggedInListener) loggedInListener();
                if (registeredListener) registeredListener();
            });
        }
    };
});
/* origin: public/webapp/directives/kibana-field-selector/kibana-field-selector.js */
angular.module('webApp').directive('kibanaFieldSelector', function ($q, AccountService, DelayChunkLoader) {
    return {
        restrict: 'E',
        templateUrl: 'directives/kibana-field-selector/kibana-field-selector.html',
        scope: {
            selectedField: '=',
            selectedFieldCallback: '&',
            selectorDisabled: '=',
            fieldName: '@'
        },
        link: function(scope) {

            scope.logTypeFilter = { value: '' };

            scope.filterFieldsByType = function() {
                var filterValue = _.get(scope.logTypeFilter, 'value');
                if (filterValue === 'Clear filter') {
                    filterValue = '';
                }

                scope.filteredFields = [];
                return AccountService.getAccountFieldsByType(filterValue, 3000).then(function (res) {
                    DelayChunkLoader(scope.filteredFields, Object.keys(res.data), 100, 500);
                });
            };

            scope.loadFilterFields = function () {
                scope.loading = true;
                scope.filterFieldsByType().finally(function () {
                    scope.loading = false;
                });
            };

            scope.loading = true;
            $q.all([
                AccountService.getAccountLogTypes(),
                scope.filterFieldsByType() // Init
            ]).then(function (res) {
                scope.logTypes = res[0];
            }).finally(function () {
                scope.loading = false;
            });

            scope.onSelectedFieldCallback = function() {
                scope.selectedFieldCallback(scope.selectedField);
                scope.logTypeFilter.value = 'Clear filter';
            };
        }
    };
});
/* origin: public/webapp/directives/kibana-logs-table-row/kibana-logs-table-row-controller.js */
angular.module('webApp').controller('KibanaLogsTableRowController', function ($scope) {
    var vm = this;
    vm.log = $scope.log;
    vm.mapping = $scope.mapping;

    vm.toggleLog = function () {
        vm.log.open = vm.log.open === undefined
            ? true
            : !vm.log.open;
    };
});
/* origin: public/webapp/directives/kibana-logs-table-row/kibana-logs-table-row.js */
angular.module('webApp').directive('kibanaLogsTableRow', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/kibana-logs-table-row/kibana-logs-table-row.html',
        controller: 'KibanaLogsTableRowController',
        controllerAs: 'vm',
        scope: {
            log: '=ngModel',
            mapping: '='
        }
    };
});
/* origin: public/webapp/directives/kibana-logs-table/kibana-logs-table-controller.js */
angular.module('webApp').controller('KibanaLogsTableController', function ($scope, $timeout) {
    var vm = this;
    vm.logsData = $scope.logsData;
    vm.mapping = $scope.mapping;
    vm.name = $scope.name;

    vm.paginationData = {
        from: 1,
        to: 15,
    };

    var changeDisplay = function (showUnparsed) {
        if (showUnparsed) {
            vm.displayMode = 'unparsed';
            vm.displayLogs = vm.logsData.unparsed;
        }
        else {
            vm.displayMode = 'all';
            vm.displayLogs = vm.logsData.logs;
        }
    };
    changeDisplay(vm.logsData.unparsed.length > 0);

    var renderDisplayTimer;
    vm.renderDisplayMode = function (showUnparsed) {
        if (vm.renderingDisplayMode) {
            $timeout.cancel(renderDisplayTimer);
        }

        vm.renderingDisplayMode = true;
        renderDisplayTimer = $timeout(function () {
            vm.renderingDisplayMode = false;
            vm.paginationData = {
                from: 1,
                to: 15,
            };

            changeDisplay(showUnparsed);
        }, 500);
    };

    vm.prevPage = function () {
        if (vm.paginationData.from - 1 < 1) return;

        vm.paginationData.from = Math.max(vm.paginationData.from - 15, 1);
        vm.paginationData.to = vm.paginationData.from + 14;

        renderPagination();
    };

    vm.nextPage = function () {
        if (vm.paginationData.to + 1 > vm.displayLogs.length) return;

        vm.paginationData.from += 15;
        vm.paginationData.to = Math.min(vm.paginationData.from + 14, vm.displayLogs.length);

        renderPagination();
    };

    var renderPaginationTimer;
    var renderPagination = function () {
        if (vm.renderingPagination) {
            $timeout.cancel(renderPaginationTimer);
        }

        vm.renderingPagination = true;
        renderPaginationTimer = $timeout(function () {
            vm.renderingPagination = false;
        }, 500); // For the fade out - fade in animation
    };

    $scope.$on('$destroy', function () {
        if (vm.renderingPagination) $timeout.cancel(renderPaginationTimer);
        if (vm.renderingDisplayMode) $timeout.cancel(renderDisplayTimer);
    });
});
/* origin: public/webapp/directives/kibana-logs-table/kibana-logs-table.js */
angular.module('webApp').directive('kibanaLogsTable', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/kibana-logs-table/kibana-logs-table.html',
        controller: 'KibanaLogsTableController',
        controllerAs: 'vm',
        scope: {
            logsData: '=ngModel',
            mapping: '=',
            name: '@'
        }
    };
});
/* origin: public/webapp/directives/logz-button-processing.js */
angular.module('webApp').directive('logzFormButton', [function() {
    return {
        restrict: 'E',
        template: '<span class="new-button" ng-class="{\'primary\':primary, \'disabled\':processing}"><i class="fa fa-spinner fa-spin" ng-class="{\'hidden\':!processing}"></i><i class="fa {{icon}}" ng-class="{\'hidden\':processing}"></i><ng-transclude></ng-transclude></span>',
        transclude: true,
        scope: {
            processing: '=?',
            primary: '=?',
            icon: '@?'
        },
        link: function() { }
    };
}]);
/* origin: public/webapp/directives/logz-checklist-item.js */
angular.module('webApp').directive('logzChecklistItem', [function() {
    return {
        restrict: 'E',
        transclude: true,
        template: '<div class="checklist-item clearfix"><i class="fa fa-check"></i><span class="item" ng-transclude></span></div>'
    };
}]);
/* origin: public/webapp/directives/logz-click-to-copy.js */
angular.module('webApp').directive('logzClickToCopy', [function() {
    var link = function(scope, element) {
        (function() {
            var clipboard = new Clipboard(element[0], {
                text: function() {
                    return element[0].getAttribute('logz-click-to-copy');
                }
            });

            scope.$on('$destroy', function() {
                clipboard.destroy();
            });

        }());
    };

    var isolatedScope = {
        logzClickToCopy: '@'
    };

    return {
        restrict: 'A',
        link: link,
        scope: isolatedScope
    };
}]);



/* origin: public/webapp/directives/logz-cloudtrail-settings.js */
angular.module('webApp').directive('logzCloudtrailSettings', function($timeout, Backend, AuthService, AnalyticsService) {

    return {
        restrict: 'E',
        templateUrl: 'directives/logz-cloudtrail-settings.html',
        scope: {
            accountId: '=',
            settings: '=?'
        },
        link: function(scope) {

            if (!AuthService.isAuthenticated())
                return;

            scope.errors = {};
            scope.deleted = false;

            scope.saveCloudtrailSettings = function(cloudtrailSettingsId) {
                if (!scope.settings.s3bucket || !scope.settings.s3accessKey || !scope.settings.s3secretKey || !scope.settings.prefix) {
                    scope.errorMessage = 'Please fill in all fields';

                    AnalyticsService.report('cloudtail:save-settings-error', {
                        error: scope.errorMessage,
                        severity: 'warning'
                    });

                    $timeout(function() {
                        scope.errorMessage = '';
                    }, 5000);
                    return;
                }

                if (scope.saving)
                    return;

                scope.saving = true;
                var settings = {
                    accountId: scope.accountId,
                    s3bucket: scope.settings.s3bucket,
                    prefix: scope.settings.prefix,
                    active: scope.settings.active,
                    s3accessKey: scope.settings.s3accessKey,
                    s3secretKey: scope.settings.s3secretKey
                };
                if (cloudtrailSettingsId) {
                    settings.id = cloudtrailSettingsId;
                }

                Backend.POST('/account-cloudtrail', settings).then(function(savedSettings) {
                    if (savedSettings.data === '') {
                        scope.errorMessage = 'Failed to save or update CloudTrail settings';
                        scope.saving = false;

                        AnalyticsService.report('cloudtail:save-settings-error', {
                            error: scope.errorMessage,
                            severity: 'warning'
                        });

                        $timeout(function() {
                            scope.errorMessage = '';
                        }, 8000);
                        return;
                    }

                    AnalyticsService.report('cloudtail:save-settings');

                    scope.saveSuccess = true;

                    var secretKey = scope.settings.s3secretKey;
                    scope.settings = savedSettings.data;
                    scope.settings.s3secretKey = secretKey; // We don't get this from services

                    $timeout(function() {
                        scope.saveSuccess = false;
                    }, 3000);
                    scope.saving = false;
                }).catch(function(error) {
                    scope.errorMessage = error.data || 'Failed to save or update settings';

                    AnalyticsService.report('cloudtail:save-settings-error', {
                        error: scope.errorMessage,
                        severity: 'error'
                    });

                    scope.saving = false;
                    $timeout(function() {
                        scope.errorMessage = '';
                    }, 8000);
                });
            };

            scope.deleteCloudtrailSettings = function(settingId) {
                if (!window.confirm('Are you sure you want to delete these CloudTrail settings?'))
                    return;

                Backend.DELETE('/account/cloudtrail', {
                    id: settingId,
                    accountId: scope.accountId
                }).then(function() {
                    AnalyticsService.report('cloudtail:delete-settings');

                    scope.deleted = true;
                }).catch(function(ex) {
                    scope.errorMessage = 'Failed to delete CloudTrail settings';
                    if (ex && ex.data && typeof ex.data === 'string') {
                        scope.errorMessage = ex.data;
                    }
                    $timeout(function() {
                        scope.errorMessage = '';
                    }, 8000);
                });
            };

            scope.addCloudtrailBucket = function() {
                scope.$parent.addCloudtrailSettings();
            };
        }
    };

});
/* origin: public/webapp/directives/logz-code-section.js */
angular.module('webApp').directive('logzCodeSection', function($timeout) {
    return {
        restrict: 'E',
        scope: true,
        link: function(scope, element) {
            var innerWrapper = angular.element('<div/>');
            innerWrapper.text(element.text());

            element.text('');
            element.append(innerWrapper);

            var copyButton = angular.element('<div class=\"clipboard-copy\"/>')
                .append(angular.element('<span class=\"fa fa-copy\"></span>'))
                .append(' Copy');
            element.append(copyButton);
            element.addClass('logz-code-section');

            var copiedMessageText = 'Copied to clipboard';
            var copiedMessage = angular.element('<div class=\"copy-success-message\" style=\"display:none; opacity:0;\"/>')
                .append(angular.element('<div class=\"message\">' + copiedMessageText + '</div>'));
            element.append(copiedMessage);

            var getTextToCopy = function(el) {
                return cleanText(el.text());
            };
            var cleanText = function(str) {
                var trimmed = str
                    .replace('Copy', '')
                    .replace(copiedMessageText, '')
                    .trim();

                // clean \u2028 characters
                return trimmed.replace(/((?!.)\s)+/g, '\n');
            };

            /* eslint-disable */
            var clipboard = new Clipboard('.clipboard-copy', {
                text: function(trigger) {
                    var copyArea = $(trigger.parentNode);

                    var copiedMessage = copyArea.find('.copy-success-message');
                    copiedMessage.css('display', 'block');
                    var a = copiedMessage.css('height'); // hack to force browser to refresh dom tree
                    copiedMessage.css('opacity', '1');
                    $timeout(function() {
                        copiedMessage.css('opacity', '0');
                        var a = copiedMessage.css('height'); // hack to force the browser refresh dom tree
                        copiedMessage.css('display', 'none');
                    }, 2000);

                    return getTextToCopy(copyArea);
                }
            });
            /* eslint-enable */

        }
    };
});

/* origin: public/webapp/directives/logz-date-input.js */
angular.module('webApp').directive('logzDateInput', [function() {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attrs, ngModel) {
            ngModel.$formatters.unshift(function(value) {
                var date = new Date(parseInt(value));
                if (isNaN(date.getTime())) return value;

                if (date.getHours() === 0 && date.getMinutes() === 0) {
                    return date.getDate() + '/' + parseInt(date.getMonth()+1) + '/' + date.getFullYear();
                }

                return date.getDate() + '/' + parseInt(date.getMonth()+1) + '/' + date.getFullYear() + ' ' + date.getHours() + ':' + date.getMinutes();
            });

            ngModel.$render = function() {
                element.val(ngModel.$viewValue);
            };

            ngModel.$parsers.unshift(function(viewValue) {
                var dateParts = viewValue.split('/');
                var date;

                if (dateParts[2].length === 4) {
                    date = new Date(Date.UTC(dateParts[2], parseInt(dateParts[1]) - 1, dateParts[0]));
                    if (isNaN(date.getTime())) return viewValue;
                    return date.getTime();
                }

                var timeParts = dateParts[2].split(' ')[1].split(':');
                date = new Date(Date.UTC(dateParts[2].substr(0, 4), parseInt(dateParts[1]) - 1, dateParts[0], timeParts[0], timeParts[1]));
                if (isNaN(date.getTime())) return viewValue;
                return date.getTime();
            });
        }
    };
}]);
/* origin: public/webapp/directives/logz-dialog/logz-dialog-close/logz-dialog-close.js */
angular.module('webApp').directive('logzDialogClose', function($compile) {
    return {
        restrict: 'A',
        scope: {
            closeFunc: '&logzDialogClose'
        },
        link: function(scope, element) {
            var closeSpan = angular.element('<span class="dialog-close logz-x-close pull-right" ng-click="closeFunc()"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.68 13.6"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><line x1="13.03" y1="12.95" x2="0.65" y2="0.65"/><line x1="0.65" y1="12.95" x2="13.03" y2="0.65"/></g></g></svg></span>');
            element.before($compile(closeSpan)(scope));
        }
    };
});
/* origin: public/webapp/directives/logz-dialog/logz-dialog-header/logz-dialog-header.js */
angular.module('webApp').directive('logzDialogHeader', [function() {
    return {
        restrict: 'E',
        templateUrl: 'directives/logz-dialog/logz-dialog-header/logz-dialog-header.html',
        scope: {
            text: '@'
        }
    };
}]);
/* origin: public/webapp/directives/logz-dialog/logz-dialog-seperator/logz-dialog-seperator.js */
angular.module('webApp').directive('logzDialogSeperator', [function() {
    return {
        restrict: 'E',
        templateUrl: 'directives/logz-dialog/logz-dialog-seperator/logz-dialog-seperator.html',
        scope: {
            text: '@?'
        }
    };
}]);
/* origin: public/webapp/directives/logz-elb-settings.js */
angular.module('webApp').directive('logzElbSettings', function($timeout, Backend, AuthService, AnalyticsService) {

    return {
        restrict: 'E',
        templateUrl: 'directives/logz-elb-settings.html',
        scope: {
            accountId: '=',
            settings: '='
        },
        link: function(scope) {

            if (!AuthService.isAuthenticated())
                return;

            scope.errors = {};
            scope.deleted = false;
            scope.showRegionError = false;

            scope.saveElbSettings = function(elbSettingsId) {
                if (!scope.settings.bucket || !scope.settings.accessKey || !scope.settings.secretKey || !scope.settings.region) {
                    if (!scope.settings.region)
                        scope.showRegionError = true;
                    scope.errorMessage = 'Please fill in all fields';

                    AnalyticsService.report('elb:save-settings-error', {
                        error: scope.errorMessage,
                        severity: 'warning',
                        category: 'elb'
                    });

                    $timeout(function() {
                        scope.errorMessage = '';
                    }, 5000);
                    return;
                }

                if (scope.saving)
                    return;

                scope.showRegionError = false;

                scope.saving = true;
                var settings = {
                    accountId: scope.accountId,
                    bucket: scope.settings.bucket,
                    prefix: scope.settings.prefix || '',
                    accessKey: scope.settings.accessKey,
                    secretKey: scope.settings.secretKey,
                    logsType: 'elb',
                    active: scope.settings.active,
                    region: scope.settings.region
                };
                if (elbSettingsId) {
                    settings.id = elbSettingsId;
                }

                Backend.POST('/s3buckets/' + (settings.id ? 'update' : 'create'), settings).then(function(savedSettings) {
                    if (savedSettings.data === '') {
                        scope.errorMessage = 'Failed to save or update settings';
                        scope.saving = false;

                        AnalyticsService.report('elb:save-settings-error', {
                            error: scope.errorMessage,
                            severity: 'warning',
                            category: 'elb'
                        });

                        $timeout(function() {
                            scope.errorMessage = '';
                        }, 8000);
                        return;
                    }

                    AnalyticsService.report('elb:save-settings', {category: 'elb'});

                    scope.saveSuccess = true;

                    var secretKey = scope.settings.secretKey;
                    scope.settings = savedSettings.data;
                    scope.settings.secretKey = secretKey; // We don't get this from services

                    $timeout(function() {
                        scope.saveSuccess = false;
                    }, 3000);
                    scope.saving = false;
                }).catch(function(error) {
                    scope.errorMessage = error.data || 'Failed to save or update settings';

                    AnalyticsService.report('elb:save-settings-error', {
                        error: scope.errorMessage,
                        severity: 'error',
                        category: 'elb'
                    });

                    scope.saving = false;
                    $timeout(function() {
                        scope.errorMessage = '';
                    }, 8000);
                });
            };

            scope.deleteElbSettings = function(settingId) {
                if (!window.confirm('Are you sure you want to delete these settings ?'))
                    return;

                Backend.DELETE('/s3buckets/' + settingId, scope.settings).then(function() {

                    AnalyticsService.report('elb:delete-settings', {category: 'elb'});

                    scope.deleted = true;
                }).catch(function(ex) {
                    scope.errorMessage = 'Failed to delete ELB settings';
                    if (ex && ex.data && typeof ex.data === 'string') {
                        scope.errorMessage = ex.data;
                    }
                    $timeout(function() {
                        scope.errorMessage = '';
                    }, 8000);
                });
            };

            scope.addElbBucket = function() {
                scope.$parent.addElbSettings();
            };
        }
    };

});
/* origin: public/webapp/directives/logz-email-list.js */
angular.module('webApp').directive('logzEmailList', [function() {

    function validEmail(email) {
        var re = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i;
        return re.test(email);
    }

    return {
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attrs, model) {
            model.$parsers.unshift(function(value) {
                if (!value) {
                    model.$setValidity('logzEmailList', true);
                    return '';
                }

                var valid = true;
                var emails = value.split(',');
                emails.forEach(function(email) {
                    if (!validEmail(email.trim())) {
                        model.$setValidity('logzEmailList', false);
                        valid = false;
                    }
                });

                if (valid) {
                    model.$setValidity('logzEmailList', true);
                    return value;
                }

                return undefined;
            });
        }
    };
}]);
/* origin: public/webapp/directives/logz-focus-on.js */
angular.module('webApp').directive('focusOn', function($timeout) {
    return function(scope, elem, attr) {
        scope.$on('focusOn', function(e, name) {
            if(name !== attr.focusOn)
                return;

            $timeout(function() {
                elem[0].focus();
            }, 0);
        });
    };
});
/* origin: public/webapp/directives/logz-form-status.js */
angular.module('webApp').directive('logzFormStatus', [function() {
    var html = '<div class="form-status" ng-hide="!status.message" ng-class="{\'success\':status.success,\'error\':status.error}"><i class="fa" ng-class="{\'fa-check\':status.success,\'fa-remove\':status.error}"></i>{{status.message}}</div>';
    return {
        restrict: 'E',
        template: html,
        scope: {
            status: '=?'
        }
    };
}]);
/* origin: public/webapp/directives/logz-header/logz-header-controller.js */
angular.module('webApp').controller('LogzHeaderCtrl', function($rootScope, $scope, $state, $timeout, AccountService, UpgradeService, AuthService, UserService, appEmbedded, cacheService, InsightsService, AnalyticsService, FeatureFlagService) {

    $scope.isEmbedded = appEmbedded;

    var requiresAuthentication = !!($state.current.data && $state.current.data.authenticate);

    $scope.isAlertsPageActive = function () {
        return $state.includes('dashboard.alerts');
    };

    $scope.isLogShippingActive = function () {
        return $state.includes('dashboard.dataSources') || $state.includes('dashboard.dataParsing');
    };

    $scope.goHome = function() {
        if (window.location.hash.indexOf('homepage') > 0) {
            window.location.href = 'http://logz.io/';
            return;
        }

        $state.go('login');
    };

    $scope.upgradeNow = function() {
        $state.go('dashboard.settings.usage-and-billing');
        AnalyticsService.report('upgrade', { event: 'click', location: 'header' });
    };

    $scope.isLoggingSuspended = false;
    if (!AuthService.isAuthenticated()) {
        $scope.anonymous = true;
        return;
    }

    UpgradeService.getPlanDetails().then(function(planDetails) {
        if (!planDetails.data || !planDetails.data.planType) return;
        $scope.planType = planDetails.data.planType.toLowerCase();
        $scope.isFreePlan = planDetails.data.planType.toLowerCase() === 'free';
        $scope.isTrialPlan = planDetails.data.planType.toLowerCase() === 'trial';

        if ($scope.isTrialPlan) {
            var endDate = new Date(planDetails.data.endDate);
            var now = new Date();
            $scope.expireDays = Math.round((endDate - now) / (1000 * 60 * 60 * 24));
        }
    });

    if (appEmbedded) return;
    if (requiresAuthentication && $scope.anonymous) return;

    AuthService.getUser().then(function(user) {
        $scope.user = user.data;
    }).catch(function() {
        $state.go('login');
    });
    UserService.getSummary().then(function(res) {
        $scope.accountName = res.data.accountName;

        if (res.data.accountLogsSuspensionStae !== 'NOT_SUSPENDED') {
            $scope.isLoggingSuspended = true;
            $rootScope.isLoggingSuspended = true;
        }
    });

    $scope.logout = AuthService.logout;

    $scope.closeAccountsList = function() {
        try {
            $scope.$apply(function() {
                $scope.showAccountsList = false;
            });
        }
        catch (ex) {
            $scope.showAccountsList = false;
        }
    };

    var loadUserAccounts = function() {
        AuthService.getUser().then(function(user) {
            AccountService.getUserAccounts().then(function(accountsList) {
                $scope.loadingAccountsList = false;
                $scope.accountsList = _.filter(_.uniq(accountsList, 'accountId'), function(account) {
                    return account.accountId !== user.data.accountId;
                });
            }).finally(function() {
                $scope.loadingAccountsList = false;
            });
        });
    };

    $scope.loadingAccountsList = true;
    $scope.openAccountsMenu = function() {
        if (Object.prototype.toString.call($scope.accountsList) === '[object Array]' && $scope.accountsList.length === 0) {
            return;
        }
        if ($scope.showAccountsList) {
            $scope.showAccountsList = false;
            return;
        }
        $scope.showAccountsList = true;

        if (!$scope.accountsList) {
            loadUserAccounts();
        }

        $timeout(function() {
            $('body', $('#kibana-iframe').contents()).one('click', $scope.closeAccountsList);
        }, 100);
    };
    loadUserAccounts();

    $scope.switchAccount = AuthService.switchAccount;

    $scope.insightsSummary = InsightsService.getSummary();

    $scope.liveTailEnabled = false;
    FeatureFlagService.isFeatureEnabled('live-tail').then(function (enabled) {
        $scope.liveTailEnabled = enabled;
    });

    $scope.dataParsingEnabled = false;
    FeatureFlagService.isFeatureEnabled('data-parsing').then(function (enabled) {
        $scope.dataParsingEnabled = enabled;
    });

    $scope.incidentsFeatureEnabled = false;
    FeatureFlagService.isFeatureEnabled('insights-ui').then(function (enabled) {
        $scope.incidentsFeatureEnabled = enabled;
    });

    $rootScope.$on('SubAccounts.updated', loadUserAccounts);
    $rootScope.$on('Account.updatedName', function(event, newAccountName) {
        $scope.accountName = newAccountName;
        cacheService.clearAllCache();
    });
});

/* origin: public/webapp/directives/logz-header/logz-header.js */
angular.module('webApp').directive('logzHeader', [function() {
    return {
        restrict: 'E',
        templateUrl: 'directives/logz-header/logz-header.html',
        controller: 'LogzHeaderCtrl'
    };
}]);
/* origin: public/webapp/directives/logz-input-limit.js */
angular.module('webApp').directive('logzInputLimit', [function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            var limit = attrs['logzInputLimit'];

            var listener = scope.$watch(function() {
                return element.val();
            }, function() {
                element.val(element.val().substr(0, limit-1));
            });

            scope.$on('$destroy', listener);
        }
    };
}]);

/* origin: public/webapp/directives/logz-input-validation.js */
angular.module('webApp').directive('logzInputValidation', [function() {
    return {
        restrict: 'A',
        link: function(scope, element, attr) {

            element.bind('keydown', function(event) {
                element.removeClass('warn');

                if (attr.maxLength && element.val().length > attr.maxLength) {
                    event.preventDefault();
                    return false;
                }

                if (event.keyCode >= 8 && event.keyCode <= 57) {
                    return true;
                }

                if (attr.numeric && (event.keyCode < 96 || event.keyCode > 109)) {
                    event.preventDefault();
                    return false;
                }
            });

            element.bind('blur', validateInput);
            element.bind('focus', validateInput);

            function validateInput() {
                if (attr.minValue && parseInt($(this).val()) < attr.minValue) {
                    element.addClass('warn');
                }

                if (attr.maxLength && element.val().length > attr.maxLength) {
                    element.val(element.val().substr(0, attr.maxLength));
                }

                if (attr.nonEmpty && element.val().trim().length === 0) {
                    element.addClass('warn');
                }

                if (attr.emailList) {
                    var emails = element.val().trim().split(',');
                    for (var i=0; i<emails.length; i++) {
                        if (emails[i].trim().length === 0)
                            continue;
                        if (emails[i].trim().length > 200)
                            element.addClass('warn');
                        if (!validEmail(emails[i].trim()))
                            element.addClass('warn');
                    }
                }
            }

            function validEmail(email) {
                var re = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i;
                return re.test(email);
            }
        }
    };
}]);
/* origin: public/webapp/directives/logz-numeric/logz-numeric-controller.js */
angular.module('webApp').controller('LogzNumericController', function ($scope) {
    $scope.validate = function () {
        if (typeof $scope.minValue !== 'undefined')
            $scope.numericForm['numericPanel'].$setValidity('min', $scope.model >= $scope.minValue);

        if (typeof $scope.maxValue !== 'undefined')
            $scope.numericForm['numericPanel'].$setValidity('max', $scope.model <= $scope.maxValue);

        if ($scope.precision !== undefined) {
            $scope.model = parseFloat($scope.model.toFixed($scope.precision));
        }
    };

    if (!$scope.model) {
        $scope.model = $scope.defaultValue || $scope.minValue || 0;
    }

    var modelWatcher = $scope.$watch('model', $scope.validate);
    var minValueWatcher = $scope.$watch('minValue', $scope.validate);
    var maxValueWatcher = $scope.$watch('maxValue', $scope.validate);

    $scope.increment = function() {
        if ($scope.isDisabled) {
            return;
        }

        $scope.model++;
        $scope.validate();
    };
    $scope.decrement = function() {
        if ($scope.isDisabled) {
            return;
        }

        $scope.model--;
        $scope.validate();
    };

    $scope.$on('$destroy', function () {
        if (modelWatcher) modelWatcher();
        if (minValueWatcher) minValueWatcher();
        if (maxValueWatcher) maxValueWatcher();
    });
});
/* origin: public/webapp/directives/logz-numeric/logz-numeric.js */
angular.module('webApp').directive('logzNumeric', [ function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/logz-numeric/logz-numeric.html',
        controller: 'LogzNumericController',
        link: function(scope) {
            scope.validate();
        },
        scope: {
            isDisabled: '=',
            model: '=ngModel',
            minValue: '=?',
            maxValue: '=?',
            focusEvent: '=',
            defaultValue: '=',
            suffixLabel: '@',
            inputId: '@',
            precision: '=?',
            hideValidationErrorMessage: '='
        }
    };
}]);
/* origin: public/webapp/directives/logz-placeholder.js */
angular.module('webApp').directive('logzPlaceholder', function () {
    return {
        restrict: 'A',
        scope: {
            placeholder: '=logzPlaceholder'
        },
        link: function (scope, elem) {
            scope.$watch('placeholder', function () {
                elem[0].placeholder = scope.placeholder;

            });
        }
    };
});

/* origin: public/webapp/directives/logz-popover/logz-popover.js */
angular.module('webApp').directive('logzPopover', function($timeout, $document, $window, $controller, $compile, $templateRequest, $sce){
    return {
        scope: {
            popoverController: '@?',
            popoverWidth: '@?',
            popoverHtml: '@?',
            popoverTransclude: '<?',
            popoverApplyCallback: '=?',
            data: '=?popoverData',
            popoverFrom: '@?',
            popoverCloseCallbackFunction: '=?',
            popoverOpenOnCreation: '@?'
        },
        transclude: true,
        restrict: 'A',
        link: function (scope, element, attrs, ctrl, transclude) {
            var popoverDialog;
            var elementWidth = parseFloat(scope.popoverWidth) || 400;
            var outerPadding = 40;
            var isComingFromTopLeft = true;
            var backDropElement;
            var backDropElementCss = {
                'position': 'fixed',
                'top': 0, 'left': 0,
                'z-index': 79,
                'display': 'block',
                'width': '100vw', 'height': '100vh'
            };

            scope.popoverCloseCallbackFunction = scope.popoverCloseCallbackFunction || function () {};
            scope.dialogOpen = false;

            if (!scope.popoverTransclude) {
                transclude(scope, function (clone) {
                    $compile(clone)(scope.$parent);
                    element.append(clone);
                });
            }

            var createBackDropLayer = function () {
                backDropElement = $('<div class="popover-backdrop-layer">');
                backDropElement.css(backDropElementCss);
                backDropElement.bind('click', closeByBackdropHandler);
                backDropElement.appendTo($document.find('body'));
            };

            var closeByBackdropHandler = function () {
                scope.$apply(function () {
                    scope.closeCallback();
                });
            };

            var mouseClickHandler = function () {
                if (scope.dialogOpen) return;
                var templateUrl = $sce.getTrustedResourceUrl(scope.popoverHtml);
                popoverDialog = $('<div class="logz-popover-dialog">');
                if (scope.popoverTransclude) {
                    transclude(scope, compileByTemplate);
                }
                else {
                    $templateRequest(templateUrl).then(compileByTemplate);
                }
            };

            scope.closeCallback = function (overrideCallback) {
                popoverDialog.removeClass('show');
                angular.element($window).off('resize', onResize);
                $timeout(function () {
                    popoverDialog.remove();
                    backDropElement.remove();
                    scope.dialogOpen = false;
                    if (!overrideCallback) {
                        scope.popoverCloseCallbackFunction(scope);
                    }
                }, 500);
            };

            function compileElement() {
                if (scope.popoverController) {
                    var controllerInstance = $controller(scope.popoverController, {
                        $scope: scope,
                        $element: popoverDialog
                    });

                    popoverDialog.data(scope.popoverController, controllerInstance);
                }
                $compile(popoverDialog)(scope);
            }

            function addTransitionProperties() {
                var targetRect = element[0].getBoundingClientRect();
                var elementCss = {top: targetRect.top + $window.pageYOffset, width: elementWidth};
                isComingFromTopLeft = $document[0].body.clientWidth - targetRect.right > elementWidth + outerPadding;


                if (isComingFromTopLeft) {
                    elementCss.left = targetRect.left;
                    popoverDialog.addClass('leave-from-left-top');
                }
                else {
                    elementCss.left = targetRect.right - elementWidth;
                    popoverDialog.addClass('leave-from-right-top');
                }

                scope.popoverFrom = scope.popoverFrom || 'top';
                if (scope.popoverFrom === 'bottom') {
                    elementCss.top = targetRect.bottom + $window.pageYOffset;
                }

                if ($document[0].body.clientWidth < elementWidth * 2) { // width of screen is too small
                    elementCss.left = ($document[0].body.clientWidth - elementWidth) / 2;
                }
                popoverDialog.css(elementCss);
            }

            function compileByTemplate(template) {
                popoverDialog.append(angular.element(template));

                addTransitionProperties();
                compileElement();

                popoverDialog.appendTo($document.find('body'));

                $timeout(function () {
                    popoverDialog.addClass('show');
                    createBackDropLayer();
                    angular.element($window).bind('resize', onResize);
                    scope.dialogOpen = true;
                });

            }

            function onResize() {
                $timeout(function () {
                    if (!scope.dialogOpen) return;
                    addTransitionProperties();
                    scope.$digest();
                }, 600);
            }

            element.on('click', mouseClickHandler);
            if (scope.popoverOpenOnCreation) $timeout(mouseClickHandler);

            scope.$on('$destroy', function () {
                angular.element($window).off('resize', onResize);
                element.off('click', mouseClickHandler);
                if (popoverDialog && popoverDialog.remove) popoverDialog.remove();
                if (backDropElement && backDropElement.remove) backDropElement.remove();
            });

        },

    };
});


//todo reduce width to min width when screen is small
/* origin: public/webapp/directives/logz-radio-selector/logz-radio-selector.js */
angular.module('webApp').directive('logzRadioSelector', function($compile, $timeout) {
    return {
        restrict: 'E',
        require: 'ngModel',
        link: function(scope, element, attrs, ngModel) {

            var selectionClick = function() {
                var selections = element.find('.logz-radio-selector');
                var value = $(this).attr('value');

                ngModel.$setViewValue(value);
                ngModel.$commitViewValue();

                for (var i = 0; i < selections.length; i++) {
                    if ($(selections[i]).attr('value') === value)
                        $(selections[i]).addClass('selected');
                    else
                        $(selections[i]).removeClass('selected');
                }
            };

            var selectionChangeWatcher = scope.$watch(function() { return element.childElementCount; }, function() {
                var selections = element.find('.logz-radio-selector');
                selections.click(selectionClick);
            });

            ngModel.$formatters.unshift(function(value) {
                $timeout(function() {
                    var options = element.find('.logz-radio-selector');
                    for (var i = 0; i < options.length; i++) {
                        if ($(options[i]).html() === value) {
                            $(options[i]).triggerHandler('click');
                            break;
                        }
                    }
                }, 0);
            });

            scope.$on('$destroy', function() {
                if (selectionChangeWatcher) selectionChangeWatcher();
            });
        }
    };
});

/* origin: public/webapp/directives/logz-s3-settings.js */
angular.module('webApp').directive('logzS3Settings', function($timeout, Backend, AuthService, AnalyticsService) {

    return {
        restrict: 'E',
        templateUrl: 'directives/logz-s3-settings.html',
        scope: {
            accountId: '=',
            settings: '=',
            logType: '=?'
        },
        link: function (scope) {

            if (!AuthService.isAuthenticated())
                return;

            var initialSecretKey = scope.settings ? scope.settings.encryptedSecretKey : undefined;

            Backend.GET('/supported-log-types').then(function(logTypes) {
                scope.supportedLogTypes = [{'type': 'other'}].concat(logTypes.data);
                _.remove(scope.supportedLogTypes, { type: 'cloudtrail' });
                if (scope.settings && _.map(scope.supportedLogTypes, 'type').indexOf(scope.settings.logsType) === -1) {
                    scope.settings.otherType = scope.settings.logsType;
                    scope.settings.logsType = 'other';
                }

                if (scope.logType && scope.settings) {
                    scope.settings.logsType = scope.logType;
                    scope.settings.otherType = '';
                }
            });

            scope.errors = {};
            scope.deleted = false;
            scope.showRegionError = false;
            scope.saveSettings = function(elbSettingsId) {
                if (!scope.settings.bucket || !scope.settings.accessKey ||
                    !scope.settings.secretKey || !scope.settings.region ||
                    (scope.settings.logsType === 'other' && !scope.settings.otherType)) {
                    if (!scope.settings.region)
                        scope.showRegionError = true;
                    scope.errorMessage = 'Please fill in all fields';

                    AnalyticsService.report('aws:save-settings-error', {
                        error: scope.errorMessage,
                        severity: 'warning',
                        category: 'aws'
                    });

                    $timeout(function() {
                        scope.errorMessage = '';
                    }, 5000);
                    return;
                }

                if (scope.saving)
                    return;

                scope.showRegionError = false;
                scope.saving = true;
                var settings = {
                    accountId: scope.accountId,
                    bucket: scope.settings.bucket,
                    prefix: scope.settings.prefix || '',
                    accessKey: scope.settings.accessKey,
                    logsType: scope.settings.logsType === 'other' ? scope.settings.otherType : scope.settings.logsType,
                    active: scope.settings.active,
                    region: scope.settings.region
                };

                // set secret key
                if (scope.settings.secretKey === initialSecretKey) {
                    settings.encryptedSecretKey = initialSecretKey;
                }
                else {
                    settings.secretKey = scope.settings.secretKey;
                }

                if (elbSettingsId) {
                    settings.id = elbSettingsId;
                }

                Backend.POST('/s3buckets/' + (settings.id ? 'update' : 'create'), settings).then(function(savedSettings) {
                    if (savedSettings.data === '') {
                        scope.errorMessage = 'Failed to save or update settings';
                        scope.saving = false;

                        AnalyticsService.report('aws:save-settings-error', {
                            error: scope.errorMessage,
                            severity: 'warning',
                            category: 'aws'
                        });

                        $timeout(function() {
                            scope.errorMessage = '';
                        }, 8000);
                        return;
                    }

                    AnalyticsService.report('aws:save-settings', {category: 'aws'});

                    scope.saveSuccess = true;

                    var secretKey = scope.settings.secretKey;
                    scope.settings = savedSettings.data;
                    scope.settings.secretKey = secretKey; // We don't get this from services

                    var supportedLogTypesArray = _.map(scope.supportedLogTypes, 'type');
                    if (supportedLogTypesArray.indexOf(scope.settings.logsType) === -1) {
                        scope.settings.otherType = scope.settings.logsType;
                        scope.settings.logsType = 'other';
                    }

                    $timeout(function() {
                        scope.saveSuccess = false;
                    }, 3000);
                    scope.saving = false;
                }).catch(function(ex) {
                    scope.errorMessage = 'Failed to save or update settings';
                    if (ex && ex.data && typeof ex.data === 'string') {
                        scope.errorMessage = ex.data;
                    }
                    scope.saving = false;
                    $timeout(function() {
                        scope.errorMessage = '';
                    }, 8000);
                });
            };

            scope.deleteDisabled = function() {
                return !scope.settings.id;
            };

            scope.deleteSettings = function(settingId) {
                if (!settingId)
                    return;

                if (!window.confirm('Are you sure you want to delete these settings ?'))
                    return;

                Backend.DELETE('/s3buckets/' + settingId, scope.settings).then(function() {
                    scope.settings = {
                        accountId: scope.accountId,
                        bucket: '',
                        prefix: '',
                        accessKey: '',
                        secretKey: '',
                        logsType: ''
                    };
                    scope.$parent.bucketDeleted(settingId);

                    AnalyticsService.report('aws:delete-settings', {category: 'aws'});

                }).catch(function(ex) {
                    scope.errorMessage = 'Failed to delete AWS settings';
                    if (ex && ex.data && typeof ex.data === 'string') {
                        scope.errorMessage = ex.data;
                    }
                    $timeout(function() {
                        scope.errorMessage = '';
                    }, 8000);
                });
            };

            scope.addBucket = function() {
                scope.$parent.addS3Settings();
            };
        }
    };

});
/* origin: public/webapp/directives/logz-search/logz-find.js */
angular.module('webApp').directive('logzFind', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/logz-search/logz-find.html',
        controller: 'logzFindController',
        scope: {
            name: '@',
            initialText: '=',
            onCloseCallback: '&?'
        }
    };
}).controller('logzFindController', function ($scope, $rootScope, logzSearchTerms) {
    $scope.current = 0;
    $scope.total = 0;
    $scope.text = $scope.initialText;
    $scope.name = $scope.name || 'logz-find';

    $scope.scrollDown = function () {
        theySeeMeScrollinTheyHatin(1);
    };
    $scope.scrollUp = function () {
        theySeeMeScrollinTheyHatin(-1);
    };

    $scope.inputKey = function (event) {
        if (event.keyCode === 13) {
            if (event.shiftKey)
                $scope.scrollUp();
            else
                $scope.scrollDown();
        }
        else if (event.keyCode === 27) {
            $scope.text = '';
        }
    };

    $scope.close = function() {
        if ($scope.onCloseCallback) {
            $scope.onCloseCallback()();
        }
    };

    $scope.onChange = function () {
        $scope.current = 0;
        $scope.total = 0;

        //we don't want to search for small queries,
        // but if the query is empty we're going to update everyone
        if ($scope.text && $scope.text.length < 2)
            return;

        logzSearchTerms.addTerm($scope.name, {
            text: $scope.text,
            class: 'query',
            id: 'query',
            isQuery: true
        });
    };

    var queryResultsEvent = $rootScope.$on('logz-search.' + $scope.name + '.query-result', function (event, amount) {
        $scope.total = amount;
        if ($scope.current > $scope.total)
            $scope.current = 0;
    });

    var clearQueryResultsEvent = $rootScope.$on('logz-search.' + $scope.name + '.clear-query-result', function () {
        $scope.total = 0;
        $scope.current = 0;
    });

    $scope.$on('$destroy', function () {
        queryResultsEvent();
        clearQueryResultsEvent();
    });

    function theySeeMeScrollinTheyHatin(diff) {
        if ($scope.total === 0) {
            $scope.current = 0;
            return;
        }

        $scope.current += diff;

        if ($scope.current <= 0)
            $scope.current = $scope.total;
        else if ($scope.current > $scope.total)
            $scope.current = 1;

        $rootScope.$emit('logz-search.' + $scope.name + '.scroll', $scope.current - 1);
    }
});
/* origin: public/webapp/directives/logz-search/logz-mark.js */
angular.module('webApp').directive('logzMark', function (gabby) {
    return {
        template: '',
        scope: gabby.scope(null, 'logzMark'),
        controller: 'logzMarkController'
    };
}).controller('logzMarkController', function ($scope, $element, $rootScope, LogzMarker, gabby) {
    gabby.for($scope)
        .settings({
            name: 'mark',
            getText: function() {}
        })
        .api({
            appendLine: function (line) {
                var html = logzMarker.getMarkedText(line);
                $element.append(html.markedText +'\r\n');
                queryMatchesCount += html.queryCount;
                reportMatches(html.queryCount);
            },
            renderAllText: function() {
                $scope.api.clear();
                var text = $scope.getText();
                var html = logzMarker.getMarkedText(text);
                $element.html(html.markedText);
                queryMatchesCount = html.queryCount;
                reportMatches();
            },
            clear: function () {
                queryMatchesCount = 0;
                $rootScope.$emit('logz-search.' + $scope.name + '.clear-query-result');
                $element.empty();
            }
        });

    var logzMarker = new LogzMarker($scope.name);
    var queryMatchesCount = 0;

    var termsUpdateEvent = $rootScope.$on('logz-search.' + $scope.name + '.terms-updated', function () {
        $scope.api.renderAllText();
    });

    var scrollTriggerEvent = $rootScope.$on('logz-search.' + $scope.name + '.scroll', function(event, scrollId) {

        var scrollElement = $element.find('span.query:eq(' + scrollId + ')');
        var elementTop = scrollElement.position().top;
        var halfScreen = $element.parent().height() / 2 || 0;
        var currentScroll = $element.parent().scrollTop() + halfScreen;
        var quarterScreen = halfScreen / 2;

        if (_.inRange(elementTop, currentScroll  - quarterScreen, currentScroll + quarterScreen)) {
            postScroll(scrollElement);
            return;
        }

        $element.parent().animate({ scrollTop: elementTop - halfScreen }, 100, postScroll.bind(null, scrollElement));
    });

    function postScroll(scrollElement) {
        $element.find('span.term').removeClass('selected');
        scrollElement.addClass('selected');
        $element.parent().focus();
    }


    $scope.$on('$destroy', function() {
        termsUpdateEvent();
        scrollTriggerEvent();
        $rootScope.$emit('logz-search.' + $scope.name + '.clear-query-result');
    });

    $scope.api.renderAllText();

    function reportMatches() {
        $rootScope.$emit('logz-search.' + $scope.name + '.query-result', queryMatchesCount);
    }
});
/* origin: public/webapp/directives/logz-search/logz-marker-service.js */
angular.module('webApp').factory('LogzMarker', function (logzSearchTerms) {
    var service = function (logzTermScopeName) {
        this.logzTermScopeName = logzTermScopeName;
    };

    service.prototype.getMarkedText = function (text) {
        var matchResult = matchTextWithTerms(this.logzTermScopeName, text);
        var markedText = getTextWithMarkedMatches(text, matchResult.matches, matchResult.locations);
        return {
            markedText: markedText,
            queryCount: matchResult.matches.filter(function (x) {
                return x.term.isQuery;
            }).length
        };
    };

    return service;

    function matchTextWithTerms(logzSearchName, text) {
        var matches = [];
        var locations = [];

        (logzSearchTerms.terms[logzSearchName] || []).forEach(function (t) {
            if (!t || !t.text)
                return;

            var r = new RegExp(_.escapeRegExp(t.text), 'gi');
            var match;
            do {
                match = r.exec(text);
                if (!match)
                    break;

                matches.push({
                    term: t,
                    index: match.index,
                    end: match.index + match[0].length
                });
                locations[match.index] = true;
                locations[match.index + match[0].length] = true;
            } while (match);
        });

        return {locations: locations, matches: matches};
    }

    function getTextWithMarkedMatches(text, matches, locations) {
        var lastIndex = 0;
        var html = '';

        locations.forEach(function (exists, index) {
            if (!exists)
                return;

            html += _.escape(text.slice(lastIndex, index));
            lastIndex = index;

            var newMatches = matches.filter(function (x) {
                return x.index === index;
            });
            var endingMatches = matches.filter(function (x) {
                return x.end === index;
            });

            var overlappingMatches = [];
            if (newMatches.length > 0)
                overlappingMatches = matches.filter(function (x) {
                    return x.index < index
                        && x.end > index
                        && newMatches.filter(function (y) {
                            return x.end < y.end;
                        }).length;
                });

            for (var i = 0; i < (endingMatches.length + overlappingMatches.length); i++) {
                html += '</span>';
            }

            _.orderBy(newMatches.concat(overlappingMatches), 'end', 'desc')
                .forEach(function (x) {
                    html += '<span class="term ' + x.term.class + '"' + (x.term.style ? ' style="' + x.term.style + '"' : '') + '>';
                });
        });

        if (lastIndex < text.length)
            html += _.escape(text.slice(lastIndex));

        html = html.replace(/^(<.+?>)*Error.+?$/gm, '<span class="error">$&</span>');

        return html;
    }
});

/* origin: public/webapp/directives/logz-search/logz-search-terms-service.js */
angular.module('webApp').factory('logzSearchTerms', function ($rootScope) {
    var service = {};
    service.terms = {};
    service.addTerm = function (name, term) {
        var termsForName = service.terms[name];
        if (termsForName) {
            var terms = termsForName.filter(function (x) {
                return x.id === term.id;
            });
            if (terms.length === 0) {
                termsForName.push(term);
            }
            else {
                angular.extend(terms[0], term);
            }
        }
        else {
            service.terms[name] = [term];
        }

        $rootScope.$emit('logz-search.' + name + '.terms-updated', service.terms[name]);
    };

    service.removeTerm = function (name, term) {
        _.pull(service.terms[name], term);
        $rootScope.$emit('logz-search.' + name + '.terms-updated', service.terms[name]);
    };

    return service;
});

/* origin: public/webapp/directives/logz-severity/logz-severity.js */
angular.module('webApp').directive('logzSeverity', [function() {

    return {
        restrict: 'E',
        templateUrl: 'directives/logz-severity/logz-severity.html',
        scope: {
            severity: '=',
            allowTrigger: '=',
            showText: '='
        },
        link: function(scope) {
            scope.options = [ 'HIGH', 'MEDIUM', 'LOW' ];

            scope.changeSeverity = function (severity) {
                scope.severity = scope.allowTrigger && scope.severity === severity
                    ? null
                    : severity;
            };
        }
    };
}]);
/* origin: public/webapp/directives/logz-svg.js */
angular.module('webApp').directive('logzSvg', [function () {
    var SVG_Elements = {
        setup: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 53.47 46"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path d="M4.86,29.65H.68a.68.68,0,0,1,0-1.37H4.86a.68.68,0,0,1,0,1.37Z"/><path d="M17,41.76A12.83,12.83,0,1,1,29.9,29,12.85,12.85,0,0,1,17,41.76Zm0-24.29A11.49,11.49,0,1,0,28.53,29,11.47,11.47,0,0,0,17,17.47Z"/><path d="M17,34a5,5,0,1,1,5-5A5,5,0,0,1,17,34Zm0-8.69a3.63,3.63,0,1,0,3.63,3.63A3.65,3.65,0,0,0,17,25.27Z"/><path d="M17,17.47a.65.65,0,0,1-.68-.68V12.62a.68.68,0,1,1,1.37,0v4.17A.74.74,0,0,1,17,17.47Z"/><path d="M33.38,29.65H29.21a.68.68,0,0,1,0-1.37h4.17a.65.65,0,0,1,.68.68A.69.69,0,0,1,33.38,29.65Z"/><path d="M17,46a.65.65,0,0,1-.68-.68V41.14a.68.68,0,0,1,1.37,0v4.17A.74.74,0,0,1,17,46Z"/><path d="M10.95,19.11a.82.82,0,0,1-.62-.34L8.21,15.15a.7.7,0,1,1,1.23-.68l2.12,3.63a.69.69,0,0,1-.27,1A3,3,0,0,0,10.95,19.11Z"/><path d="M27.57,23.56a.82.82,0,0,1-.62-.34.69.69,0,0,1,.27-1l3.63-2.12a.7.7,0,1,1,.68,1.23l-3.63,2.12A3,3,0,0,0,27.57,23.56Z"/><path d="M25.17,43.74a.82.82,0,0,1-.62-.34l-2.12-3.63a.7.7,0,0,1,1.23-.68l2.12,3.63a.69.69,0,0,1-.27,1A.51.51,0,0,1,25.17,43.74Z"/><path d="M2.87,37.79a.82.82,0,0,1-.62-.34.69.69,0,0,1,.27-1l3.63-2.12a.7.7,0,0,1,.68,1.23L3.22,37.72A.62.62,0,0,1,2.87,37.79Z"/><path d="M6.5,23.56a.62.62,0,0,1-.34-.07L2.53,21.37a.76.76,0,0,1-.27-1,.76.76,0,0,1,1-.27l3.63,2.12a.76.76,0,0,1,.27,1A1,1,0,0,1,6.5,23.56Z"/><path d="M23.05,19a.62.62,0,0,1-.34-.07.76.76,0,0,1-.27-1l2.12-3.63a.7.7,0,1,1,1.23.68L23.67,18.7A.6.6,0,0,1,23.05,19Z"/><path d="M31.19,37.79a.62.62,0,0,1-.34-.07L27.23,35.6a.7.7,0,0,1,.68-1.23l3.63,2.12a.76.76,0,0,1,.27,1A.82.82,0,0,1,31.19,37.79Z"/><path d="M8.89,43.81a.62.62,0,0,1-.34-.07.76.76,0,0,1-.27-1l2.12-3.63a.7.7,0,1,1,1.23.68L9.44,43.47A.7.7,0,0,1,8.89,43.81Z"/><path d="M40.74,22.38a10.21,10.21,0,0,1-1.44-.14,9.65,9.65,0,0,1-6.43-3.76,9.49,9.49,0,0,1-1.78-7.25A9.78,9.78,0,0,1,40.74,3a10.21,10.21,0,0,1,1.44.14,9.7,9.7,0,0,1,6.36,3.83,9.49,9.49,0,0,1,1.78,7.25A9.71,9.71,0,0,1,40.74,22.38Zm0-18.06a8.44,8.44,0,0,0-8.28,7.11A8.14,8.14,0,0,0,34,17.66a8.35,8.35,0,0,0,5.47,3.28,7.44,7.44,0,0,0,1.23.07A8.44,8.44,0,0,0,49,13.9a8.14,8.14,0,0,0-1.57-6.23A8.35,8.35,0,0,0,42,4.39,7.44,7.44,0,0,0,40.74,4.32Z"/><path d="M40.74,16.57a1.33,1.33,0,0,1-.55-.07A3.77,3.77,0,0,1,37.66,15a3.92,3.92,0,0,1-.75-2.87,4,4,0,0,1,4.45-3.28,3.92,3.92,0,0,1,3.28,4.45A4,4,0,0,1,40.74,16.57Zm0-6.43a2.63,2.63,0,0,0-2.53,2.19,2.45,2.45,0,0,0,.48,1.85,2.82,2.82,0,0,0,1.64,1,2.53,2.53,0,0,0,.75-5A.51.51,0,0,0,40.74,10.14Z"/><path d="M42,4.39H42a.68.68,0,0,1-.55-.75L41.9.56a.66.66,0,0,1,1.3.21l-.48,3.08A.68.68,0,0,1,42,4.39Z"/><path d="M52.78,15.13h-.07l-3.08-.48a.66.66,0,1,1,.21-1.3l3.08.48a.68.68,0,0,1,.55.75A.67.67,0,0,1,52.78,15.13Z"/><path d="M39,25.39h-.07a.68.68,0,0,1-.55-.75l.48-3.08a.66.66,0,0,1,1.3.21l-.48,3.08A.74.74,0,0,1,39,25.39Z"/><path d="M31.78,12h-.07l-3.08-.48a.66.66,0,0,1,.21-1.3l3.08.48a.68.68,0,0,1,.55.75A.67.67,0,0,1,31.78,12Z"/><path d="M37.39,4.94a.6.6,0,0,1-.62-.41L35.61,1.58A.66.66,0,0,1,36,.69a.66.66,0,0,1,.89.41L38.07,4a.66.66,0,0,1-.41.89C37.59,4.94,37.52,4.94,37.39,4.94Z"/><path d="M49.15,10a.6.6,0,0,1-.62-.41.66.66,0,0,1,.41-.89l2.87-1.16a.69.69,0,0,1,.48,1.3L49.43,10Z"/><path d="M45.19,24.71a.6.6,0,0,1-.62-.41l-1.16-2.87a.69.69,0,0,1,1.3-.48l1.16,2.87a.66.66,0,0,1-.41.89C45.39,24.64,45.32,24.71,45.19,24.71Z"/><path d="M29.38,17.8a.6.6,0,0,1-.62-.41.66.66,0,0,1,.41-.89l2.87-1.16a.69.69,0,1,1,.48,1.3L29.66,17.8Z"/><path d="M33.63,7.74a1,1,0,0,1-.41-.14L30.75,5.69a.74.74,0,0,1-.14-1,.74.74,0,0,1,1-.14L34,6.51a.74.74,0,0,1,.14,1A.84.84,0,0,1,33.63,7.74Z"/><path d="M46.35,6.24a1,1,0,0,1-.41-.14.74.74,0,0,1-.14-1l1.92-2.46a.74.74,0,0,1,1-.14.74.74,0,0,1,.14,1L46.9,6A.62.62,0,0,1,46.35,6.24Z"/><path d="M50.25,20.94a1,1,0,0,1-.41-.14l-2.46-1.92a.68.68,0,0,1,.82-1.09l2.46,1.92a.74.74,0,0,1,.14,1A.84.84,0,0,1,50.25,20.94Z"/><path d="M33.15,22.93a1,1,0,0,1-.41-.14.74.74,0,0,1-.14-1l1.92-2.46a.68.68,0,1,1,1.09.82l-1.92,2.46A.84.84,0,0,1,33.15,22.93Z"/></g></g></svg>',
        parse: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 41.45 33.25"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><rect x="11.54" y="0.78" width="16.56" height="5.85"/><rect x="11.54" y="11.37" width="8.21" height="5.85"/><rect x="11.54" y="21.96" width="29.21" height="5.85"/><line x1="10.84" y1="32.47" x2="41.37" y2="32.47"/><path d="M3.22,29.25a4,4,0,0,0,4,4v-1.6a2.41,2.41,0,0,1-2.4-2.4V4a2.41,2.41,0,0,1,2.4-2.4V0a4,4,0,0,0-4,4V15.83H0v1.6H3.22Z"/></g></g></svg>',
        enrich: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 35.15 35"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path d="M18.43,34.55V26.92a5,5,0,0,0,0-9.94V0H16.77V17a5,5,0,0,0,0,9.94v7.63Zm-4.17-12.6a3.36,3.36,0,1,1,3.36,3.36A3.36,3.36,0,0,1,14.26,21.94ZM4.17,18.28V34.15H5.82V18.28a5,5,0,0,0,0-9.94V0H4.17V8.34a5,5,0,0,0,0,9.94ZM5,10a3.36,3.36,0,1,1-3.36,3.36A3.36,3.36,0,0,1,5,10ZM31,35V18.28a5,5,0,0,0,0-9.94V.45H29.33V8.34a5,5,0,0,0,0,9.94V35ZM26.76,13.31a3.36,3.36,0,1,1,3.36,3.36A3.36,3.36,0,0,1,26.76,13.31Z"/></g></g></svg>',
        validate: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 47.32 45"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path d="M38.27,45,23.65,37.31,9,45l2.8-16.28L0,17.19l16.35-2.38L23.66,0,31,14.81l16.35,2.38L35.48,28.72ZM23.65,35.43,36.06,42,33.69,28.14l10-9.78-13.84-2L23.65,3.76,17.41,16.33l-13.84,2,10,9.78L11.24,42Z"/><path d="M23,30.5a1.08,1.08,0,0,1-.76-.32l-4-4a1.08,1.08,0,0,1,1.53-1.53L23,27.89,29,21.82a1.08,1.08,0,0,1,1.53,1.53h0l-6.84,6.84A1.08,1.08,0,0,1,23,30.5Z"/></g></g></svg>',
        arrow_down: '<svg class="arrow-down-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12.05 7.34"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><polyline points="0.85 0.85 6.13 6.13 11.2 0.85"/></g></g></svg>',
        paging_arrow: '<svg class="paging-arrow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16.13 13.15"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><line x1="12.27" y1="6.57" x2="0.9" y2="6.57"/><polyline points="7.1 0.9 14.63 6.69 7.1 12.25"/></g></g></svg>',
        list_open_arrow: '<svg class="list-open-arrow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 7.35 9.51"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><polyline points="1 1 5.74 4.83 1 8.51"/></g></g></svg>',
        data_menu: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 21.53 21"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><rect x="7.99" y="10.32" width="12.74" height="4.36"/><line x1="7.53" y1="18.65" x2="21.53" y2="18.65"/><path d="M2.4,17.7A3.3,3.3,0,0,0,5.7,21V19.68a2,2,0,0,1-2-2V3.3a2,2,0,0,1,2-2V0A3.3,3.3,0,0,0,2.4,3.3V9.84H0v1.82H2.4Z"/><path d="M14.43,2.88v3h-6v-3h6m1-1h-8v5h8v-5Z"/></g></g></svg>',
        question_mark_circled: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.6994 13.9"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="cls-1" d="M6.85,0a6.9507,6.9507,0,0,0,0,13.9A6.9507,6.9507,0,0,0,6.85,0Zm0,13.0313A6.0819,6.0819,0,0,1,6.85.8688a6.0819,6.0819,0,0,1,0,12.1625Z"/><path class="cls-1" d="M6.9764,2.7245A2.4849,2.4849,0,0,0,4.3731,5.4918h1.24c0-1.0062.3719-1.7191,1.3224-1.7191A1.1575,1.1575,0,0,1,8.0511,4.9886c0,.7548-.4546,1.0063-.9505,1.4257a2.6,2.6,0,0,0-.9091,2.3481H7.5139a1.8853,1.8853,0,0,1,.9505-1.9707A2.21,2.21,0,0,0,9.4778,5.2769,2.3286,2.3286,0,0,0,7.232,2.7328c-.087-.0055-.1724-.0083-.2556-.0083Zm.8,6.8556H6.1647v1.6354H7.7764V9.58Z"/></g></g></svg>',
        question_mark_circled_active: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.6993 13.9"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="cls-1" d="M6.85,0a6.9507,6.9507,0,0,0,0,13.9A6.9507,6.9507,0,0,0,6.85,0Zm.9266,11.2154H6.1648V9.58H7.7764ZM9.4778,5.2768A2.21,2.21,0,0,1,8.4644,6.7917a1.8854,1.8854,0,0,0-.95,1.9708H6.1914a2.6,2.6,0,0,1,.9092-2.3481c.4958-.4193.95-.6709.95-1.4257A1.1574,1.1574,0,0,0,6.9353,3.7727c-.95,0-1.3225.7128-1.3225,1.7191H4.373A2.5053,2.5053,0,0,1,7.2319,2.7327,2.3285,2.3285,0,0,1,9.4778,5.2768Z"/></g></g></svg>',
        exclamation_mark_circled: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.6994 13.8999"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="cls-1" d="M6.85,0a6.9507,6.9507,0,0,0,0,13.9A6.9507,6.9507,0,0,0,6.85,0Zm0,13.0313A6.0819,6.0819,0,0,1,6.85.8687a6.0819,6.0819,0,0,1,0,12.1626Z"/><polygon class="cls-1" points="7.221 8.328 6.429 8.328 5.831 4.601 5.831 2.328 7.831 2.328 7.831 4.663 7.221 8.328"/><rect class="cls-1" x="5.8307" y="9.3285" width="2" height="2"/></g></g></svg>',
        exclamation_mark_circled_active: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.6993 13.9"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="cls-1" d="M6.85,0a6.9507,6.9507,0,0,0,0,13.9A6.9507,6.9507,0,0,0,6.85,0Zm.981,11.3286h-2v-2h2Zm0-6.6653L7.2212,8.3286h-.792L5.8306,4.6013V2.3286h2Z"/></g></g></svg>',
        sort_ascending: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 10.5"><defs><style>.sort-ascending-svg{fill:none;stroke:#919498;stroke-width:1.5px;}</style></defs><title>ascending</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><line class="sort-ascending-svg" x1="3.9991" y1="5.25" x2="14" y2="5.25"/><line class="sort-ascending-svg" x1="8.9991" y1="0.75" x2="14" y2="0.75"/><line class="sort-ascending-svg" y1="9.75" x2="14" y2="9.75"/></g></g></svg>',
        sort_descending: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 10.5"><defs><style>.sort-descending-svg{fill:none;stroke:#919498;stroke-width:1.5px;}</style></defs><title>descending</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><line class="sort-descending-svg" x1="3.9991" y1="5.25" x2="14" y2="5.25"/><line class="sort-descending-svg" x1="8.9991" y1="9.75" x2="14" y2="9.75"/><line class="sort-descending-svg" y1="0.75" x2="14" y2="0.75"/></g></g></svg>',
        arrow_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 7.8361 13.2827"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path d="M.75,13.2827a.75.75,0,0,1-.53-1.28L5.6916,6.53.2306,1.292A.75.75,0,0,1,1.27.209L7.8361,6.5074,1.28,13.063A.7467.7467,0,0,1,.75,13.2827Z"/></g></g></svg>',
        cmd_key: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 17"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="cls-1" d="M13.71,17a3.29,3.29,0,0,1-3.29-3.29V11.79H6.58v1.92a3.29,3.29,0,1,1-3.29-3.29H5.21V6.58H3.29A3.29,3.29,0,1,1,6.58,3.29V5.21h3.84V3.29a3.29,3.29,0,1,1,3.29,3.29H11.79v3.84h1.92a3.29,3.29,0,0,1,0,6.58Zm-1.92-5.21v1.92a1.92,1.92,0,1,0,1.92-1.92Zm-8.5,0a1.92,1.92,0,1,0,1.92,1.92V11.79Zm3.29-1.37h3.84V6.58H6.58Zm5.21-5.21h1.92a1.92,1.92,0,1,0-1.92-1.92ZM3.29,1.37a1.92,1.92,0,1,0,0,3.84H5.21V3.29A1.92,1.92,0,0,0,3.29,1.37Z"/></g></g></svg>',
        dots: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.67 4"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="cls-1" d="M7.83,2a2,2,0,1,1,2,2A2,2,0,0,1,7.83,2Zm7.83,0a2,2,0,0,1,2-2,2,2,0,0,1,2,2,2,2,0,0,1-4,0ZM0,2A2,2,0,0,1,2,0,2,2,0,0,1,4,2,2,2,0,0,1,0,2Z"/></g></g></svg>',
        arrow: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.42 11.1"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><polyline class="cls-1" points="17.62 0.8 9.03 10.3 0.8 0.8"/></g></g></svg>',
        play: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.78 17.39"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="cls-1" d="M15,8.77.75.75V16.64Z"/></g></g></svg>',
        stop: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.38 14.46"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="cls-1" d="M14.63.75H.75v13H14.63Z"/></g></g></svg>',
        clear: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24.01 19"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="cls-1" d="M11.67,19H9.33a2.48,2.48,0,0,1-1.77-.73l-3-3a2.5,2.5,0,0,1,0-3.54L16.15.14a.51.51,0,0,1,.71,0l7,7a.5.5,0,0,1,0,.71L13.44,18.27A2.48,2.48,0,0,1,11.67,19ZM16.51,1.2,5.27,12.44a1.5,1.5,0,0,0,0,2.12l3,3A1.49,1.49,0,0,0,9.33,18h2.34a1.49,1.49,0,0,0,1.06-.44L22.8,7.5Z"/><path class="cls-1" d="M15.5,16a.5.5,0,0,1-.35-.15l-7-7a.5.5,0,0,1,.71-.71l7,7a.5.5,0,0,1-.35.85Z"/><path class="cls-1" d="M5.5,19H.5a.5.5,0,0,1,0-1h5a.5.5,0,0,1,0,1Z"/></g></g></svg>',
        scroll: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.63 26"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="cls-1" d="M1.06,5.81h0v6.87a4.76,4.76,0,1,0,9.51,0V5.81a4.76,4.76,0,1,0-9.51,0ZM0,5.81a5.81,5.81,0,1,1,11.63,0v6.87A5.81,5.81,0,1,1,0,12.68V5.81Z"/><path class="cls-1" d="M5.28,4.23a.53.53,0,1,1,1.06,0V6.34a.53.53,0,1,1-1.06,0Z"/><path class="cls-1" d="M5.81,24.72l3.91-3.91a.53.53,0,0,1,.75.75L6.19,25.85a.53.53,0,0,1-.75,0L1.14,21.55a.53.53,0,0,1,.75-.75Z"/></g></g></svg>',
        x: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8.98 8.95"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><line class="xcls-1" x1="8.25" y1="8.23" x2="0.73" y2="0.73"/><line class="xcls-1" x1="0.73" y1="8.23" x2="8.25" y2="0.73"/></g></g></svg>',
        search_remove: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10.95 11.22"><title>x close</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><line x1="10.15" y1="10.42" x2="0.8" y2="0.8"/><line x1="0.8" y1="10.42" x2="10.15" y2="0.8"/></g></g></svg>',
        search_magnifying_glass: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.0008 19.0008"><title>magnify_new</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><g id="a"><path d="M19.0008,18.2508a.7342.7342,0,0,0-.225-.5375l-4.1877-4.1877A7.6345,7.6345,0,0,0,16.3007,10.1v-.0125a8.3942,8.3942,0,0,0,.2-1.8376A7.9733,7.9733,0,0,0,14.0756,2.4,7.9341,7.9341,0,0,0,8.25,0,8.0211,8.0211,0,0,0,2.4,2.4,8.0211,8.0211,0,0,0,0,8.25a7.9341,7.9341,0,0,0,2.4,5.8252,7.9733,7.9733,0,0,0,5.85,2.4251,7.8466,7.8466,0,0,0,5.2752-1.9126l4.1877,4.1877a.7342.7342,0,0,0,.5375.225.769.769,0,0,0,.75-.75M13.013,3.4626A6.5253,6.5253,0,0,1,15.0006,8.25a6.8948,6.8948,0,0,1-.1625,1.5251,6.3949,6.3949,0,0,1-1.8126,3.2251l-.025.025a6.4469,6.4469,0,0,1-4.75,1.9751A6.5253,6.5253,0,0,1,3.4626,13.013,6.4823,6.4823,0,0,1,1.5,8.25,6.5611,6.5611,0,0,1,3.4626,3.4626,6.5611,6.5611,0,0,1,8.25,1.5,6.4823,6.4823,0,0,1,13.013,3.4626Z"/></g></g></g></svg>',
        search_arrow_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.1814 14.4576"><title>nina</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><polyline class="cls-3" points="10.664 13.691 17.099 7.093 10.664 0.767"/><line class="cls-3" x1="15.9165" y1="7.2288" x2="0.767" y2="7.2288"/></g></g></svg>',
        x_tag_square: '<svg class="x-tag-square" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><rect width="16" height="16"/><line x1="11.07" y1="11.1" x2="4.93" y2="4.9"/><line x1="4.93" y1="11.1" x2="11.07" y2="4.9"/></g></g></svg>',
        toast_error: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26"><defs><style>.toast_failure_svg{fill:#cb5d54;}</style></defs><title>failure</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="toast_failure_svg" d="M13,0A13,13,0,1,0,26,13,13,13,0,0,0,13,0Zm1.5,20.5h-3v-3h3Zm0-10.4968L13.5858,14.5h-1.188L11.5,9.91V5.5h3Z"/></g></g></svg>',
        toast_success: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26"><defs><style>.toast_success_svg{fill:#70b670;}</style></defs><title>succcess</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="toast_success_svg" d="M13,0A13,13,0,1,0,26,13,13,13,0,0,0,13,0Zm7.1709,9.2375h0l-9.5,9.4678L5.8292,13.8643a.6224.6224,0,0,1,0-.88h0l.88-.88a.6225.6225,0,0,1,.88,0l3.0812,3.0807,7.74-7.7073a.6223.6223,0,0,1,.88,0l.88.88A.6223.6223,0,0,1,20.1709,9.2375Z"/></g></g></svg>',
        x_tag: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10.95 11.22"><defs><style>.cls-tag-x{fill:none;stroke:#ffffff;stroke-linecap:round;stroke-width:1.6px;}</style></defs><title>x close</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><line class="cls-tag-x" x1="10.15" y1="10.42" x2="0.8" y2="0.8"/><line class="cls-tag-x" x1="0.8" y1="10.42" x2="10.15" y2="0.8"/></g></g></svg>',
        pencil: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.9814 14.0015"><defs><style>.cls-1{fill:#cacbcc;}</style></defs><title>edit_3</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="cls-1" d="M0,14.0015,1.792,8.6646,10.3813,0l.228.0659a5.0072,5.0072,0,0,1,3.3184,3.3823l.0537.2168-8.6763,8.74ZM2.4268,9.1606,1.2373,12.7935l3.7393-1.1245,8.1157-8.2407A4.2056,4.2056,0,0,0,10.604.9121Z"/><rect class="cls-1" x="3.2422" y="8.1388" width="0.8003" height="4.4391" transform="translate(-6.2447 5.5825) rotate(-44.844)"/><polygon class="cls-1" points="3.981 10.692 3.411 10.132 10.33 3.092 9.496 1.264 10.224 0.932 11.286 3.261 3.981 10.692"/><rect class="cls-1" x="11.4095" y="2.4398" width="0.7997" height="2.3977" transform="translate(3.2857 12.5856) rotate(-63.5132)"/></g></g></svg>',
        download: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13 15.6197"><defs><style>.logz-svg-download{fill:none;stroke:white;stroke-linecap:square;stroke-width:1.6px;}</style></defs><title>download</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><polyline class="logz-svg-download" points="3.052 6.939 6.572 10.8 9.948 6.939"/><line class="logz-svg-download" x1="6.5" y1="10.3281" x2="6.5" y2="0.8"/><line class="logz-svg-download" x1="12.2" y1="14.8197" x2="0.8" y2="14.8197"/></g></g></svg>'
    };

    return {
        restrict: 'E',
        transclude: true,
        required: 'svgName',
        scope: {
            svgName: '@'
        },
        link: function (scope, element) {
            // $watch - Support for changing the svg on runtime
            scope.$watch('svgName', function() {
                element.html(SVG_Elements[scope.svgName]);
            });
        }
    };
}]);

/* origin: public/webapp/directives/logz-switch/logz-switch.js */
angular.module('webApp').directive('logzSwitch', [function() {

    var html = '<div class="logz-switch" ng-class="{\'on\':isOn}" ng-click=\"toggle()\">' +
        '<label><span></span></label>' +
        '</div>';

    return {
        restrict: 'E',
        template: html,
        require: 'ngModel',
        scope: {
            stateUpdate: '&'
        },
        link: function(scope, element, attrs, model) {

            model.$formatters.unshift(function(value) {
                scope.isOn = value === true;
                return value;
            });

            scope.toggle = function() {
                var continueSwitchLogic = scope.stateUpdate({ enabled: !scope.isOn });
                if (continueSwitchLogic === false) // Make sure it isn't undefined and that value is false
                    return;

                scope.isOn = !scope.isOn;
                model.$setViewValue(scope.isOn);
            };

        }
    };
}]);
/* origin: public/webapp/directives/logz-user-token.js */
angular.module('webApp').directive('logzUserToken', function($window, $rootScope, Backend, AuthService, UserTokensService) {

    // todo: separate this into html template file!
    var html = '<div class="user-token-control clearfix" ng-class="{\'readonly\':token.id}">' +
        '<input type="text" ng-model="token.name" class="token-name" ng-class="{\'readonly\':token.id}" placeholder="token name" ng-disabled="token.id" />' +
        '<span class="token" ng-class="{\'empty\':!token.token}" ng-bind="token.token"></span>' +
        '<span class="attach-filter link small" ng-class="" ng-show="token.id" ng-click="openAttachFiltersSection()">Attach Filter</span>' +
        '<span class="pull-right delete" ng-if="token.id" ng-click="deleteToken()"><i class="fa fa-close"></i></span>' +
        '<span class="button-link create-token" ng-class="{\'disabled\':!token.name}" ng-show="!token.id" ng-click="saveToken()">Save</span>' +

        '<div class="filters">' +
            '<span class="attached-filter" ng-repeat="attachedFilter in token.filters">' +
                '{{attachedFilter.description.value}}' +
                '<span class="delete-attached-filter" ng-click="removeAttachedFilter(attachedFilter.id)">X</span>' +
            '</span>' +
        '</div>' +
        '<div class="new-filters" ng-show="attachingFilters">' +
            '<select ng-model="chosenFilter" style="margin-right:10px; display:inline-block;">' +
                '<option ng-repeat="queryFilter in queryFilters" ng-value="queryFilter.id" ng-if="shouldShowFilter(queryFilter.id)">{{queryFilter.description.value}}</option>' +
            '</select>' +
            '<span class="link small" style="margin-right:10px; display:inline-block;" ng-click="saveAttachedFilter()">Save</span>' +
            '<span class="link small" style="margin-right:10px; display:inline-block;" ng-click="cancelAttachedFilter()">Cancel</span>' +
        '</div>' +

        '</div>';

    return {
        restrict: 'E',
        scope: {
            chosenFilter: '=?',
            token: '=?',
            readonly: '=?'
        },
        template: html,
        link: function(scope) {
            if (!scope.token)
                scope.token = {};
            scope.attachingFilters = false;

            AuthService.getUser().then(function(userData) {
                scope.token.accountId = userData.data.accountId;
            });

            UserTokensService.getQueryFilters().then(function(queryFilters) {
                scope.queryFilters = queryFilters;
            });

            scope.shouldShowFilter = function (queryFilterId) {
                return _.findIndex(scope.token.filters, function (filter) { return filter.id === queryFilterId; }) === -1;
            };

            scope.deleteToken = function() {
                if (!window.confirm('Are you sure you want to delete this token?'))
                    return;

                Backend.DELETE('/user-token/' + scope.token.id).then(function() {
                    $rootScope.$broadcast('user-token-update');
                    $window.postMessage({
                        message: '__kibana-tokens-update',
                    }, '*');
                });
            };

            scope.saveToken = function() {
                if (scope.readonly)
                    return;
                if (!scope.token.name || scope.token.name.trim() === '')
                    return;

                Backend.POST('/user-tokens', {
                    name: scope.token.name,
                    accountId: scope.token.accountId
                }).then(function(savedToken) {
                    scope.token = savedToken.data;
                    scope.readonly = true;
                    $rootScope.$broadcast('user-token-update');
                    $window.postMessage({
                        message: '__kibana-tokens-update',
                    }, '*');
                });
            };

            scope.openAttachFiltersSection = function() {
                scope.attachingFilters = true;
            };

            scope.saveAttachedFilter = function() {
                Backend.POST('/user-tokens/add-filter', {
                    filterId: parseInt(scope.chosenFilter),
                    userTokenId: scope.token.id
                }).then(function() {
                    $rootScope.$broadcast('user-token-update');
                    scope.attachingFilters = false;
                });
            };
            scope.cancelAttachedFilter = function() {
                scope.attachingFilters = false;
            };

            scope.removeAttachedFilter = function(filterId) {
                if (!$window.confirm('Are you sure you want to remove this filter from the user token ?'))
                    return;

                Backend.POST('/user-tokens/remove-filter', {
                    filterId: filterId,
                    userTokenId: scope.token.id
                }).then(function() {
                    UserTokensService.clearCache();
                    $rootScope.$broadcast('user-token-update');
                });
            };
        }
    };
});
/* origin: public/webapp/directives/logz-vote/logz-vote.js */
angular.module('webApp').directive('logzVote', function($rootScope, ngDialog, Backend, AuthService) {

    var likeHtml = '<span class="logz-vote" ng-click="addLike()" ng-class="{\'voted\':upVoted, \'preview\':previewMode}">' +
                        '<span class="like-img" ng-class="{\'liked\':upVoted, \'not-liked\':!upVoted}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 21.41 18.25"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path d="M17.77,18.25H5V6.49h.46a2.59,2.59,0,0,0,1.82-.68,33.13,33.13,0,0,0,3.19-3.74c.5-.64.91-1.18,1.23-1.55l0,0a2.32,2.32,0,0,1,2.82,0c.82.68.27,2.14.14,2.41l-.77,3.05c0,.27.14.55.23.55h5.19a1.94,1.94,0,0,1,2.05,1.82,1.82,1.82,0,0,1-.68,1.37,1.7,1.7,0,0,1-.23,2.87,1.65,1.65,0,0,1,.5,1.18,1.84,1.84,0,0,1-1.5,1.73,1.72,1.72,0,0,1,.32,1A1.94,1.94,0,0,1,17.77,18.25ZM5.92,17.34H17.77a1,1,0,0,0,1.14-.91,1,1,0,0,0-1.14-.91V14.6H19a1,1,0,0,0,1.14-.91A1,1,0,0,0,19,12.78v-.91h.41A1,1,0,0,0,20.5,11,1,1,0,0,0,19.36,10V9.14a1,1,0,0,0,1.14-.91,1,1,0,0,0-1.14-.91H14.17c-.82,0-1.09-.91-1.14-1.5V5.72l.87-3.14c.18-.46.36-1.18.14-1.37a1.37,1.37,0,0,0-1.64,0c-.32.36-.73.87-1.18,1.5A30.33,30.33,0,0,1,7.88,6.54a3.49,3.49,0,0,1-2,.87Z"/><path d="M5.92,18.25H0V6.49H5.92Zm-5-.91H5V7.4H.91Z"/></g></g></svg></span>' +
                        '<span class="vote-count" ng-bind-template="{{countLikes || 0}}"></span>' +
                    '</span>';

    return {
        restrict: 'E',
        template: likeHtml,
        scope: {
            objectId: '=',
            upVoted: '=?',
            countLikes: '=',
            previewMode: '=?'
        },
        link: function(scope) {
            scope.addLike = function() {
                if (scope.previewMode) return;

                if (!AuthService.isAuthenticated()) {
                    ngDialog.open({
                        template: 'app/outer/register/registration-dialog.html',
                        controller: 'RegistrationDialogController',
                        width: '586px',
                        closeByEscape: true,
                        showClose: false
                    });

                    return;
                }

                $rootScope.$emit('Labs_VoteInteraction');

                scope.upVoted = !scope.upVoted;
                if (scope.upVoted) scope.countLikes++;
                else scope.countLikes--;
                Backend.POST('/labs/vote', { id: scope.objectId, enabled: scope.upVoted });
            };
        }
    };
});
/* origin: public/webapp/directives/logzio-grouped-multiselect/logzio-grouped-multiselect.js */
/* eslint-disable max-lines */
angular.module('webApp').directive('logzioGroupedMultiselect', function ($document, $filter, $timeout) {
    var EMAIL_REGEX = /^[_A-Za-z0-9-\+]+(\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\.[A-Za-z0-9]+)*(\.[A-Za-z]{2,})$/;

    return {
        restrict: 'EA',
        scope: {
            suggestionsGroups: '=?',
            modelArr: '=ngModel',
            loadingRecipients: '=?',
            inputPlaceholder: '@',
            emailInputCallback: '=?',
            errorMessage: '=?',
            disableRequire: '@?',
            multiselectApi: '=?'
        },
        templateUrl: 'directives/logzio-grouped-multiselect/logzio-grouped-multiselect.html',
        link: function (scope, element, attr) {

            scope.multiselectApi = scope.multiselectApi || {};
            scope.api = {
                elementRemoved: scope.multiselectApi.elementRemoved || function () {},
                elementAddedCallback: scope.multiselectApi.elementAddedCallback || function () {},
            };

            scope.selectedItemIndex = 0;
            scope.selectedGroupIndex = 0;
            scope.isHover = false;
            scope.isFocused = false;
            scope.inDeleteMode = false;
            scope.isError = false;
            scope.inputValue = '';
            scope.validInput = true;

            scope.modelArr = _.isArray(scope.modelArr) ? scope.modelArr : [];
            scope.emailInputCallback = scope.emailInputCallback || function () { };

            var selectedOrderedItem;
            var keys = {
                38: 'up',
                40: 'down',
                8: 'backspace',
                13: 'enter',
                9: 'tab',
                27: 'esc',
                188: 'comma',
                32: 'space',
                186: 'semiColon'
            };
            var suggestionElementHeight = 34;
            var emailGroup = false;

            var inputElement = element.find('input');
            var goWithInput = attr['goWithInput'] !== undefined;

            scope.onFocus = function () {
                scope.isFocused = true;
                scope.validInput = true;
            };
            scope.onMouseEnter = function () {
                scope.isHover = true;
            };
            scope.onMouseLeave = function () {
                scope.isHover = false;
            };
            scope.onBlur = function () {
                scope.isFocused = false;
                scope.inDeleteMode = false;
                if (emailGroup && isValidMailInput() && scope.isNotAddedValue({name: scope.inputValue})) {
                    addEmailToModelArr();
                }
                else {
                    scope.validInput = false;
                }
            };
            scope.focusOnInput = function () {
                inputElement.focus();
            };

            scope.onChange = function () {
                var filteredSuggestionArr = getFilteredSuggestionArr();
                if (!filteredSuggestionArr || !filteredSuggestionArr.length) return;
                scope.selectedItemIndex = filteredSuggestionArr[0].id;
                scope.selectedGroupIndex = filteredSuggestionArr[0].group;
                //TODO if the selected item is filtered - select the next item
            };


            function getFilteredSuggestionArr() {
                var filteredSuggestionArr = _.flatten(_.map(scope.suggestionsGroups, function (collection) {
                    return collection.data;
                }));
                filteredSuggestionArr = $filter('filter')(filteredSuggestionArr, {name: scope.inputValue});
                filteredSuggestionArr = $filter('filter')(filteredSuggestionArr, scope.isNotAddedValue);

                var itemCounter = 0, lastItem = {};
                _.forEach(filteredSuggestionArr, function (item, itemIndex) {
                    itemCounter = lastItem.group === item.group ? itemCounter : 0;
                    item.relativeOrderId = itemCounter;
                    item.orderId = itemIndex;
                    lastItem = item;
                    itemCounter++;
                });
                return filteredSuggestionArr;
            }

            function getSelectedOrderedItem(filteredSuggestionArr) {
                return _.find(filteredSuggestionArr, {
                    id: scope.selectedItemIndex,
                    group: scope.selectedGroupIndex
                });
            }

            function markTheNextItem(filteredSuggestionArr) {
                selectedOrderedItem = getSelectedOrderedItem(filteredSuggestionArr);
                //found an item and it is not the last
                if (selectedOrderedItem && selectedOrderedItem.orderId < filteredSuggestionArr.length - 1) {
                    markItemFromSuggestion(filteredSuggestionArr[selectedOrderedItem.orderId + 1]);
                }
                //nothing selected and there are some filtered items
                else if (!selectedOrderedItem && filteredSuggestionArr.length) {
                    markItemFromSuggestion(filteredSuggestionArr[0]);
                }
                //we are at the last item - go to the start
                else if (selectedOrderedItem && selectedOrderedItem.orderId === filteredSuggestionArr.length - 1) {
                    markItemFromSuggestion(filteredSuggestionArr[0]);
                }
                //TODO Scroll to the next item if is hidden
            }

            function markThePreviousItem(filteredSuggestionArr) {
                selectedOrderedItem = getSelectedOrderedItem(filteredSuggestionArr);
                //found an item and it is not the first one
                if (selectedOrderedItem && selectedOrderedItem.orderId > 0) {
                    markItemFromSuggestion(filteredSuggestionArr[selectedOrderedItem.orderId - 1]);
                }
                //didnt find any item and there are more items
                else if (!selectedOrderedItem && filteredSuggestionArr.length) {
                    markItemFromSuggestion(filteredSuggestionArr[filteredSuggestionArr.length - 1]);
                }
                //this is the first item and there are more
                else if (selectedOrderedItem && selectedOrderedItem.orderId === 0 && filteredSuggestionArr.length) {
                    markItemFromSuggestion(filteredSuggestionArr[filteredSuggestionArr.length - 1]);
                }
            }

            function markItemFromSuggestion(item) {
                scope.selectedItemIndex = item.id;
                scope.selectedGroupIndex = item.group;
                scrollToItem(item);
            }

            scope.keyParser = function ($event) {
                var key = keys[$event.keyCode];
                var isKeyDivider = key === 'comma' || key === 'space' || key === 'semiColon';
                if (key === 'backspace' && scope.inputValue === '') { //TODO del key also deletes
                    if (scope.modelArr.length !== 0 && scope.inDeleteMode === true) {
                        scope.removeSelectedValue(scope.modelArr[scope.modelArr.length - 1]);
                    }
                    else {
                        scope.inDeleteMode = true;
                    }
                }
                else if (key === 'down') {
                    scope.isFocused = true;
                    scope.inDeleteMode = false;
                    markTheNextItem(getFilteredSuggestionArr());
                }
                else if (key === 'up') {
                    scope.isFocused = true;
                    scope.inDeleteMode = false;
                    markThePreviousItem(getFilteredSuggestionArr());
                }
                else if (key === 'esc') {
                    scope.isHover = false;
                    scope.isFocused = false;
                    scope.inDeleteMode = false;
                }
                else if (key === 'enter' || isKeyDivider) {
                    scope.inDeleteMode = false;
                    if (!scope.isFocused) {
                        scope.isFocused = true;
                        return;
                    }

                    var itemHasBeenAdded;
                    if (emailGroup && isValidMailInput() && scope.isNotAddedValue({name: scope.inputValue})) {
                        addEmailToModelArr();
                        itemHasBeenAdded = true;
                    }
                    else {
                        selectedOrderedItem = getSelectedOrderedItem(getFilteredSuggestionArr());
                        if (selectedOrderedItem && !isKeyDivider) {
                            scope.addSuggestedItems(selectedOrderedItem);
                            itemHasBeenAdded = true;
                        }
                    }

                    if (itemHasBeenAdded) {
                        scope.isFocused = false;
                    }
                    else {
                        scope.isError = true;
                    }
                }
                else {
                    scope.inDeleteMode = false;
                    scope.isFocused = true;
                    scope.isError = false;
                    scope.validInput = true;
                }
            };

            scope.addSuggestedItems = function (selectedValue) {
                scope.modelArr.push(selectedValue);
                //making sure that the input is empty, including while inserting emails with the dividers input
                $timeout(function () {
                    scope.inputValue = '';
                    var selectedElement = getItemElement(selectedValue);
                    scope.api.elementAddedCallback(selectedValue, selectedElement);
                });

                // markTheNextItem(getFilteredSuggestionArr()); //TODO fix that the next item is selected after one is selected
            };

            scope.isNotAddedValue = function (item) {
                return !_.some(scope.modelArr, item);
            };

            scope.multiselectApi.removeElement = scope.removeSelectedValue = function (item, $event) {
                if (typeof $event === 'object') {
                    $event.stopPropagation();
                }

                if (_.size(scope.modelArr) === 0) return;

                var itemIndex = _.findIndex(scope.modelArr, {id: item.id, group: item.group});
                if (itemIndex === -1) return;
                getItemElement(item).addClass('hide-item');// todo convert this into angular find

                $timeout(function () {
                    _.remove(scope.modelArr, {id: item.id, group: item.group});
                    scope.api.elementRemoved(item);
                    $timeout(recalculateInputPosition, 500);
                }, 300);
            };

            scope.mouseEnterOnItem = function (groupIndex, itemIndex) {
                scope.selectedItemIndex = itemIndex;
                scope.selectedGroupIndex = groupIndex;
            };

            scope.isFiltered = function (suggestion) {
                var filteredSuggestionArr = getFilteredSuggestionArr();

                return _.some(filteredSuggestionArr, {
                    group: suggestion.group,
                    id: suggestion.id
                });
            };

            scope.isSelected = function (item) {
                var filteredByInput = _.filter(scope.modelArr, {
                    group: item.group,
                    id: item.id
                });
                return filteredByInput.length;
            };

            scope.noResults = function (groupIndex) {
                var filteredSuggestionArr = getFilteredSuggestionArr();
                return !_.some(filteredSuggestionArr, {
                    group: groupIndex,
                });
            };

            var isValidMailInput = function () {
                return scope.inputValue && EMAIL_REGEX.test(scope.inputValue);
            };
            var addEmailToModelArr = function () {
                selectedOrderedItem = {
                    name: scope.inputValue,
                };
                emailGroup.data.push(selectedOrderedItem);
                sanitizeSuggestedItems();
                scope.emailInputCallback(scope.inputValue);
                scope.addSuggestedItems(selectedOrderedItem);
            };

            var sanitizeSuggestedItems = function () {
                _.forEach(scope.suggestionsGroups, function (group, groupIndex) {
                    group.id = groupIndex;
                    _.forEach(group.data, function (item, itemIndex) {
                        item.group = groupIndex;
                        item.id = itemIndex;
                    });
                });
            };

            var scrollToItem = function (item) {
                $(['#group', item.group].join('-')).animate({scrollTop: suggestionElementHeight * item.relativeOrderId}, 'fast');
            };

            var getItemElement = function (item) {
                return $(['#selected-item', item.id, 'group', item.group].join('-'));
            };

            scope.multiselectApi.changeElementName = function (item, newName) {
                item.name = newName;
            };

            scope.requiredOverride = function () {
                if (attr['disableRequire'] !== undefined) {
                    return false;
                }
                else {
                    return !scope.modelArr.length;
                }
            };

            scope.$watch('suggestionsGroups', function () {
                sanitizeSuggestedItems();
                emailGroup = _.find(scope.suggestionsGroups, {groupType: 'emails'});
            }, true);

            if (goWithInput) {
                var autocompleteListElement = element.find('.autocomplete-list');
                autocompleteListElement.addClass('go-with-input');
                var formItemContainer = element.find('.form-item-container');
                var inputPadding = 10; //todo get this programmatically
                scope.$watchCollection('[isFocused, isHover]', recalculateInputPosition);
            }

            function recalculateInputPosition() {
                if (!goWithInput) return;
                var inputPosition = inputElement[0].getBoundingClientRect();
                var formItemContainerPosition = formItemContainer[0].getBoundingClientRect();
                autocompleteListElement.css({
                    left: inputPosition.left - formItemContainerPosition.left + inputPadding,
                    top: inputPosition.height + inputPosition.top - formItemContainerPosition.top - inputPadding,
                    width: inputElement.width,
                });
            }
        }
    };
})
    .filter('highlight', function ($sce) {
        return function (text, phrase) {
            if (phrase) {
                text = text.replace(new RegExp('(' + phrase + ')', 'gi'), '<span class="highlighted">$1</span>');
            }
            return $sce.trustAsHtml(text);
        };
    });
/* eslint-enable max-lines */

/* origin: public/webapp/directives/logzio-password-change-panel/logzio-password-change-panel-controller.js */
angular.module('webApp').controller('LogzioPasswordChangePanelController', function ($q, $scope, Backend) {
    var vm = this;
    vm.username = $scope.username;
    vm.finishEditCallback = $scope.finishEditCallback;

    vm.password = { current: {}, new: {} };

    vm.updatePasswordValue = function (name, value) {
        vm.password[name].value = value;
        vm.password[name].error = false;
    };

    var currentPasswordValidation;
    vm.validateCurrentPassword = function () {
        if (!vm.password.current.value || vm.password.current.value.length < 6) {
            // We now require password length of 8 chars but we support old passwords with 6 chars
            vm.password.current.error = true;
            return;
        }

        var defer = $q.defer();
        currentPasswordValidation = defer.promise;

        Backend.POST('/auth', { username: vm.username, password: vm.password.current.value }).then(function () {
            vm.password.current.error = false;
        }).catch(function () {
            vm.password.current.error = true;
        }).finally(function () {
            defer.resolve(vm.password.current.error);
        });
    };

    vm.validateNewPassword = function () {
        vm.password.new.error = !vm.password.new.value || vm.password.new.value.length < 8;
    };

    var changingPassword = false;
    vm.changePassword = function () {
        if (changingPassword || !vm.password.current.value || !vm.password.new.value || vm.password.new.value.length < 8) {
            return;
        }

        changingPassword = true;
        currentPasswordValidation.then(function (error) {
            if (error) {
                return;
            }

            Backend.POST('/change-password', { currentPassword: vm.password.current.value, newPassword: vm.password.new.value }).then(function () {
                if (vm.finishEditCallback) {
                    vm.finishEditCallback();
                }
            }).catch(function () {
                vm.password.current.error = false;
            }).finally(function () {
                changingPassword = false;
            });
        });
    };
});

/* origin: public/webapp/directives/logzio-password-change-panel/logzio-password-change-panel.js */
angular.module('webApp').directive('logzioPasswordChangePanel', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/logzio-password-change-panel/logzio-password-change-panel.html',
        controller: 'LogzioPasswordChangePanelController',
        controllerAs: 'vm',
        scope: {
            username: '=',
            finishEditCallback: '&'
        }
    };
});
/* origin: public/webapp/directives/masonry/logz-masonry-brick.js */
angular.module('webApp').directive('logzMasonryBrick', [function() {
    return {
        restrict: 'E',
        templateUrl: 'directives/masonry/masonry-brick.html',
        scope: {
            model: '=ngModel'
        }
    };
}]);
/* origin: public/webapp/directives/masonry/logz-masonry.js */
angular.module('webApp').directive('logzMasonry', function($compile) {
    return {
        restrict: 'A',
        scope: {
            columnWidth: '=',
            bricks: '='
        },
        link: function(scope, element) {
            // first hide all the bricks
            element.find('.masonry-brick').hide();

            // calculate widths
            var totalWidth = element[0].clientWidth;
            var columnsCount = Math.floor(totalWidth / scope.columnWidth);

            // create columns
            var columns = [];
            for (var i=0; i<columnsCount; i++) {
                var col = angular.element('<div></div>').addClass('column').css('width', scope.columnWidth + 'px');
                if (i === columnsCount - 1)
                    col.addClass('last');
                columns.push(col);
                element.append(col);
            }

            var bricksWatcher = scope.$watch('bricks', function(newBricks, oldBricks) {
                // if it's empty, then empty the bricks
                if (!newBricks || !newBricks.length) {
                    _.forEach(columns, function(column) {
                        column.html('');
                    });
                }

                // add the new bricks we got
                _.forEach(newBricks, function(brickModel, i) {
                    if (_.findIndex(oldBricks, function(brick) { return brick.id === brickModel.id; }) < 0) {
                        var brick = $compile('<logz-masonry-brick ng-model="bricks['+i+']"></logz-masonry-brick>')(scope);
                        columns[i % columnsCount].append(brick);
                    }
                });
            });

            scope.$on('$destroy', function() {
                if (bricksWatcher && typeof bricksWatcher === 'function') bricksWatcher();
            });
        }
    };
});
/* origin: public/webapp/directives/multi-boxes/multi-boxes.js */
angular.module('webApp').directive('multiBoxes', [function() {

    return {
        restrict: 'E',
        scope: {
            objects: '=',
            key: '@'
        },
        templateUrl: 'directives/multi-boxes/multi-boxes.html',
        link: function(scope) {
            scope.removeObject = function(index) {
                scope.objects.splice(index, 1);
            };
        }
    };

}]);
/* origin: public/webapp/directives/multi-select/logz-multi-select.js */
angular.module('webApp').directive('logzMultiSelect', function($document, $timeout ) {
    return {
        scope: {
            options: '=',
            optionKey:'@',
            selectedOptionArray:'=',
            buttonTitle:'@',
            buttonFunction:'&'
        },
        template:
                '<div id="logz-multi-select">' +
                    '<div class="selected-option clearfix" style="padding:8px" ng-click="toggleDropDownVisible()">' +
                        '<span class="selected-title"></span>' +
                        '<i class="fa fa-chevron-down pull-right"></i>' +
                    '</div>' +
                    '<div class="options align-position" ng-show="isDropDownVisible">' +
                        '<div class="dropdown-button" ng-click="buttonFunction()" ng-bind="buttonTitle"></div>' +
                        '<div ng-repeat="option in options" class="option" ng-click="toggleSelectOption(option)">' +
                            '<i class="fa fa-square-o icon-check-option" ng-show="!option.isSelected"></i>' +
                            '<i class="fa fa-check-square-o icon-check-option" ng-show="option.isSelected"></i>' +
                            '<span>{{option[optionKey]}}</span>'+
                        '</div>' +
                    '</div>' +
                '</div>',

        link: function(scope, element) {
            scope.toggleDropDownVisible = function() {
                scope.isDropDownVisible = !scope.isDropDownVisible;
                bindOutsideClick();
            };

            var bindOutsideClick = function() {
                $timeout(function() {
                    $document.one('click', function(e) {
                        var clickedOnDropDown = element.find('.options')[0] === e.target || element.find('.options').find(e.target).length > 0;
                        if (!clickedOnDropDown) {
                            scope.$apply(function() {
                                scope.isDropDownVisible = false;
                            });
                        }
                        else {
                            bindOutsideClick();
                        }
                    });
                }, 200);
            };

            scope.toggleSelectOption = function(optionPicked) {
                optionPicked.isSelected = !optionPicked.isSelected;
                modifySelectedOptionArray(optionPicked);
            };

            var modifySelectedOptionArray = function(optionPicked) {
                if (optionPicked.isSelected && scope.selectedOptionArray) {
                    scope.selectedOptionArray.push(optionPicked);
                }
                else {
                    _.remove(scope.selectedOptionArray, function(option) {
                        return option.id === optionPicked.id;
                    });
                }
            };
        }

    };

});

/* origin: public/webapp/directives/ng-for.js */
angular.module('webApp').directive('ngFor', [function() {

    return {

        restrict: 'A',
        link: function(scope, element) {
            element.attr('for', scope.ngFor);
        },
        scope: {
            ngFor: '@'
        }
    };
}]);

/* origin: public/webapp/directives/ng-really-click.js */
angular.module('webApp').directive('ngReallyClick', [function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.bind('click', function() {
                var message = attrs.ngReallyMessage;
                if (message && confirm(message)) {
                    scope.$apply(attrs.ngReallyClick);
                }
            });
        }
    };
}]);

/* origin: public/webapp/directives/online-checker/online-checker.js */
angular.module('webApp').directive('logzOnlineChecker', function($interval, $timeout, ngDialog) {

    var _checkTimer, _retryTimer;
    var _interval = 3000;
    var _retryInterval = 20;
    var _offlineDialog = undefined;
    var _storageKey = '__kibanaOnline';

    return {
        restrict: 'E',
        link: function(scope) {
            if (!navigator || !navigator.onLine)
                return;

            startCheck();

            function startCheck() {
                // clean up first
                if (_checkTimer) $interval.cancel(_checkTimer);
                if (_retryTimer) $interval.cancel(_retryTimer);

                _checkTimer = $interval(function() {
                    if (!isOnline())
                        openDialog();
                }, _interval);
            }

            function openDialog() {
                $interval.cancel(_checkTimer);

                scope.retryCountdown = _retryInterval;
                _retryTimer = $interval(function() {
                    if (scope.retryCountdown === 1) {
                        // try to reconnect and start over
                        if (!isOnline()) {
                            scope.retryCountdown = _retryInterval;
                        }
                        else {
                            $interval.cancel(_retryTimer);
                            closeDialog();
                        }
                    }
                    scope.retryCountdown--;
                }, 1000);

                _offlineDialog = ngDialog.open({
                    template: 'directives/online-checker/popup/offline-message.html',
                    width: '500px',
                    controller: [function() { }],
                    scope: scope,
                    preCloseCallback: startCheck,
                    showClose: false
                });
            }

            function closeDialog() {
                if (_offlineDialog && _offlineDialog.close)
                    _offlineDialog.close();
                if (_retryTimer)
                    $interval.cancel(_retryTimer);
                startCheck();
            }

            function isOnline() {
                if (navigator.onLine) {
                    window.sessionStorage.setItem(_storageKey, true);
                    return true;
                }
                else if (!navigator.onLine) {
                    window.sessionStorage.setItem(_storageKey, false);
                    return false;
                }
            }
        }
    };

});
/* origin: public/webapp/directives/password-input-with-show-hide/password-input-with-show-hide-controller.js */
angular.module('webApp').controller('PasswordInputWithShowHideController', function ($element, $scope) {
    var vm = this;
    vm.changeCallback = $scope.changeCallback;
    vm.ngBlur = $scope.ngBlur;
    vm.ngMinlength = $scope.ngMinlength;
    vm.ngRequired = $scope.ngRequired;
    vm.tabIndex = $scope.tabIndex;

    var inputDom = $element.find('input');
    vm.toggleShowHide = function (showPassword) {
        inputDom.attr('type', showPassword ? 'text' : 'password');
    };
    vm.toggleShowHide(false);

    vm.focusOnInput = function () {
        inputDom.focus();
    };

    vm.preventBlur = function ($event) {
        $event.preventDefault();
    };
});
/* origin: public/webapp/directives/password-input-with-show-hide/password-input-with-show-hide.js */
angular.module('webApp').directive('passwordInputWithShowHide', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/password-input-with-show-hide/password-input-with-show-hide.html',
        controller: 'PasswordInputWithShowHideController',
        controllerAs: 'vm',
        scope: {
            changeCallback: '&',
            ngFocus: '&',
            ngBlur: '&',
            enterKeyCallback: '&',
            ngMinlength: '=',
            ngRequired: '=',
            tabIndex: '='
        }
    };
});

/* origin: public/webapp/directives/people-count/people-count.js */
angular.module('webApp').directive('peopleCount', [function() {

    var html = '<span class="people-count-img"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 21.09 22.58"><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path d="M10.55,14.59c3,0,5.46-3.27,5.46-7.29S13.55,0,10.55,0A4.87,4.87,0,0,0,6.63,2.2,8.68,8.68,0,0,0,5.09,7.29C5.09,11.31,7.54,14.59,10.55,14.59Zm0-13c2.2,0,4,2.55,4,5.69s-1.8,5.69-4,5.69-4-2.56-4-5.69S8.34,1.6,10.55,1.6Zm4.58,12.19a.8.8,0,0,0,0,1.6,4.76,4.76,0,0,1,4.51,5,.61.61,0,0,1-.58.64H2a.61.61,0,0,1-.58-.64,4.75,4.75,0,0,1,4.51-5,.8.8,0,0,0,0-1.6c-3.29,0-6,2.94-6,6.55a2.15,2.15,0,0,0,2,2.24h17a2.15,2.15,0,0,0,2-2.24C21.09,16.73,18.42,13.79,15.13,13.79Z"/></g></g></svg></span>' +
               '<span class="people-count-text" ng-bind-template="{{count || 0}}"></span>';

    return {
        restrict: 'E',
        template: html,
        scope: {
            count: '=?'
        },
        link: function(scope) {
            scope.tooltip = 'Installed by ' + scope.count + ' user' + (scope.count > 1 ? 's' : '');
        }
    };
}]);
/* origin: public/webapp/directives/plan-section/logz-plan-section.js */
angular.module('webApp').directive('logzPlanSection', [function() {
    return {
        restrict: 'E',
        templateUrl: 'directives/plan-section/logz-plan-section.html',
        transclude: true,
        scope: {
            name: '@',
            checkboxModel: '=?'
        },
        link: function(scope, element, attrs) {
            scope.showCheckbox = attrs['checkboxModel'] !== undefined;
        }
    };
}]);
/* origin: public/webapp/directives/plus-minus-counter-select/plus-minus-counter-select-controller.js */
angular.module('webApp').controller('PlusMinusCounterSelectController', function ($scope) {

    $scope.validationRegex = new RegExp('(\\-?\\d+)(\\.?\\d{0,2})');

    $scope.inputName = $scope.inputName || 'input';
    $scope.formName = $scope.formName || 'plusMinusForm';

    $scope.increase = function () {
        if ($scope.disabled) {
            return;
        }
        if ($scope.defaultValue < $scope.maxValue && $scope.defaultValue >= $scope.minValue) {
            $scope.defaultValue++;
        }
        if ($scope.defaultValue < $scope.minValue) {
            $scope.defaultValue = $scope.minValue;
        }
    };

    $scope.decrease = function () {
        if ($scope.disabled) {
            return;
        }

        if ($scope.defaultValue > $scope.minValue && $scope.defaultValue <= $scope.maxValue) {
            $scope.defaultValue--;
        }

        if ($scope.defaultValue > $scope.maxValue) {
            $scope.defaultValue = $scope.maxValue;
        }
    };
});
/* origin: public/webapp/directives/plus-minus-counter-select/plus-minus-counter-select.js */
angular.module('webApp').directive('plusMinusCounterSelect', [function () {

    return {
        restrict: 'E',
        templateUrl: 'directives/plus-minus-counter-select/plus-minus-counter-select.html',
        controller: 'PlusMinusCounterSelectController',
        scope: {
            defaultValue: '=',
            maxValue: '=',
            minValue: '=',
            inputName: '@',
            formName: '@',
            suffix: '@',
            disabled: '<'
        }
    };
}]);
/* origin: public/webapp/directives/query-filter.js */
angular.module('webApp').directive('queryFilter', function($rootScope, $window, Backend) {

    // todo: extract this to separate template file
    var html = '<div class="query-filter-control clearfix" ng-class="{\'readonly\':filterId.id}">' +
            '<input type="text" ng-model="filter.description.value" class="description" ng-keyup="descriptionError = false;" ng-class="{\'readonly\':filterId.id, \'warn\':descriptionError}" placeholder="description" ng-disabled="filterId.id" />' +
            '<input type="text" ng-model="filter.content.field" class="field" ng-keyup="fieldError = false;" ng-class="{\'readonly\':filterId.id, \'warn\':fieldError}" placeholder="field" ng-disabled="filterId.id">' +
            '<input type="text" ng-model="filter.content.value" class="value" ng-keyup="valueError = false;" ng-class="{\'readonly\':filterId.id, \'warn\':valueError}" placeholder="value" ng-disabled="filterId.id">' +
            '<span class="pull-right delete" ng-show="filterId.id" ng-click="deleteFilter()"><i class="fa fa-close"></i></span>' +
            '<span class="button-link save" ng-show="!filterId.id && !savingFilter" ng-click="saveFilter()">Save</span>' +
        '</div>';

    return {
        restrict: 'E',
        scope: {
            filterId: '=?',
            filter: '=?'
        },
        template: html,
        link: function(scope) {

            scope.filter = scope.filter || {
                description: { value: '' },
                type: 'TERM',
                content: {
                    field: '',
                    value: '',
                    type: 'TERM'
                }
            };

            scope.filter.description = scope.filter.description || { value: '' }; // New shared tokens description is a string instead of an object with value string

            scope.formValid = true;
            scope.savingFilter = false;
            scope.saveFilter = function() {

                scope.formValid = true;
                if (!scope.filter.description || scope.filter.description.value.trim().length === 0) {
                    scope.descriptionError = true;
                    scope.formValid = false;
                }
                if (!scope.filter.content.field || scope.filter.content.field.trim().length === 0) {
                    scope.fieldError = true;
                    scope.formValid = false;
                }
                if (!scope.filter.content.value || scope.filter.content.value.trim().length === 0) {
                    scope.valueError = true;
                    scope.formValid = false;
                }
                if (!scope.formValid) return;

                scope.savingFilter = true;
                Backend.POST('/account/query-filters', scope.filter).then(function() {
                    $rootScope.$broadcast('query-filter-update');
                }).catch(function() {
                    alert('There was an error creating the filter.');
                    scope.savingFilter = false;
                });
            };

            scope.deleteFilter = function() {
                if (!$window.confirm('Are you sure you want to delete this query filter ?'))
                    return;

                scope.savingFilter = true;

                Backend.DELETE('/account/query-filters/' + scope.filterId.id).then(function() {
                    $rootScope.$broadcast('query-filter-update');
                });
            };
        }
    };
});
/* origin: public/webapp/directives/question-mark-note-with-dialog/question-mark-note-with-dialog-controller.js */
angular.module('webApp').controller('QuestionMarkNoteWithDialogController', function ($scope, $document, $timeout, $element) {
    var vm = this;
    vm.dialogShouldBeOpened = false;

    vm.closeDialog = function (event) {
        if (event && $element.has(event.target).length > 0) {
            $document.one('click', vm.closeDialog);
            return; // Event sent from an inner click within the dialog, shouldn't close
        }

        // Not really sure why, but without the $timeout the close performs after a small delay, doing $scope.$apply isn't a good solution due to $document.one and closeFunc direct calling being called the same time and angular throws an exception
        $timeout(function () {
            vm.dialogShouldBeOpened = false;
        }, 0);
    };

    vm.openDialog = function () {
        // Have to use $timeout due to $document.one that might conflict with opening the dialog, this way we make sure the $document.one (close dialog callback) happens before the re-open
        $timeout(function () {
            vm.dialogShouldBeOpened = true;
            if (vm.openCallback) {
                vm.openCallback();
            }

            $document.one('click', vm.closeDialog);
        }, 0);
    };

    vm.toggleDialog = function () {
        vm.dialogShouldBeOpened ? vm.closeDialog() : vm.openDialog();
    };
});

/* origin: public/webapp/directives/question-mark-note-with-dialog/question-mark-note-with-dialog.js */
angular.module('webApp').directive('questionMarkNoteWithDialog', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/question-mark-note-with-dialog/question-mark-note-with-dialog.html',
        transclude: true,
        controller: 'QuestionMarkNoteWithDialogController',
        controllerAs: 'vm',
        scope: {
            template : '@'
        }
    };
});
/* origin: public/webapp/directives/s3-archive.js */
angular.module('webApp').directive('s3Archive', function($timeout, Backend) {

    return {
        restrict: 'E',
        templateUrl: 'directives/s3-archive.html',
        scope: {
            accountId: '=',
            settings: '='
        },
        link: function(scope) {

            var initialSecretKey = scope.settings ? scope.settings.encryptedSecret : undefined;

            scope.errors = {};
            scope.deleted = false;
            scope.saveSettings = function(archiveSettingsId) {
                if (!scope.settings.path || !scope.settings.key || scope.formNotFull) {
                    scope.errorMessage = 'Please fill in all fields';
                    $timeout(function() {
                        scope.errorMessage = '';
                    }, 5000);
                    return;
                }

                if (scope.saving)
                    return;

                scope.saving = true;
                var settings = {
                    accountId: scope.accountId,
                    path: scope.settings.path,
                    key: scope.settings.key,
                    type: 'S3'
                };

                // set secret key
                if (scope.settings.secret === initialSecretKey) {
                    settings.encryptedSecret = initialSecretKey;
                }
                else {
                    settings.secret = scope.settings.secret;
                }

                if (archiveSettingsId) {
                    settings.id = archiveSettingsId;
                }

                Backend.POST('/account/' + (settings.id ? 'update-archive-settings' : 'archive-settings'), settings).then(function(savedSettings) {
                    if (savedSettings.data === '') {
                        scope.errorMessage = 'Failed to save or update settings';
                        scope.saving = false;
                        $timeout(function() {
                            scope.errorMessage = '';
                        }, 8000);
                        return;
                    }

                    scope.saveSuccess = true;

                    $timeout(function() {
                        scope.saveSuccess = false;
                    }, 3000);
                    scope.saving = false;
                }).catch(function(error) {
                    scope.errorMessage = 'Failed to save or update settings';
                    if(error.data){
                        scope.errorMessage = error.data;
                    }
                    scope.saving = false;
                    $timeout(function() {
                        scope.errorMessage = '';
                    }, 8000);
                });
            };

            scope.clearSettings = function(settingId) {
                if (!settingId)
                    return;

                if (!window.confirm('Are you sure you want to clear these settings ?'))
                    return;

                Backend.DELETE('/account/archive-settings', {
                    id: settingId,
                    accountId: scope.accountId,
                    type: 'S3'
                }).then(function() {
                    scope.settings = {
                        accountId: scope.accountId,
                        path: '',
                        key: '',
                        secret: '',
                        type: 'S3'
                    };
                });
            };

            var checkFormFull = function() {
                scope.formNotFull = (!scope.settings || (!scope.settings.path || !scope.settings.key || !scope.settings.secret));
            };
            var pathWatcher = scope.$watch('settings.path', checkFormFull);
            var keyWatcher = scope.$watch('settings.key', checkFormFull);
            var secretWatcher = scope.$watch('settings.secret', checkFormFull);

            scope.$on('$destroy', function() {
                pathWatcher();
                keyWatcher();
                secretWatcher();
            });

        }
    };

});
/* origin: public/webapp/directives/save-input-values.js */
angular.module('webApp').directive('saveInputValues', function() {
    return {
        restrict: 'A',
        scope: { settings: '=saveInputValues' },
        controller: 'saveInputValuesCtrl'
    };
}).controller('saveInputValuesCtrl', function($scope, gabby, $element, localStorageService) {
    gabby.for($scope).settings({
        id: [$element.attr('id'), '_', $element.attr('name')].join('')
    });

    var datalistId = $scope.id + '-datalist';
    var cacheKey = 'input-values.' + $scope.id;
    $element.after($('<datalist/>').attr('id', datalistId));
    $element.attr('list', datalistId);
    var datalistElement = $('#' + datalistId).hide();

    var values = localStorageService.get(cacheKey) || [];
    setOptions();
    $element.on('keyup', function(eventData) {
        if (eventData.keyCode === 13) {
            saveValue();
        }
    });

    $element.blur(function() { saveValue(); setOptions(); });

    function saveValue() {
        var val = $element.val();
        if (val === null || val === '')
            return;

        _.pull(values, val);
        values.unshift(val);
        values = values.slice(0, 30);
        localStorageService.set(cacheKey, values);
    }

    function setOptions() {
        datalistElement.empty();
        values.forEach(function(v) {
            datalistElement.append($('<option/>').attr('value', v));
        });
    }
});

/* origin: public/webapp/directives/sawmill/create-sawmill-controller.js */
/* eslint-disable max-lines */
angular.module('webApp').controller('createSawmillController', function ($scope, $rootScope, $timeout, sawmillEndpointService) {

    var isJsonString = function (str) {
        try {
            JSON.parse(str);
        }
        catch (e) {
            return false;
        }
        return true;
    };
    var sawmillDialog = {
        ADMIN: {
            type: 'ADMIN',
            title: 'Sawmill Type'
        },
        LOG_TYPE: {
            type: 'LOG_TYPE',
            title: 'Sawmill Log Type Pipeline'
        },
        GLOBAL: {
            type: 'GLOBAL',
            title: 'Sawmill Global Pipeline'
        }
    };

    var accountID = $scope.accountID || null;
    $scope.processingSteps = sawmillEndpointService.getAllGlobalSawmillProcessingSteps();
    $scope.sawmillDialog = sawmillDialog[$scope.dialogType];

    $scope.isHOCONMode = false;
    $scope.$watch('isHOCONMode', function () {
        $scope.onJSONChange();
        $scope.textAreaPlaceHolder = $scope.isHOCONMode ? HOCONPlaceHolder : JSONPlaceHolder;
    });
    var JSONPlaceHolder = '{\n  "steps": [\n    {\n      "addTag": {\n        "name": "add Tag",\n' +
        '        "config": {\n          "tags": [\n            "tag1"\n          ]\n        }\n      }\n    }\n  ]\n}';
    var HOCONPlaceHolder = 'steps : [{addTag:{ name:add tag, config.tags:[tag1]}}]';
    $scope.textAreaPlaceHolder = JSONPlaceHolder;

    $scope.loadingSawmillRequest = false;

    var json = {};
    $scope.onJSONChange = function () {
        if ($scope.isHOCONMode) {
            $scope.errorMessage = '';
            return;
        }

        try {
            json = JSON.parse($scope.sawmillJSON);
            $scope.sawmillJSON = JSON.stringify(json, null, '  ');
            $scope.errorMessage = '';
        }
        catch (e) {
            $scope.errorMessage = 'Error with json format, please use \" instead of \' and check your format again.';
        }
    };
    $scope.readOnly = true;

    var clonedSawmillTypeToEdit = _.cloneDeep($scope.sawmillTypeToEdit);
    if (clonedSawmillTypeToEdit) {
        $scope.sawmillDialog.step = clonedSawmillTypeToEdit.step;
        $scope.chosenSawmillType = $scope.sawmillLogType = clonedSawmillTypeToEdit.logType;
        $scope.sawmillJSON = clonedSawmillTypeToEdit.pipelineDefinition;
        $scope.sawmillDescription = clonedSawmillTypeToEdit.description;
        $scope.sawmillName = clonedSawmillTypeToEdit.name;
        $scope.isHOCONMode = !isJsonString(clonedSawmillTypeToEdit.pipelineDefinition);
        $scope.readOnly = clonedSawmillTypeToEdit.readOnly;
        $scope.textAreaPlaceHolder = $scope.isHOCONMode ? HOCONPlaceHolder : JSONPlaceHolder;
        $scope.onJSONChange();
    }

    if ($scope.sawmillDialog.type === 'ADMIN') {
        $scope.loadingSawmillTypes = true;
        sawmillEndpointService.getAllSawmillSupportedLogTypes().then(function (response) {
            $scope.availableSawmillTypes = [];
            _.forEach(response.data, function (sawmillType) {
                $scope.availableSawmillTypes.push(sawmillType);
            });
            $scope.loadingSawmillTypes = false;
        });
    }

    $scope.processingStepName = function (stepKey) {
        for (var i  = 0; i < $scope.processingSteps.length; i++) {
            var step = $scope.processingSteps[i];
            if (step.key === stepKey) return step.name;
        }

        return step;
    };

    $scope.saveSawmillType = function (chosenSawmillType, sawmillJSON, step) {
        angular.forEach($scope.createSawmillTypeForm.$error, function (field) {
            angular.forEach(field, function (errorField) {
                if (errorField.$error.required && errorField.$modelValue && errorField.$modelValue.length >= 0) {
                    errorField.$setValidity('required', true);
                    return;
                }
                errorField.$setTouched();
            });
        });

        if ($scope.createSawmillTypeForm.$invalid) {
            $scope.errorMessage = 'Form is invalid, please make sure all fields are filled.';
            return;
        }
        if ($scope.loadingSawmillRequest) {
            $scope.errorMessage = 'Saving in progress, please wait.';
            return;
        }
        if (!isJsonString(sawmillJSON) && !$scope.isHOCONMode) {
            $scope.errorMessage = 'Problem parsing JSON input. Please use a valid JSON.';
            return;
        }
        if (!chosenSawmillType && $scope.sawmillDialog.type === 'GLOBAL') {
            chosenSawmillType = '';
        }
        if ($scope.sawmillDialog.type === 'LOG_TYPE') {
            chosenSawmillType = $scope.sawmillLogType;
        }

        var finalSawmillJSON = {
            pipelineDefinition: sawmillJSON,
            name: $scope.sawmillName,
            description: $scope.sawmillDescription
        };
        var stringSawmillJSON = JSON.stringify(finalSawmillJSON);
        $scope.loadingSawmillRequest = true;

        if (clonedSawmillTypeToEdit && $scope.sawmillDialog.type === 'GLOBAL') {
            sawmillEndpointService.editGlobalSawmillType(clonedSawmillTypeToEdit, stringSawmillJSON, accountID, step)
                .then(function () {
                    sawmillEndpointService.getAllSawmillByScope($scope.sawmillDialog.type, accountID).then(successCallback);
                }).catch(errorHandler);
        }
        else {
            sawmillEndpointService.saveSawmillType(chosenSawmillType, stringSawmillJSON, $scope.sawmillDialog.type, accountID, step, $scope.readOnly)
                .then(function () {
                    sawmillEndpointService.getAllSawmillByScope($scope.sawmillDialog.type, accountID).then(successCallback);
                }).catch(errorHandler);
        }
    };

    var successCallback = function (response) {
        $rootScope.$broadcast('new-sawmill-configs', {
            types: response.data,
            sawmillScope: $scope.sawmillDialog.type
        });
        $scope.loadingSawmillRequest = false;
        $scope.closeThisDialog();

    };

    var errorHandler = function (error) {
        $scope.errorMessage = error.data ? JSON.stringify(error.data) : JSON.stringify(error);
        $scope.loadingSawmillRequest = false;
    };

    $scope.cancel = function () {
        $scope.closeThisDialog();
    };
});
/* origin: public/webapp/directives/select/logz-select.js */
/* eslint-disable max-lines */
angular.module('webApp').directive('logzSleekSelect', function ($window, $document, $timeout) {
    return {
        restrict: 'A',
        scope: true,
        require: '?ngModel',
        link: function (scope, element, attrs, ngModel) {
            if (element[0].tabIndex === -1) {
                // Ugly hack to in order to listen to keydown on non-input DOM
                element[0].tabIndex = 6;
            }

            var optionsArea = element.find('.options');
            var optionsContainerArea = element.find('.options-container'); // Will exist in case of an expandable selector

            var attributesBooleanDefault = {
                animate: false,
                onHover: false,
                closeOnClick: true,
                allowFilter: false,
                allowNew: false,
                manualClickHandling: false
            };
            var getAttributeAsBoolean = function (attributeName) {
                var attribute = attrs[attributeName];
                if (attribute === '' || attribute === undefined) {
                    return attributesBooleanDefault[attributeName];
                }

                return attribute.toLowerCase() === 'true';
            };

            var calculateOptionsAreaHeight = function() {
                var currentHeight = optionsArea.css('height');
                optionsArea.css('height', '');
                var optionsAreaHeight = optionsArea.outerHeight();
                optionsArea.css('height', currentHeight);

                return optionsAreaHeight;
            };

            var setOverflowOptions = function (visible) {
                var propertyWithValue = { 'overflow-y': visible ? 'auto' : 'hidden' };

                optionsArea.css(propertyWithValue);
                if (optionsContainerArea) {
                    optionsContainerArea.css(propertyWithValue);
                }
            };

            var overflowYTimerRunning = false;
            var overflowYTimer;
            scope.toggleOptionsMenu = function (visible) {
                scope.visible = visible;

                if (!visible) {
                    $document.off('click', documentClick);
                }

                $timeout(function() {
                    scope.$apply(function() {

                        if (selectedTitleDom && (getAttributeAsBoolean('allowFilter') || getAttributeAsBoolean('allowNew'))) {
                            if (scope.visible && !filterDisabled) {
                                selectedTitleDom.addClass('with-typing-animation');
                            }
                            else {
                                selectedTitleDom.removeClass('with-typing-animation');
                            }
                        }

                        if (!visible && getAttributeAsBoolean('allowNew') && scope.inFilterMode) {
                            ngModel.$setViewValue(scope.selectedTitle);
                            scope.inFilterMode = false;
                        }
                        else if (!visible && getAttributeAsBoolean('allowFilter') && !getAttributeAsBoolean('allowNew') && (scope.inFilterMode || filterDisabled)) {
                            scope.selectedTitle = selectedTitleBeforeFilter;
                            scope.inFilterMode = false;
                        }
                    });
                });

                if (getAttributeAsBoolean('animate')) {
                    var visibility = visible ? 'visible' : 'hidden';
                    var height = visible ? [ calculateOptionsAreaHeight(), 'px' ].join('') : '0';
                    if (height === '2px') { // due to border
                        visibility = 'hidden';
                    }

                    $timeout(function() {
                        optionsArea.css({'height': height, 'visibility' : visibility});
                    }, 0);
                }

                if (overflowYTimerRunning) {
                    $timeout.cancel(overflowYTimer);
                    overflowYTimerRunning = false;
                }

                if (getAttributeAsBoolean('animate') && visible) {
                    overflowYTimerRunning = true;
                    overflowYTimer = $timeout(function () {
                        setOverflowOptions(visible);
                    }, 400); // Add the scroll option only after the height animation (400 ms)
                }
                else {
                    setOverflowOptions(visible);
                }

                if (!visible && attrs.menuCloseCallback) {
                    $timeout(function () {
                        scope.$apply(attrs.menuCloseCallback);
                    }, 0);
                }
            };
            scope.toggleOptionsMenu(false);

            var addClickEventForOptions = function() {
                if (getAttributeAsBoolean('manualClickHandling')) {
                    return;
                }

                var options = element.find('.option');
                options.click(function() {
                    if (getAttributeAsBoolean('ngDisabled')) return;

                    if (ngModel) {
                        ngModel.$setViewValue($(this).html());
                        ngModel.$commitViewValue();
                    }

                    scope.selectedTitle = $(this).html();
                    scope.inFilterMode = false;

                    if (getAttributeAsBoolean('closeOnClick')) {
                        scope.toggleOptionsMenu(false);
                    }
                });
            };

            var optionsChangeWatcher = scope.$watch(function() { return element.find('.option').length; }, function() {
                addClickEventForOptions();
                scope.toggleOptionsMenu(scope.visible);

                if (ngModel && !scope.inFilterMode) {
                    $timeout(function() {
                        scope.selectedTitle = element.find([ '.option[value="', ngModel.$modelValue, '"]' ].join('')).html() || ngModel.$modelValue;
                    }, 0);
                }
            });

            var openMenu = function() {
                if (getAttributeAsBoolean('ngDisabled') || scope.visible) return;

                scope.toggleOptionsMenu(true);
                positionOptions(true);
                element.css({'position': getAttributeAsBoolean('absolutePositioning') ? 'initial' : 'relative'});

                $timeout(function() {
                    $document.on('click', documentClick);
                }, 200);

                filterDisabled = false;
            };

            var documentClick = function (e) {
                var clickedOnDropDown = element.find('.options')[0] === e.target || element.find('.options').find(e.target).length > 0;
                if (!getAttributeAsBoolean('onHover') && !clickedOnDropDown) {
                    scope.toggleOptionsMenu(false);
                }
            };

            var isDescendant = function (parents, child) {
                var node = child.parentNode;
                while (node !== null) {
                    if (parents.indexOf(node) >= 0) {
                        return true;
                    }
                    node = node.parentNode;
                }
                return false;
            };

            var closeMenu = function (event) {
                if (!scope.visible) return;

                if (!getAttributeAsBoolean('onHover')) {
                    scope.toggleOptionsMenu(false);
                    return;
                }

                var hoveredElement = event.toElement;
                if (selectedValueArea[0] === hoveredElement || optionsArea[0] === hoveredElement || (hoveredElement && isDescendant([ selectedValueArea[0], optionsArea[0] ], hoveredElement))) {
                    return; // Hovering between children DOMs, shouldn't close menu
                }

                scope.toggleOptionsMenu(false);
            };

            var selectedValueArea = element.find('div.selected-value');
            if (getAttributeAsBoolean('onHover')) {
                selectedValueArea.bind('mouseover', openMenu);
                optionsArea.bind('mouseover', openMenu);
                selectedValueArea.bind('mouseout', closeMenu);
                optionsArea.bind('mouseout', closeMenu);
            }
            else {
                selectedValueArea.click(function() {
                    if (getAttributeAsBoolean('ngDisabled')) return;

                    if (scope.visible)
                        closeMenu();
                    else
                        openMenu();
                });
            }

            var selectedTitleDom = element.find('span.selected-title');

            if (ngModel) {
                ngModel.$formatters.unshift(function(value) {
                    $timeout(function() {
                        scope.selectedTitle = element.find([ '.option[value="', value, '"]' ].join('')).html() || value;
                    }, 0);
                });

                ngModel.$parsers.unshift(function(viewValue) {
                    return getSelectedValueFromTitle(viewValue) || viewValue;
                });
            }

            function getSelectedValueFromTitle(val) {
                var options = element.find('.option');
                for (var i=0; i<options.length; i++) {
                    if ($(options[i]).html() === val) {
                        return $(options[i]).attr('value');
                    }
                }
            }

            scope.inFilterMode = false;
            var filterDisabled = false;
            var selectedTitleBeforeFilter;
            if (getAttributeAsBoolean('allowFilter')) {
                element.keydown(function (e) {
                    if (!scope.visible || filterDisabled) {
                        return;
                    }

                    var key = e.key;
                    var currentlyFilterApplied = scope.inFilterMode && scope.selectedTitle.length > 0;
                    if (key === 'Backspace' && currentlyFilterApplied) {
                        scope.$apply(function () {
                            scope.selectedTitle = scope.selectedTitle.substring(0, scope.selectedTitle.length - 1);
                            scope.inFilterMode = scope.selectedTitle.length > 0;
                            scope.toggleOptionsMenu(true);
                        });
                        return;
                    }

                    if (key === 'Escape' && currentlyFilterApplied) {
                        scope.$apply(function () {
                            scope.selectedTitle = selectedTitleBeforeFilter;
                            scope.inFilterMode = false;
                        });
                        return false; // Avoid browser from processing this escape
                    }

                    if (key === 'Enter' && getAttributeAsBoolean('allowNew')) {
                        scope.toggleOptionsMenu(false);
                        return;
                    }

                    if (key.length > 1) {
                        return; // Not a valid char (can be Escape, F8, Ctrl etc...)
                    }

                    scope.$apply(function () {
                        if (!scope.inFilterMode) {
                            selectedTitleBeforeFilter = scope.selectedTitle;
                            scope.selectedTitle = '';
                            scope.inFilterMode = true;
                        }

                        scope.selectedTitle += key;
                        scope.toggleOptionsMenu(true);
                    });

                    if (key === ' ') {
                        return false; // Avoid browser from processing the space (scrolling)
                    }
                });
            }

            scope.disableFilterTillMenuOpen = function (newSelectedTitle) {
                filterDisabled = true;
                if (!scope.inFilterMode) {
                    selectedTitleBeforeFilter = scope.selectedTitle;
                }
                scope.selectedTitle = newSelectedTitle;

                selectedTitleDom.removeClass('with-typing-animation');
            };

            var disabledWatcher = scope.$watch(function () { return getAttributeAsBoolean('ngDisabled'); }, function () {
                if (getAttributeAsBoolean('ngDisabled')) {
                    element.addClass('disabled');
                    scope.toggleOptionsMenu(false);
                    return;
                }

                element.removeClass('disabled');
            });

            var window = angular.element($window);

            var positionOptions = function (shouldScrollToTop) {
                if (!scope.visible) return;

                if (typeof shouldScrollToTop === 'boolean') {
                    optionsArea[0].scrollTop = 0; // Should happen only after menu open and not due to window resize event listener
                }

                if (!getAttributeAsBoolean('absolutePositioning')) {
                    optionsArea.css({
                        top: (element.outerHeight(true) - 2) + 'px',
                        left: '-1px'
                    });

                    return;
                }

                var targetRect = element[0].getBoundingClientRect();
                optionsArea.css({
                    top: targetRect.top + window.scrollTop(),
                    left: targetRect.left
                });
            };

            if (getAttributeAsBoolean('absolutePositioning')) {
                optionsArea.css('position', 'absolute');
                window.on('resize', positionOptions);
            }

            var nodeToCloseMenuOnScroll;
            if (attrs['closeOnParentScroll']) {
                nodeToCloseMenuOnScroll = element;
                var parentCounter = parseInt(attrs['closeOnParentScroll']);
                for (var i = 0; i < parentCounter; i++) {
                    nodeToCloseMenuOnScroll = nodeToCloseMenuOnScroll.parent();
                }

                nodeToCloseMenuOnScroll.on('scroll', closeMenu);
            }

            scope.$on('$destroy', function() {
                if (optionsArea) optionsArea.unbind();
                if (selectedValueArea) selectedValueArea.unbind();
                if (optionsChangeWatcher) optionsChangeWatcher();
                if (disabledWatcher) disabledWatcher();

                $document.off('click', documentClick);
                window.off('resize', positionOptions);
                if (nodeToCloseMenuOnScroll) nodeToCloseMenuOnScroll.off('scroll', closeMenu);
            });
        }
    };
});
/* eslint-enable max-lines */
/* origin: public/webapp/directives/sparkline/sparkline.js */
angular.module('webApp').directive('logzioSparkline', [function () {
    return {
        restrict: 'E',
        template: '',
        scope: {
            data: '=',
            horizontalLineValue: '=', // The Y axis value in which to draw the horizontal line
            horizontalLinePos: '@', // The position of the line, relative to the data (e.g. 25 is at 1/4 of Sparkline board)
            graphColor: '@'
        },
        link: function(scope, elem) {

            var dataWatcher = scope.$watch('data', drawSparkline);

            function drawSparkline() {

                elem.html('');

                if (!scope.data || !Object.keys(scope.data).length)
                    return;

                var graphWidth = elem.parent().width();
                var graphHeight = elem.parent().height();

                elem.width(graphWidth).height(graphHeight);

                // organize data
                var parsedData = [];
                Object.keys(scope.data).forEach(function(d) {
                    parsedData.push({ date: d, value: scope.data[d] });
                });

                parsedData = _.sortBy(parsedData, function(d) {
                    return d.date;
                });

                // x axis
                var x = d3.time.scale()
                    .range([0, graphWidth])
                    .domain(d3.extent(parsedData, function(d) { return parseInt(d.date); }));

                // y axis
                var y = d3.scale.linear().range([graphHeight, 0]);

                if (scope.horizontalLineValue) {
                    scope.horizontalLinePos = scope.horizontalLinePos || 50;

                    y = y.domain([0, (1 + scope.horizontalLinePos / 100) * scope.horizontalLineValue]);
                }
                else
                    y = y.domain(d3.extent(parsedData, function(d) { return d.value; }));

                // var lineHeightPercentage = (scope.horizontalLineValue + (scope.horizontalLinePos/100) * scope.horizontalLineValue)

                // draw the line
                var line = d3.svg.line()
                    .interpolate('basis')
                    .x(function(d) { return x(d.date); })
                    .y(function(d) { return y(d.value); });

                var svg = d3.select(elem[0])
                    .append('svg')
                    .attr('width', graphWidth)
                    .attr('height', graphHeight)
                    .append('g');
                svg.append('path')
                    .datum(parsedData)
                    .attr('class', 'sparkline')
                    .attr('stroke', scope.graphColor ? scope.graphColor : '#ff0000')
                    .attr('stroke-width', 2)
                    .attr('fill', 'none')
                    .attr('d', line);

                // draw the horizontal line
                if (scope.horizontalLineValue) {
                    // Draw the background above the horizontal line
                    var rectLineHeight = graphHeight - (graphHeight/(1 + scope.horizontalLinePos/100));

                    svg.append('rect')
                        .attr('x', 0)
                        .attr('y', 0)
                        .attr('width', graphWidth)
                        .attr('height', rectLineHeight)
                        .attr('fill', 'red')
                        .attr('fill-opacity', '0.1');

                    // Draw the dashed line
                    svg.append('path')
                        .datum([ {date: Object.keys(scope.data)[0], value: scope.horizontalLineValue}, {date:Object.keys(scope.data)[Object.keys(scope.data).length-1], value: scope.horizontalLineValue} ])
                        .attr('class', 'sparkline')
                        .attr('stroke', '#ff5454')
                        .attr('stroke-width', 1)
                        .attr('stroke-dasharray', [5, 5])
                        .attr('fill', 'none')
                        .attr('d', line);
                }
            }

            drawSparkline();

            scope.$on('$destroy', dataWatcher);

        }
    };
}]);
/* origin: public/webapp/directives/tab/tab.js */
angular.module('webApp').directive('tab', function () {
    return {
        restrict: 'E',
        require: '^tabsManager',
        scope: {
            tabTitle: '@',
            suffix: '=',
            active: '=',
        },
        template: '<div class="tab-data-container" ng-show="tab.active" ng-transclude></div>',
        replace: true,
        transclude: true,
        link: function ($scope, element, attrs, tabsCtrl) {
            $scope.tab = {
                tabTitle: $scope.tabTitle,
                suffix: $scope.suffix,
                active: $scope.active
            };
            tabsCtrl.register($scope.tab);
        }
    };
});

/* origin: public/webapp/directives/tabs-manager/tabs-manager-controller.js */
angular.module('webApp').controller('TabsManagerController', function ($scope, $timeout) {
    var vm = this;

    vm.tabs = [];
    vm.register = function (tab) {
        if (tab.active) {
            vm.activeTab = tab;
        }

        vm.tabs.push(tab);
    };

    vm.select = function (tab) {
        if (tab.active) {
            return;
        }

        vm.activeTab.active = false;
        vm.activeTab = tab;
        render(tab);

        $scope.optionalOnTabActionFunc(tab);
    };

    var rendering = false;
    var renderTimer;
    var render = function (tab) {
        if (rendering) $timeout.cancel(renderTimer);

        renderTimer = $timeout(function () {
            tab.active = true;
        }, 210); // 210 is to make sure the hide animation is done (transition 0.2s)
    };

    vm.optionalActionText = $scope.optionalActionText;
    vm.optionalActionFunc = $scope.optionalActionFunc;

    $scope.$on('$destroy', function () {
        if (rendering) $timeout.cancel(renderTimer);
    });
});
/* origin: public/webapp/directives/tabs-manager/tabs-manager.js */
angular.module('webApp').directive('tabsManager', function () {
    return {
        restrict: 'E',
        templateUrl: 'directives/tabs-manager/tabs-manager.html',
        transclude: true,
        replace: true,
        controller: 'TabsManagerController',
        controllerAs: 'vm',
        scope: {
            optionalActionText: '=',
            optionalActionFunc: '=',
            optionalOnTabActionFunc: '='
        }
    };
});
/* origin: public/webapp/directives/textarea-auto-height.js */
angular.module('webApp').directive('logzAutoHeightTextarea', [
    '$timeout', '$window',
    function($timeout, $window) {
        'use strict';

        return {
            require: 'ngModel',
            restrict: 'A, C',
            link: function(scope, element, attrs, ngModel) {

                // cache a reference to the DOM element
                var ta = element[0],
                    $ta = element;

                var config = {append: '\n'};

                // ensure the element is a textarea, and browser is capable
                if (ta.nodeName !== 'TEXTAREA' || !$window.getComputedStyle) {
                    return;
                }

                // set these properties before measuring dimensions
                $ta.css({
                    'overflow': 'hidden',
                    'overflow-y': 'hidden',
                    'word-wrap': 'break-word'
                });

                // force text reflow
                var text = ta.value;
                ta.value = '';
                ta.value = text;

                var append = attrs.msdElastic ? attrs.msdElastic.replace(/\\n/g, '\n') : config.append,
                    $win = angular.element($window),
                    mirrorInitStyle = 'position: absolute; top: -999px; right: auto; bottom: auto;' +
                        'left: 0; overflow: hidden; -webkit-box-sizing: content-box;' +
                        '-moz-box-sizing: content-box; box-sizing: content-box;' +
                        'min-height: 0 !important; height: 0 !important; padding: 0;' +
                        'word-wrap: break-word; border: 0;',
                    $mirror = angular.element('<textarea aria-hidden="true" tabindex="-1" ' +
                        'style="' + mirrorInitStyle + '"/>').data('elastic', true),
                    mirror = $mirror[0],
                    taStyle = getComputedStyle(ta),
                    resize = taStyle.getPropertyValue('resize'),
                    borderBox = taStyle.getPropertyValue('box-sizing') === 'border-box' ||
                        taStyle.getPropertyValue('-moz-box-sizing') === 'border-box' ||
                        taStyle.getPropertyValue('-webkit-box-sizing') === 'border-box',
                    boxOuter = !borderBox ? {width: 0, height: 0} : {
                        width:  parseInt(taStyle.getPropertyValue('border-right-width'), 10) +
                        parseInt(taStyle.getPropertyValue('padding-right'), 10) +
                        parseInt(taStyle.getPropertyValue('padding-left'), 10) +
                        parseInt(taStyle.getPropertyValue('border-left-width'), 10),
                        height: parseInt(taStyle.getPropertyValue('border-top-width'), 10) +
                        parseInt(taStyle.getPropertyValue('padding-top'), 10) +
                        parseInt(taStyle.getPropertyValue('padding-bottom'), 10) +
                        parseInt(taStyle.getPropertyValue('border-bottom-width'), 10)
                    },
                    minHeightValue = parseInt(taStyle.getPropertyValue('min-height'), 10),
                    heightValue = parseInt(taStyle.getPropertyValue('height'), 10),
                    minHeight = Math.max(minHeightValue, heightValue) - boxOuter.height,
                    maxHeight = parseInt(taStyle.getPropertyValue('max-height'), 10),
                    mirrored,
                    active,
                    copyStyle = ['font-family',
                        'font-size',
                        'font-weight',
                        'font-style',
                        'letter-spacing',
                        'line-height',
                        'text-transform',
                        'word-spacing',
                        'text-indent'];

                // exit if elastic already applied (or is the mirror element)
                if ($ta.data('elastic')) {
                    return;
                }

                // Opera returns max-height of -1 if not set
                maxHeight = maxHeight && maxHeight > 0 ? maxHeight : 9e4;

                // append mirror to the DOM
                if (mirror.parentNode !== document.body) {
                    angular.element(document.body).append(mirror);
                }

                // set resize and apply elastic
                $ta.css({
                    'resize': (resize === 'none' || resize === 'vertical') ? 'none' : 'horizontal'
                }).data('elastic', true);

                /*
                 * methods
                 */

                function initMirror() {
                    var mirrorStyle = mirrorInitStyle;

                    mirrored = ta;
                    // copy the essential styles from the textarea to the mirror
                    taStyle = getComputedStyle(ta);
                    angular.forEach(copyStyle, function(val) {
                        mirrorStyle += val + ':' + taStyle.getPropertyValue(val) + ';';
                    });
                    mirror.setAttribute('style', mirrorStyle);
                }

                function adjust() {
                    var taHeight,
                        taComputedStyleWidth,
                        mirrorHeight,
                        width,
                        overflow;

                    if (mirrored !== ta) {
                        initMirror();
                    }

                    // active flag prevents actions in function from calling adjust again
                    if (!active) {
                        active = true;

                        mirror.value = ta.value + append; // optional whitespace to improve animation
                        mirror.style.overflowY = ta.style.overflowY;

                        taHeight = ta.style.height === '' ? 'auto' : parseInt(ta.style.height, 10);

                        taComputedStyleWidth = getComputedStyle(ta).getPropertyValue('width');

                        // ensure getComputedStyle has returned a readable 'used value' pixel width
                        if (taComputedStyleWidth.substr(taComputedStyleWidth.length - 2, 2) === 'px') {
                            // update mirror width in case the textarea width has changed
                            width = parseInt(taComputedStyleWidth, 10) - boxOuter.width;
                            mirror.style.width = width + 'px';
                        }

                        mirrorHeight = mirror.scrollHeight;

                        if (mirrorHeight > maxHeight) {
                            mirrorHeight = maxHeight;
                            overflow = 'scroll';
                        }
                        else if (mirrorHeight < minHeight) {
                            mirrorHeight = minHeight;
                        }
                        mirrorHeight += boxOuter.height;
                        ta.style.overflowY = overflow || 'hidden';

                        if (taHeight !== mirrorHeight) {
                            scope.$emit('elastic:resize', $ta, taHeight, mirrorHeight);
                            ta.style.height = mirrorHeight + 'px';
                        }

                        // small delay to prevent an infinite loop
                        $timeout(function() {
                            active = false;
                        }, 1, false);

                    }
                }

                function forceAdjust() {
                    active = false;
                    adjust();
                }

                /*
                 * initialise
                 */

                // listen
                if ('onpropertychange' in ta && 'oninput' in ta) {
                    // IE9
                    ta['oninput'] = ta.onkeyup = adjust;
                }
                else {
                    ta['oninput'] = adjust;
                }

                $win.bind('resize', forceAdjust);

                scope.$watch(function() {
                    return ngModel.$modelValue;
                }, function() {
                    forceAdjust();
                });

                scope.$on('elastic:adjust', function() {
                    initMirror();
                    forceAdjust();
                });

                $timeout(adjust, 0, false);

                /*
                 * destroy
                 */

                scope.$on('$destroy', function() {
                    $mirror.remove();
                    $win.unbind('resize', forceAdjust);
                });
            }
        };
    }
]);

/* origin: public/webapp/directives/tooltips/logz-tooltip.js */
angular.module('webApp').directive('logzTooltip', function($document) {

    return {
        restrict: 'A',
        scope: {
            tooltipText: '@',
            tooltipPosition: '@?',
            tooltipCssClass: '@?',
            hideOnClick: '@?',
            showOnTextOverflow: '='
        },
        link: function(scope, element) {
            var cssClasses = [ 'logz-tooltip' ];
            if (scope.tooltipCssClass) {
                _.forEach(scope.tooltipCssClass.split(','), function (cssClass) {
                    cssClasses.push(cssClass);
                });
            }
            var tooltip = angular.element([ '<div class=\'', cssClasses.join(' '), '\'>', scope.tooltipText, '</div>' ].join(''))[0];
            $document.find('body').append(tooltip);

            var bindOnOverflow = function () {
                var el = element[0];
                // TRUE: Ellipsis is active for element', element
                return el.offsetWidth < el.scrollWidth;
            };

            element.bind('mouseover.tooltip', function() {
                if (!scope.tooltipText ||
                    (scope.showOnTextOverflow && !bindOnOverflow())) {

                    return;
                }

                tooltip.style.opacity = 1;
                tooltip.style.visibility = 'visible';

                var elementPos = element[0].getBoundingClientRect();

                var margin = 8;

                if (scope.tooltipPosition === 'top')
                    tooltip.style.top = (elementPos.top - tooltip.offsetHeight + window.scrollY - margin) + 'px';
                else
                    tooltip.style.top = (elementPos.bottom + window.scrollY + margin) + 'px';

                tooltip.style.left = ((elementPos.left - (tooltip.offsetWidth / 2)) + (element[0].offsetWidth / 2)) + 'px';
            });

            var hideTooltip = function () {
                tooltip.style.opacity = 0;
                tooltip.style.visibility = 'hidden';
            };
            element.bind('mouseout.tooltip', hideTooltip);
            if (scope.hideOnClick === undefined || scope.hideOnClick === 'true') {
                element.on('click', hideTooltip);
            }

            var tooltipTextWatcher = scope.$watch('tooltipText', function () {
                tooltip.innerText = scope.tooltipText;
            });

            scope.$on('$destroy', function() {
                element.unbind('.tooltip');
                tooltip.remove();
                if (tooltipTextWatcher) tooltipTextWatcher();
            });
            element.on('$destroy', function() {
                hideTooltip();
                scope.$destroy();
            });
        }
    };
});
/* origin: public/webapp/directives/user-row/logz-user-row.js */
angular.module('webApp').directive('logzUserRow', function($rootScope, $window, Backend, UserService, AuthService, AccountService) {
    return {
        restrict: 'E',
        templateUrl: 'directives/user-row/logz-user-row.html',
        scope: {
            user: '=?',
            editing: '=?',
            account: '=?'
        },
        link: function(scope, element) {
            scope.user = scope.user || {};
            scope.user.role = scope.user.role || 'USER_ROLE_REGULAR';
            AuthService.getUser().then(function(user) {
                scope.userId = user.data.userId;
            });

            scope.cancelEditing = function() {
                element.remove();
                $rootScope.$broadcast('user-management-change');
            };

            scope.saveUser = function() {
                if (!scope.isValidUsername() || !scope.user.user.fullName)
                    return;

                var save = function() {
                    if (scope.saving) return;
                    scope.saving = true;

                    var newUser = scope.user;

                    if (scope.user.user.userId) {
                        Backend.POST('/account/update-user', newUser).then(function() {
                            scope.editing = false;
                            scope.saving = false;
                            $rootScope.$broadcast('user-management-change');
                        });
                    }
                    else {
                        AccountService.getUsers().then(function(accountUsers) {
                            var accountUsernames = _.map(accountUsers, function(u) { return u.user.username; });
                            if (accountUsernames.indexOf(scope.user.user.username) !== -1) {
                                alert('The user is already associated with this account.');
                                scope.saving = false;
                            }
                            else {
                                Backend.POST('/account/new-user', {
                                    username: scope.user.user.username,
                                    fullName: scope.user.user.fullName,
                                    role: scope.user.role,
                                    accountId: scope.account
                                }).then(function() {
                                    scope.editing = false;
                                    scope.saving = false;
                                    $rootScope.$broadcast('user-management-change');
                                }).catch(function(res) {
                                    var errorMessage = _.get(res, 'data');
                                    if (errorMessage && typeof errorMessage === 'string')
                                        alert(errorMessage);
                                    else
                                        alert('There was an error trying to create new user');
                                    scope.saving = false;
                                });
                            }
                        });
                    }
                };

                // check if user is in a different domain
                UserService.getSummary().then(function(summary) {
                    var username = summary.data.username;
                    var currentDomain = username.substr(username.indexOf('@') + 1);

                    var newUsername = scope.user.user.username;
                    var newEmailDomain = newUsername.substr(newUsername.indexOf('@') + 1);

                    if (newEmailDomain !== currentDomain) {
                        if ($window.confirm('You are adding a user from another domain.\nAre you sure ?')) {
                            save();
                        }
                    }
                    else {
                        save();
                    }
                });
            };

            scope.deleteUser = function() {
                if (!$window.confirm('Are you sure you want to delete the user "' + scope.user.user.username + '" ?'))
                    return;

                Backend.DELETE('/account/users/' + scope.user.user.userId).then(function() {
                    $rootScope.$broadcast('user-management-change');
                }).catch(function() {
                    alert('Failed to delete user from account.');
                });
            };

            scope.suspendUser = function() {
                var action = scope.user.active ? 'suspend' : 'unsuspend';

                if (!$window.confirm([ 'Are you sure you want to ', action, ' this user?' ].join('')))
                    return;

                var endpoint = [ '/account/users/', scope.user.user.userId, '/', action ].join('');

                Backend.POST(endpoint, scope.user.user).then(function() {
                    $rootScope.$broadcast('user-management-change');
                }).catch(function() {
                    alert([ 'Failed to ', action, ' user.' ].join(''));
                });
            };

            scope.isValidUsername = function() {
                var re = /^([\w-+]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,30}(?:\.[a-z]{2,30})?)$/i;
                return re.test(scope.user.user.username);
            };

            scope.editUser = function() {
                scope.editing = true;
                scope.existingUserEdit = true;
            };
        }
    };
});
/* origin: public/webapp/directives/validators/custom-form-validator.js */
angular.module('webApp').directive('customFormValidation', function () {
    return {

        restrict: 'A',
        scope: true,
        require: 'ngModel',

        link: function (scope, element, attr, ctrl) {

            var validationWatcher = scope.$watch(attr['customFormValidation'], function (newVal) {
                ctrl.$setValidity('customFormValidation', newVal);
            });

            scope.$on('$destroy', function () {
                if (validationWatcher)
                    validationWatcher();
            });

        }
    };
});
/* origin: public/webapp/factories/logz-focus.js */
angular.module('webApp').factory('Focus', function ($rootScope, $timeout) {
    return function(name) {
        $timeout(function (){
            $rootScope.$broadcast('focusOn', name);
        });
    };
});
/* origin: public/webapp/factories/wait-until.js */
angular.module('webApp').factory('WaitUntil', function ($q, $timeout) {


    /** wait until the executed promise resolved to a true value,
     *  execute it every x milliseconds and stop after y milliseconds
     *  example
     *  var later = +Date.now() + 5000;
     *  WaitUntil()
     *      .stopAfter(30 * 1000)
     *      .tryEvery(2 *1000)
     *      .execute(function () {
     *         var promise = Q.defer()
     *         if (+Date.now() >= later) {
     *             promise.resolve('wow'); //some true value
     *         } else {
     *             promise.resolve(false);
     *         }
     *         return promise.promise;
     *      })
     *      .then(function () {
     *             console.log('YEY')
     *      })
     *      .catch(function(){
     *             console.log('AYY')
     *      });
     *
     * @options {object} - optional option object
     */
    function Wait(options) {
        options = options || {};
        this._interval = options.interval || 1000;
        this._timeout = options.timeout || 20 * 1000;
        this._isWaiting = false;
        this.defer = $q.defer();
    }

    Wait.prototype = {
        tryEvery: function (interval) {
            this._interval = interval;
            return this;
        },
        stopAfter: function (timeout) {
            this._timeout = timeout;
            return this;
        },
        execute: function (execute) {
            this.executeFn = execute;
            this.start = Date.now();
            this._isWaiting = true;

            this._runFunction();

            return this.defer.promise;
        },
        getPromise: function () {
            return this.defer.promise;
        },
        isWaiting: function() {
            return this._isWaiting;
        },
        _shouldStopTrying: function () {
            return (Date.now() - this.start) > this._timeout;
        },
        _runFunction: function () {
            var self = this;

            if (self._shouldStopTrying()) {
                return this.defer.reject('Failed to wait');
            }

            self.executeFn().then(function (result) {
                if (result) {
                    self.defer.resolve(result);
                }
                else {
                    $timeout(function () {
                        self._runFunction();
                    }, self._interval);
                }
            });
        }
    };

    return Wait;
});





/* origin: public/webapp/filters/capitalize.js */
angular.module('webApp').filter('capitalize', function() {
    return _.capitalize;
});


/* origin: public/webapp/filters/date-format.js */
angular.module('webApp').filter('momentDateFormat', function () {
    return function (date, format) {
        return moment(date).format(format).toString();
    };
});

/* origin: public/webapp/filters/minutes-to-friendly-frequency-display.js */
angular.module('webApp').filter('minutesToFriendlyFrequencyDisplay', function () {
    var createUnitsString = function (amount, unitName) {
        return [ amount, ' ', unitName, amount > 1 ? 's' : '' ].join('');
    };

    var addUnitsStringAndSubtractAmount = function (minutesAmount, amountOfMinutesToUnit, unitName, frequencyFriendlyDisplayArr) {
        var unitsAmount = Math.floor(minutesAmount / amountOfMinutesToUnit);
        if (unitsAmount > 0) {
            minutesAmount -= unitsAmount * amountOfMinutesToUnit;
            frequencyFriendlyDisplayArr.push(createUnitsString(unitsAmount, unitName));
        }

        return minutesAmount;
    };

    return function (minutesAmount) {
        var frequencyFriendlyDisplayArr = [];

        minutesAmount = addUnitsStringAndSubtractAmount(minutesAmount, 1440, 'day', frequencyFriendlyDisplayArr);
        minutesAmount = addUnitsStringAndSubtractAmount(minutesAmount, 60, 'hour', frequencyFriendlyDisplayArr);

        if (minutesAmount > 0) {
            frequencyFriendlyDisplayArr.push(createUnitsString(minutesAmount, 'minute'));
        }

        var frequencyFriendlyDisplay = frequencyFriendlyDisplayArr.join(', ');
        var lastCommaIndex = frequencyFriendlyDisplay.lastIndexOf(',');
        if (lastCommaIndex > 0) {
            // Replace the last comma ',' with 'and' - eg: '1 day, 5 hours, 2 minutes' => '1 day, 5 hours and 2 minutes'
            frequencyFriendlyDisplay = [ frequencyFriendlyDisplay.substr(0, lastCommaIndex), frequencyFriendlyDisplay.substr(lastCommaIndex + 1) ].join(' and');
        }

        return frequencyFriendlyDisplay;
    };
});

/* origin: public/webapp/filters/range-filter.js */
angular.module('webApp').filter('range', function() {
    return function(input, start, end) {
        if (!end) {
            end = +start;
            start = 0;
        }
        else {
            end = +end ;
            start = +start;
        }

        for (var i=start; i<end; i++) {
            input.push(i);
        }

        return input;
    };
});
/* origin: public/webapp/filters/trust-as-html.js */
angular.module('webApp').filter('trustAsHtml', function($sce) {
    return $sce.trustAsHtml;
});

/* origin: public/webapp/filters/white-space-characters.js */
angular.module('webApp').filter('whiteSpaceCharacters', function () {
    return function (text, show) {
        if (!text || !text.replace) {
            return text;
        }

        return show
            ? text.replace(/\r/g, '\\r').replace(/\n/g, '\\n')
            : text;
    };
});

/* origin: public/webapp/models/account.model.js */
angular.module('webApp').factory('Account', function (UserService, UpgradeService, sharedObjects, AccountService) {

    var Account = function (options) {
        options = options || {};

        this.id = options.id || null;
        this.name = options.name || 'New sub-account';
        this.token = options.token;
        this.setIsMain(options.isMain || false);
        this.subAccounts = this.getIsMain() ? [] : null;
        this.volumeGB = options.volumeGB || 0;

        // Searchable and accessible are only relevant to sub-accounts
        this.isSearchable = this.getIsMain() ? false : (options.isSearchable || false);
        this.isAccessible = this.getIsMain() ? false : (options.isAccessible || false);

        this.setSharingObjectsAccounts(options.sharingObjectsAccounts || []);
        this.retentionDays = options.retentionDays || 0;
        this.setDailyUsage(options.dailyUsage);
        this.parent = options.parent || null;
        if (this.token || options.isMain) {
            this.color = this._allocateColor();
        }
    };

    Account.prototype = {
        ERR_NOT_A_MAIN_ACCOUNT: 'Received account is not a main account',

        // For the pie chart in 'Managed Accounts'
        colorsList: ['#79B338', '#445A64', '#7CD6FF', '#0B73D4', '#BCBCBC', '#A1867D'],
        colorIndex: 0,

        getMain: function () {
            return this.getIsMain() ? this : this.parent;
        },

        getIsMain: function () {
            return this._isMain;
        },

        setIsMain: function (value) {
            this._isMain = value;
            this._isSub = !value;
        },

        getIsSub: function () {
            return this._isSub;
        },

        setIsSub: function (value) {
            this._isSub = value;
            this._isMain = !value;
        },

        /**
         * Set which accounts we share object to
         * @param value - Int[] - A list of ids of the accounts we share objects with
         */
        setSharingObjectsAccounts: function (value) {
            this.sharingObjectsAccounts = value;
            this.isSharingObj = this.sharingObjectsAccounts && this.sharingObjectsAccounts.length;
        },

        /**
         * Allocate a color for the account by the order of the accounts created
         * @return {Color}
         * @private
         */
        _allocateColor: function () {
            return Account.prototype.colorsList[Account.prototype.colorIndex++ % Account.prototype.colorsList.length];
        },

        _throwIfNotMain: function () {
            if (!this.getIsMain()) {
                throw new Error(this.ERR_NOT_A_MAIN_ACCOUNT);
            }
        },

        setDailyUsage: function (dailyUsages) {
            this.dailyUsage = dailyUsages || 0;

            this.maxDailyUsage = _.maxBy(this.dailyUsage, 'bytes') || {bytes: 0};
            this.maxDailyUsage.humanReadableBytes = window.LogzIO.formatBytes(this.maxDailyUsage.bytes);
        },

        getFlatAccountList: function () {
            return this.getIsMain() ? _.flatten([this, this.subAccounts]) : _.flatten([this.parent, this.parent.subAccounts]);
        },

        deleteExistingAccountById: function (id) {
            var main = this.getMain();
            _.remove(main.subAccounts, {id: id});
        },

        /**
         * If the account exists in the tree (as the main or one of the sub-accounts), grab it.
         */
        getExistingAccountById: function (id) {
            return _.find(this.getFlatAccountList(), {id: id}) || null;
        },

        delete: function () {
            var self = this;
            return AccountService.deleteSubAccount(self.id)
                .then(function (response) {
                    self.deleteExistingAccountById(self.id);
                    self._calculateAvailableVolumeGBForAccount(self);

                    return response;
                });
        },

        update: function () {
            return this.getIsMain() ? this._updateMain() : this._updateSub();
        },

        createSubAccount: function () {
            var self = this;

            var postObject = {
                accessible: self.isAccessible,
                accountName: self.name,
                maxDailyGB: self.volumeGB,
                retentionDays: self.retentionDays,
                searchable: self.isSearchable,
                sharingObjectsAccounts: self.sharingObjectsAccounts
            };
            return AccountService.createSubAccount(postObject)
                .then(function (responseSubAccount) {
                    var main = self.getMain();
                    var account = self._getAccountFromRaw(responseSubAccount, main);

                    main.subAccounts.push(account);

                    return account;
                });
        },

        _updateMain: function () {
            var self = this;

            return AccountService.updateMainAccount(self.name, self.sharingObjectsAccounts)
                .then(function (res) {
                    self.setSharingObjectsAccounts(self.sharingObjectsAccounts);

                    return res;
                });
        },

        _updateSub: function () {
            var self = this;

            var putObject = {
                accessible: self.isAccessible,
                accountName: self.name,
                maxDailyGB: self.volumeGB,
                retentionDays: self.retentionDays,
                searchable: self.isSearchable,
                sharingObjectsAccounts: self.sharingObjectsAccounts
            };

            return AccountService.updateSubAccount(self.id, putObject)
                .then(function (res) {
                    self.setSharingObjectsAccounts(self.sharingObjectsAccounts);
                    self._calculateAvailableVolumeGBForAccount(self);

                    return res;
                });
        },

        /**
         * Calculate how much volume we have to allocate to other sub-accounts
         * @param account - The account on which we calculate
         * @return {Account} - The same account as the param
         * @private
         */
        _calculateAvailableVolumeGBForAccount: function (account) {
            var accountRef = account.getIsMain() ? account : account.parent;

            accountRef.volumeGB = accountRef.overallVolumeGB - (_.sumBy(accountRef.subAccounts, 'volumeGB'));

            return account;
        },

        /******************************************************************************************************
         *                                      Create Main Account Tree                                      *
         ******************************************************************************************************/

        createAccountTree: function () {
            // Reset the index (going to another place and returning will give different colors)
            this.colorIndex = 0;

            var account = new Account({
                isMain: true
            });

            return this.createAccountTreeForAccount(account);
        },

        createAccountTreeForAccount: function(account) {
            return this._getMainAccountSummary(account)
                .then(this._getSubAccounts)
                .then(this._getMainAccountPlanDetails)
                .then(this._getMainAccountSharingAccount)
                .then(this._calculateAvailableVolumeGBForAccount)
                .then(this._getMainDailyUsage);
        },

        _getMainAccountSummary: function (account) {
            return UserService.getSummary()
                .then(function (res) {
                    if (res.data.subAccount) {
                        throw new Error(self.ERR_ZERO_MANAGED_ACCOUNTS);
                    }

                    account.id = res.data.accountId;
                    account.name = res.data.accountName;
                    account.token = res.data.accountToken;

                    return account;
                });
        },

        _getMainAccountPlanDetails: function (account) {
            return UpgradeService.getPlanDetails()
                .then(function (res) {
                    account.maxSubAccounts = res.data.maxSubAccounts;
                    account.retentionDays = res.data.retentionDays;
                    account.overallVolumeGB = res.data.maxDailyGB;

                    return account;
                });
        },


        _getMainAccountSharingAccount: function (account) {
            account._throwIfNotMain();

            return sharedObjects.getSharingAccounts()
                .then(function (sharingObjectsAccounts) {
                    account.setSharingObjectsAccounts(_.map(sharingObjectsAccounts, 'accountId'));

                    return account;
                });
        },

        _getMainDailyUsage: function (account) {
            return UserService.getUsage()
                .then(function (usage) {
                    account.setDailyUsage(usage.slice(0, 7));

                    return account;
                });
        },

        /***
         * Creates an account from a server response
         * @param rawData - the response data object
         * @param mainAccount - the parent (main account) of the current account - if exists
         * @returns {Account} - new Account instance
         * @private
         */
        _getAccountFromRaw: function (rawData, mainAccount) {
            return new Account({
                id: rawData.account.accountId,
                name: rawData.account.accountName,
                token: rawData.account.accountToken,
                retentionDays: rawData.account.retentionDays,
                isMain: false,
                volumeGB: rawData.account.maxDailyGB,
                isSearchable: rawData.subAccountRelation.searchable,
                isAccessible: rawData.subAccountRelation.accessible,
                sharingObjectsAccounts: _.map(rawData.sharingObjectsAccounts, 'accountId'),
                dailyUsage: rawData.dailyUsagesList.usage.slice(0, 7),
                parent: mainAccount
            });
        },

        _getSubAccounts: function (account) {
            return AccountService.getSubAccounts()
                .then(function (subAccountsRes) {
                    subAccountsRes.map(function (accountRes) {
                        account.subAccounts.push(account._getAccountFromRaw(accountRes, account));
                    });

                    return account;
                });
        }


    };

    return Account;
});
/* origin: public/webapp/modules/customFilters.js */
var customFiltersApp = angular.module('customFilters', []);

/*group by key
collection is the array to be filtered
field is the key property to be grouped by : pass as string
*/
customFiltersApp.filter('groupByFilter', function() {
    return _.memoize(function(collection, field) { //records the result of func - invoke if input is changed
        return _.groupBy(collection, function(item) {
            return item[field]; //field to be grouped by
        });
    }, function resolver(collection, field) {
        return collection.length + field; //save the result in the cache with this key
    });
});

customFiltersApp.filter('toArray', function() {
    return function(obj) {
        if (!(obj instanceof Object))
            return obj;

        return Object.keys(obj).filter(function(key) {
            if (key.charAt(0) !== '$') {
                return key;
            }
        }).map(function(key) {
            return Object.defineProperty(obj[key], '$key', {__proto__: null, value: obj[key].value });
        });
    };
});

/* origin: public/webapp/modules/rison.js */
//////////////////////////////////////////////////
//
//  the stringifier is based on
//    http://json.org/json.js as of 2006-04-28 from json.org
//  the parser is based on
//    http://osteele.com/sources/openlaszlo/json
//

if (typeof rison == 'undefined')
    window.rison = {};

/**
 *  rules for an uri encoder that is more tolerant than encodeURIComponent
 *
 *  encodeURIComponent passes  ~!*()-_.'
 *
 *  we also allow              ,:@$/
 *
 */
rison.uri_ok = {  // ok in url paths and in form query args
    '~': true,  '!': true,  '*': true,  '(': true,  ')': true,
    '-': true,  '_': true,  '.': true,  ',': true,
    ':': true,  '@': true,  '$': true,
    "'": true,  '/': true
};

/*
 * we divide the uri-safe glyphs into three sets
 *   <rison> - used by rison                         ' ! : ( ) ,
 *   <reserved> - not common in strings, reserved    * @ $ & ; =
 *
 * we define <identifier> as anything that's not forbidden
 */

/**
 * punctuation characters that are legal inside ids.
 */
// this var isn't actually used
//rison.idchar_punctuation = "_-./~";

(function () {
    var l = [];
    for (var hi = 0; hi < 16; hi++) {
        for (var lo = 0; lo < 16; lo++) {
            if (hi+lo == 0) continue;
            var c = String.fromCharCode(hi*16 + lo);
            if (! /\w|[-_.\/~]/.test(c))
                l.push('\\u00' + hi.toString(16) + lo.toString(16));
        }
    }
    /**
     * characters that are illegal inside ids.
     * <rison> and <reserved> classes are illegal in ids.
     *
     */
    rison.not_idchar = l.join('')
    //idcrx = new RegExp('[' + rison.not_idchar + ']');
    //console.log('NOT', (idcrx.test(' ')) );
})();
//rison.not_idchar  = " \t\r\n\"<>[]{}'!=:(),*@$;&";
rison.not_idchar  = " '!:(),*@$";


/**
 * characters that are illegal as the start of an id
 * this is so ids can't look like numbers.
 */
rison.not_idstart = "-0123456789";


(function () {
    var idrx = '[^' + rison.not_idstart + rison.not_idchar +
        '][^' + rison.not_idchar + ']*';

    rison.id_ok = new RegExp('^' + idrx + '$');

    // regexp to find the end of an id when parsing
    // g flag on the regexp is necessary for iterative regexp.exec()
    rison.next_id = new RegExp(idrx, 'g');
})();

/**
 * this is like encodeURIComponent() but quotes fewer characters.
 *
 * @see rison.uri_ok
 *
 * encodeURIComponent passes   ~!*()-_.'
 * rison.quote also passes   ,:@$/
 *   and quotes " " as "+" instead of "%20"
 */
rison.quote = function(x) {
    if (/^[-A-Za-z0-9~!*()_.',:@$\/]*$/.test(x))
        return x;

    return encodeURIComponent(x)
        .replace('%2C', ',', 'g')
        .replace('%3A', ':', 'g')
        .replace('%40', '@', 'g')
        .replace('%24', '$', 'g')
        .replace('%2F', '/', 'g')
        .replace('%20', '+', 'g');
};


//
//  based on json.js 2006-04-28 from json.org
//  license: http://www.json.org/license.html
//
//  hacked by nix for use in uris.
//

(function () {
    var sq = { // url-ok but quoted in strings
            "'": true,  '!': true
        },
        s = {
            array: function (x) {
                var a = ['!('], b, f, i, l = x.length, v;
                for (i = 0; i < l; i += 1) {
                    v = x[i];
                    f = s[typeof v];
                    if (f) {
                        v = f(v);
                        if (typeof v == 'string') {
                            if (b) {
                                a[a.length] = ',';
                            }
                            a[a.length] = v;
                            b = true;
                        }
                    }
                }
                a[a.length] = ')';
                return a.join('');
            },
            'boolean': function (x) {
                if (x)
                    return '!t';
                return '!f'
            },
            'null': function (x) {
                return "!n";
            },
            number: function (x) {
                if (!isFinite(x))
                    return '!n';
                // strip '+' out of exponent, '-' is ok though
                return String(x).replace(/\+/,'');
            },
            object: function (x) {
                if (x) {
                    if (x instanceof Array) {
                        return s.array(x);
                    }
                    // WILL: will this work on non-Firefox browsers?
                    if (typeof x.__prototype__ === 'object' && typeof x.__prototype__.encode_rison !== 'undefined')
                        return x.encode_rison();

                    var a = ['('], b, f, i, v, ki, ks=[];
                    for (i in x)
                        ks[ks.length] = i;
                    ks.sort();
                    for (ki = 0; ki < ks.length; ki++) {
                        i = ks[ki];
                        v = x[i];
                        f = s[typeof v];
                        if (f) {
                            v = f(v);
                            if (typeof v == 'string') {
                                if (b) {
                                    a[a.length] = ',';
                                }
                                a.push(s.string(i), ':', v);
                                b = true;
                            }
                        }
                    }
                    a[a.length] = ')';
                    return a.join('');
                }
                return '!n';
            },
            string: function (x) {
                if (x == '')
                    return "''";

                if (rison.id_ok.test(x))
                    return x;

                x = x.replace(/(['!])/g, function(a, b) {
                    if (sq[b]) return '!'+b;
                    return b;
                });
                return "'" + x + "'";
            },
            undefined: function (x) {
                throw new Error("rison can't encode the undefined value");
            }
        };


    /**
     * rison-encode a javascript structure
     *
     *  implemementation based on Douglas Crockford's json.js:
     *    http://json.org/json.js as of 2006-04-28 from json.org
     *
     */
    rison.encode = function (v) {
        return s[typeof v](v);
    };

    /**
     * rison-encode a javascript object without surrounding parens
     *
     */
    rison.encode_object = function (v) {
        if (typeof v != 'object' || v === null || v instanceof Array)
            throw new Error("rison.encode_object expects an object argument");
        var r = s[typeof v](v);
        return r.substring(1, r.length-1);
    };

    /**
     * rison-encode a javascript array without surrounding parens
     *
     */
    rison.encode_array = function (v) {
        if (!(v instanceof Array))
            throw new Error("rison.encode_array expects an array argument");
        var r = s[typeof v](v);
        return r.substring(2, r.length-1);
    };

    /**
     * rison-encode and uri-encode a javascript structure
     *
     */
    rison.encode_uri = function (v) {
        return rison.quote(s[typeof v](v));
    };

})();




//
// based on openlaszlo-json and hacked by nix for use in uris.
//
// Author: Oliver Steele
// Copyright: Copyright 2006 Oliver Steele.  All rights reserved.
// Homepage: http://osteele.com/sources/openlaszlo/json
// License: MIT License.
// Version: 1.0


/**
 * parse a rison string into a javascript structure.
 *
 * this is the simplest decoder entry point.
 *
 *  based on Oliver Steele's OpenLaszlo-JSON
 *     http://osteele.com/sources/openlaszlo/json
 */
rison.decode = function(r) {
    var errcb = function(e) { throw Error('rison decoder error: ' + e); };
    var p = new rison.parser(errcb);
    return p.parse(r);
};

/**
 * parse an o-rison string into a javascript structure.
 *
 * this simply adds parentheses around the string before parsing.
 */
rison.decode_object = function(r) {
    return rison.decode('('+r+')');
};

/**
 * parse an a-rison string into a javascript structure.
 *
 * this simply adds array markup around the string before parsing.
 */
rison.decode_array = function(r) {
    return rison.decode('!('+r+')');
};


/**
 * construct a new parser object for reuse.
 *
 * @constructor
 * @class A Rison parser class.  You should probably
 *        use rison.decode instead.
 * @see rison.decode
 */
rison.parser = function (errcb) {
    this.errorHandler = errcb;
};

/**
 * a string containing acceptable whitespace characters.
 * by default the rison decoder tolerates no whitespace.
 * to accept whitespace set rison.parser.WHITESPACE = " \t\n\r\f";
 */
rison.parser.WHITESPACE = "";

// expose this as-is?
rison.parser.prototype.setOptions = function (options) {
    if (options['errorHandler'])
        this.errorHandler = options.errorHandler;
};

/**
 * parse a rison string into a javascript structure.
 */
rison.parser.prototype.parse = function (str) {
    this.string = str;
    this.index = 0;
    this.message = null;
    var value = this.readValue();
    if (!this.message && this.next())
        value = this.error("unable to parse string as rison: '" + rison.encode(str) + "'");
    if (this.message && this.errorHandler)
        this.errorHandler(this.message, this.index);
    return value;
};

rison.parser.prototype.error = function (message) {
    if (typeof(console) != 'undefined')
        console.log('rison parser error: ', message);
    this.message = message;
    return undefined;
}

rison.parser.prototype.readValue = function () {
    var c = this.next();
    var fn = c && this.table[c];

    if (fn)
        return fn.apply(this);

    // fell through table, parse as an id

    var s = this.string;
    var i = this.index-1;

    // Regexp.lastIndex may not work right in IE before 5.5?
    // g flag on the regexp is also necessary
    rison.next_id.lastIndex = i;
    var m = rison.next_id.exec(s);

    // console.log('matched id', i, r.lastIndex);

    if (m.length > 0) {
        var id = m[0];
        this.index = i+id.length;
        return id;  // a string
    }

    if (c) return this.error("invalid character: '" + c + "'");
    return this.error("empty expression");
}

rison.parser.parse_array = function (parser) {
    var ar = [];
    var c;
    while ((c = parser.next()) != ')') {
        if (!c) return parser.error("unmatched '!('");
        if (ar.length) {
            if (c != ',')
                parser.error("missing ','");
        } else if (c == ',') {
            return parser.error("extra ','");
        } else
            --parser.index;
        var n = parser.readValue();
        if (typeof n == "undefined") return undefined;
        ar.push(n);
    }
    return ar;
};

rison.parser.bangs = {
    t: true,
    f: false,
    n: null,
    '(': rison.parser.parse_array
}

rison.parser.prototype.table = {
    '!': function () {
        var s = this.string;
        var c = s.charAt(this.index++);
        if (!c) return this.error('"!" at end of input');
        var x = rison.parser.bangs[c];
        if (typeof(x) == 'function') {
            return x.call(null, this);
        } else if (typeof(x) == 'undefined') {
            return this.error('unknown literal: "!' + c + '"');
        }
        return x;
    },
    '(': function () {
        var o = {};
        var c;
        var count = 0;
        while ((c = this.next()) != ')') {
            if (count) {
                if (c != ',')
                    this.error("missing ','");
            } else if (c == ',') {
                return this.error("extra ','");
            } else
                --this.index;
            var k = this.readValue();
            if (typeof k == "undefined") return undefined;
            if (this.next() != ':') return this.error("missing ':'");
            var v = this.readValue();
            if (typeof v == "undefined") return undefined;
            o[k] = v;
            count++;
        }
        return o;
    },
    "'": function () {
        var s = this.string;
        var i = this.index;
        var start = i;
        var segments = [];
        var c;
        while ((c = s.charAt(i++)) != "'") {
            //if (i == s.length) return this.error('unmatched "\'"');
            if (!c) return this.error('unmatched "\'"');
            if (c == '!') {
                if (start < i-1)
                    segments.push(s.slice(start, i-1));
                c = s.charAt(i++);
                if ("!'".indexOf(c) >= 0) {
                    segments.push(c);
                } else {
                    return this.error('invalid string escape: "!'+c+'"');
                }
                start = i;
            }
        }
        if (start < i-1)
            segments.push(s.slice(start, i-1));
        this.index = i;
        return segments.length == 1 ? segments[0] : segments.join('');
    },
    // Also any digit.  The statement that follows this table
    // definition fills in the digits.
    '-': function () {
        var s = this.string;
        var i = this.index;
        var start = i-1;
        var state = 'int';
        var permittedSigns = '-';
        var transitions = {
            'int+.': 'frac',
            'int+e': 'exp',
            'frac+e': 'exp'
        };
        do {
            var c = s.charAt(i++);
            if (!c) break;
            if ('0' <= c && c <= '9') continue;
            if (permittedSigns.indexOf(c) >= 0) {
                permittedSigns = '';
                continue;
            }
            state = transitions[state+'+'+c.toLowerCase()];
            if (state == 'exp') permittedSigns = '-';
        } while (state);
        this.index = --i;
        s = s.slice(start, i)
        if (s == '-') return this.error("invalid number");
        return Number(s);
    }
};
// copy table['-'] to each of table[i] | i <- '0'..'9':
(function (table) {
    for (var i = 0; i <= 9; i++)
        table[String(i)] = table['-'];
})(rison.parser.prototype.table);

// return the next non-whitespace character, or undefined
rison.parser.prototype.next = function () {
    var s = this.string;
    var i = this.index;
    do {
        if (i == s.length) return undefined;
        var c = s.charAt(i++);
    } while (rison.parser.WHITESPACE.indexOf(c) >= 0);
    this.index = i;
    return c;
};
/* origin: public/webapp/modules/utils.js */
var dateApp = angular.module('utils', []);

dateApp.service('dateService', function() {

    var addLeadingZero = function(num, numZero) {
        if  (num <= 9) {
            return Array(++numZero).join('0') + num;
        }
        else if (num <= 99) {
            return Array(numZero).join('0') + num;
        }
        else {
            return num;
        }

    };

    var formatTimestamp = function(time) {
        var time = new Date(time);
        return time.getDate() + '/' + addLeadingZero(time.getMonth() + 1, 1) + '/' + time.getFullYear() + ' ' + addLeadingZero(time.getHours(), 1) + ':' + addLeadingZero(time.getMinutes(), 1) + ':' + addLeadingZero(time.getSeconds(), 1);
    };

    //format time for query in kibana query
    var formatTimestampUTC = function(time) {
        var date = new Date(time);
        return date.getUTCFullYear() + '-' + addLeadingZero(date.getUTCMonth() + 1, 1) + '-' +
            addLeadingZero(date.getUTCDate(), 1) + 'T' + addLeadingZero(date.getUTCHours(), 1) + ':' + addLeadingZero(date.getUTCMinutes(), 1) + ':'
            + addLeadingZero(date.getUTCSeconds(), 1) + '.' + addLeadingZero(date.getUTCMilliseconds(), 2) + 'Z';
    };


    return {
        formatTimestamp: formatTimestamp,
        formatTimestampUTC: formatTimestampUTC
    };

});

/* origin: public/webapp/reimg.js */

window.ReImg = {

    OutputProcessor: function(encodedData) {
        return {
            toBase64: function() {
                return encodedData;
            },
            toImg: function() {
                var imgElement = document.createElement('img');
                imgElement.src = 'data:image/svg+xml;base64,' + encodedData;
                return imgElement;
            },
            toCanvas: function(callback) {
                // https://gist.github.com/gustavohenke/9073132
                var canvas = document.createElement('canvas');
                var canvasCtx = canvas.getContext('2d');

                var img = this.toImg();
                img.onload = function() {
                    canvasCtx.drawImage(img, 0, 0);
                    callback(canvas);
                };
            },
            downloadPng: function() {
                // http://stackoverflow.com/questions/6796974/force-download-an-image-using-javascript
                this.toCanvas(function(canvas) {
                    var imageData = canvas.toDataURL('image/png;base64');
                    imageData.replace('image/png', 'image/octet-stream');
                    window.location.href = imageData;
                });
            }
        };
    },

    fromSvg: function(svgElement) {
        var svgString = new XMLSerializer().serializeToString(svgElement);
        return new this.OutputProcessor(window.btoa(svgString));
    }

};
/* origin: public/webapp/services/account.service.js */
angular.module('webApp').service('AccountService', function($rootScope, $q, $window, AuthService, Backend, cacheService,
    enums) {

    var self = this;
    var ACCOUNT_STATES = enums.ACCOUNT_STATES;
    self.ACCOUNT_CREATION_STATES = {
        CREATED: 'AS_CREATED',
        READY: 'AS_READY',
        BASE: 'AS_BASE'
    };

    var accountSettingsCacheKey = 'account_settings';

    self.deleteSubAccount = function (accountId) {
        return Backend.DELETE('/account/sub-accounts/' + accountId);
    };

    self.updateSubAccount = function (accountId, postData) {
        return Backend.PUT('/account/sub-accounts/' + accountId, postData);
    };

    self.updateMainAccount = function (name, sharedAccountIds) {
        return Backend.PUT('/account/owner-account', {
            accountName: name,
            sharingAccountIds: sharedAccountIds
        });
    };

    self.createSubAccount = function (postData) {
        return Backend.POST('/account/sub-accounts', postData).then(function(resp) {
            return resp.data;
        });
    };

    self.getSubAccounts = function () {
        return Backend.GET('/account/sub-accounts').then(function(resp) {
            return resp.data;
        });
    };


    var _accountLogTypesEndpoint = '/account/log-types';

    self.clearAccountLogTypesCache  = function () {
        cacheService.clear(_accountLogTypesEndpoint);
    };

    self.getAccountLogTypes = function () {
        return cacheService.get(_accountLogTypesEndpoint, function() {
            return AuthService.getUser().then(function() {
                return Backend.GET(_accountLogTypesEndpoint).then(function (res) {
                    return res.data;
                });
            });
        }, 5 * 60); // cache for 5 min
    };


    var _accountFieldsEndpoint = '/account/fields';

    self.clearAccountFieldsCache = function () {
        cacheService.getAllItems().forEach(function(item) {
            if (item.indexOf([ 'logzCache.', _accountFieldsEndpoint ].join('')) !== 0) {
                return;
            }

            cacheService.clear(item.replace('logzCache.', ''));
        });
    };

    self.getAccountFieldsByType = function (logType, size) {
        size = size || 3000;
        var queryString = logType
            ? [ '&logType=', logType ].join('')
            : '';
        var endpointName = [ _accountFieldsEndpoint, '?size=', size, queryString ].join('');

        return cacheService.get(endpointName, function() {
            return Backend.GET(endpointName);
        }, 5 * 60); // cache for 5 min
    };


    self.getAccountSettings = function () {
        if (!AuthService.isAuthenticated()) {
            return $q.when({});
        }

        // TODO: use the cache service instead!
        var settings = $window.sessionStorage.getItem(accountSettingsCacheKey);
        if (settings) {
            return $q.when(JSON.parse(settings));
        }
        var deferred = $q.defer();
        Backend.GET('/account-settings').then(function(accountSettings) {
            $window.sessionStorage.setItem(accountSettingsCacheKey, JSON.stringify(accountSettings.data));
            var settings = accountSettings.data;
            deferred.resolve(settings);
        });
        return deferred.promise;
    };


    $rootScope.$on('logzio:account_settings_updated', function() {
        // invalidate account settings cache
        $window.sessionStorage.removeItem(accountSettingsCacheKey);
    });

    self.listAccounts = function (from, size, filter) {
        from = from || 0;
        size = size || 20; // todo: remove this when we fix all calls to this

        var cacheKey = 'accounts-list_' + from + '_' + size;
        var queryObject = {
            from: from,
            size: size
        };

        if (filter && filter.planType !== 0) {
            cacheKey += '_' + filter.planType;
            queryObject.filter = filter;
        }

        return cacheService.get(cacheKey, function() {
            return Backend.POST('/__admin__/accounts/list', queryObject).then(function(resp) {
                return resp.data;
            });
        }, 60 * 30); // save this for 30min
    };

    self.clearAccountListCache = function () {
        cacheService.getAllItems().forEach(function(item) {
            if (item.indexOf('logzCache.accounts-list') === 0)
                cacheService.clear(item.replace('logzCache.', ''));
        });
    };

    self.searchAccounts = function (from, size, query, filter) {
        from = from || 0;
        size = size || 20;

        var searchObject = {
            from: from,
            size: size,
            q: query
        };

        // check if search term is just a number
        if (parseInt(query).toString() === query.toString()) {
            searchObject.accountId = parseInt(query);
        }

        if (filter && filter.planType !== 0)
            searchObject.filter = filter;

        return Backend.POST('/__admin__/accounts/search', searchObject).then(function(resp) {
            return resp.data;
        });
    };

    self.updateAccount = function (accountId, newState) {
        return Backend.POST('/__admin__/account', {
            accountId: accountId,
            block: (newState === ACCOUNT_STATES.BLOCKED)
        });
    };

    self.deleteAccount = function (accountId) {
        return Backend.DELETE('/__admin__/account/' + accountId);
    };

    self.getAccount = function (accountId) {
        return Backend.GET('/__admin__/account/' + accountId).then(function(res) {
            return res.data;
        });
    };

    var _getAccountUsersEndpoint = '/account/users';
    self.getUsers = function () {
        return Backend.GET(_getAccountUsersEndpoint).then(function(resp) {
            return resp.data.users;
        });
    };

    self.getCachedAccountUsers = function () {
        return cacheService.get(_getAccountUsersEndpoint, self.getUsers, 5 * 60); // cache for 5 min
    };

    self.getAccountUsers = function (accountId) {
        return Backend.GET('/__admin__/account/' + accountId + '/users').then(function(resp) {
            return resp.data.users;
        });
    };

    self.getUserAccounts = function () {
        return Backend.GET('/user/accounts').then(function(accounts) {
            return accounts.data;
        });
    };
});

/* origin: public/webapp/services/alert-wizard-service.js */
angular.module('webApp').service('AlertWizardService', function ($state, $q, $rootScope, ngDialog, AnalyticsService, localStorageService, UserService, Backend, UpgradeService, kibanaNavigator, AuthService) {
    var service = {};
    var _key = '__alertWizardData';

    service.getData = function () {
        return localStorageService.get(_key);
    };

    service.report = function (eventName, eventData) {
        eventData = eventData || {};
        eventData = _.assign(eventData, {
            category: 'alerts',
            alertDefinition: service.getData(),
        });
        eventName = ['alerts', eventName].join(':');
        AnalyticsService.report(eventName, eventData);
    };

    service.viewTriggeredAlertEvents = function (eventTimestamp, timeRangeInMinutes, alertDefinitionId, triggeredAlerts) {
        var eventName = triggeredAlerts ? 'view-in-kibana' :'view-in-kibana-from-mail';
        Backend.GET('/alerts/' + alertDefinitionId).then(function (res) {
            if (res.data && res.data.code && res.data.code === 500) {
                service.report(eventName + '-error');

                ngDialog.open({
                    template: '<p style="padding: 5px;">We could not get event for this alert, this might indicate that the alert has been deleted</p>',
                    width: '655px',
                    plain: true,
                    showClose: false
                });
                return;
            }

            service.report(eventName);

            AuthService.getUser().then(function (user) {
                kibanaNavigator.navigateToDiscover(
                    res.data.alertDefinition.query,
                    parseInt(eventTimestamp) - (1000 * 60 * parseInt(timeRangeInMinutes)),
                    parseInt(eventTimestamp),
                    res.data.alertDefinition.filter,
                    user.data.indexPrefix
                );
            });
        });
    };

    service.storeData = function (data) {
        localStorageService.set(_key, data);
    };

    service.storeDataAndOpenWizard = function (data) {
        data.senderState = $state.current.name; // In case the user will cancel operation he will be redirected to the previous state
        service.storeData(data);
        $state.go('dashboard.alerts.wizard.step1');
    };

    service.clearData = function () {
        localStorageService.remove(_key);
    };

    service.addNewEndpoint = function (endpoints, selectedRecipients) {
        var dialogScope = $rootScope.$new();
        dialogScope.notificationEndpoints = [];

        ngDialog.open({
            template: 'directives/alert-webhooks/upsert-notification-endpoint.html',
            controller: 'UpsertNotificationEndpointController',
            width: '765px',
            scope: dialogScope,
            showClose: false,
            preCloseCallback: function () {
                if (dialogScope.notificationEndpoints.length) {
                    var newEndpoint = {
                        data: dialogScope.notificationEndpoints[0],
                        name: dialogScope.notificationEndpoints[0].title
                    };
                    endpoints.push(newEndpoint);
                    selectedRecipients.push(newEndpoint);
                    service.report('add-new-endpoint');
                }
            }
        });
    };


    service.submitAlert = function (alertDefinition, alertNotificationEndpoints, alertOutputTemplate, preview) {
        var createAlertMode = alertDefinition.alertDefinitionId === undefined;

        alertOutputTemplate = alertOutputTemplate || {};
        if (alertOutputTemplate.templateType === 'JSON') {
            alertOutputTemplate = {
                templateType: 'JSON',
                fieldsConfig: null
            };
        }

        var copyAlertOutputTemplate = _.cloneDeep(alertOutputTemplate);

        if (typeof copyAlertOutputTemplate.fieldsConfig !== 'string') {
            copyAlertOutputTemplate.fieldsConfig = copyAlertOutputTemplate.fieldsConfig === null ? null : angular.toJson(copyAlertOutputTemplate.fieldsConfig);
        }

        var aggMode =  _.size(alertDefinition.aggGroupByFields) > 0 || alertDefinition.aggGroupBy || alertDefinition.aggType !== 'NONE';
        if (aggMode) copyAlertOutputTemplate.fieldsConfig = null;

        return UserService.getSummary().then(function (userSummary) {
            var copiedAlertDefinition = _.cloneDeep(alertDefinition);
            copiedAlertDefinition.accountId = userSummary.data.accountId;
            copiedAlertDefinition.username = userSummary.data.username;
            copiedAlertDefinition.annotation = copiedAlertDefinition.annotation || '';
            copiedAlertDefinition.enabled = copiedAlertDefinition.enabled || true;
            copiedAlertDefinition.deleted = copiedAlertDefinition.deleted || false;
            copiedAlertDefinition.type = copiedAlertDefinition.type || 'SCHEDULED';
            copiedAlertDefinition.lastUpdate = parseInt(new Date().getTime() / 1000);
            copiedAlertDefinition.filter = JSON.stringify(copiedAlertDefinition.filter);
            copiedAlertDefinition.notifications = JSON.stringify(copiedAlertDefinition.notifications);


            if (copiedAlertDefinition.aggGroupBy === '') {
                copiedAlertDefinition.aggGroupBy = null;
            }

            if (copiedAlertDefinition.aggGroupBy !== null && copiedAlertDefinition.aggType === 'NONE') {
                copiedAlertDefinition.aggType = 'COUNT'; // aggType NONE with aggGroupBy set should be COUNT in services, we treat it as NONE in the wizard UI
            }

            var alertModeName = createAlertMode ? 'create' : 'update';
            var postUrl = [ '/alerts/', alertModeName ].join('');
            var upsertAlertRequest = {
                detailedAlert: {
                    alertDefinition: copiedAlertDefinition,
                    alertNotificationEndpoints: alertNotificationEndpoints,
                    alertOutputTemplate : copyAlertOutputTemplate
                }
            };

            if (preview === true) {
                postUrl = '/alerts/samples';
            }

            postUrl = [postUrl, 'version=v2'].join('?'); //this param tells the backend we use the second version of alerts
            return Backend.POST(postUrl, upsertAlertRequest).then(function (res) {
                if (_.get(res, 'data.alertDefinition.enabled') === false) { // May be undefined, that's why I compare it to false instead of doing if(!...)
                    UpgradeService.showAlertDisabledDialog(true, createAlertMode);
                }
                service.report(preview ? 'preview-table' : [alertModeName, 'alert'].join('-'));
                return $q.when(res);
            });
        });
    };

    return service;
});
/* origin: public/webapp/services/analytics-service.js */
angular.module('webApp').service('AnalyticsService', function (currentEnv, Backend, UserService, AuthService, ImpersonationService, GoogleAnalyticsService, SessionService) {
    var self = this;
    self.concurrentEvents = {};

    var processCounter = 0;
    var maxProcessing = 3;      // don't allow more than 3 requests to this endpoint at a time

    self._sendUserAnalytics = function (data) {
        processCounter++;
        return Backend.POST('/user-analytics', data, { dontShowProgressBar: true })
            .finally(function() {
                processCounter--;
            });
    };

    self._createEventObject = function (eventName, eventData) {
        return {
            eventName: eventName,
            eventData: JSON.stringify(eventData),
            timestamp: new Date().toISOString(),
            sessionId: SessionService.getSessionId()
        };
    };

    self.report = function (eventName, eventData) {
        // User analytics should not crash our app on failure
        try {
            if (currentEnv() !== 'PROD' || AuthService.isAdmin()) {
                return;
            }

            var eventObject = self._createEventObject(eventName, eventData);

            if (!AuthService.isAuthenticated()) {
                // By design - we currently don't support sending analytics for anonymous users,
                // when we will want to support this we will need to a change in the services endpoint (user-analytics endpoint) and allow this here

                // We do want to send it to analytics though
                GoogleAnalyticsService.reportToGA(eventObject);

                return;
            }

            if (ImpersonationService.isImpersonating()) {
                eventObject.isImpersonating = true;
            }

            var dataStr = angular.toJson(eventObject);
            if (processCounter === maxProcessing) {
                console.log('blocking user-analytics request for: ' + dataStr);
                return;
            }

            UserService.getSummary().then(function(res) {
                delete res.data['accountToken'];

                eventObject.userSummary = res.data;

                self._sendUserAnalytics(eventObject);
                GoogleAnalyticsService.reportToGA(eventObject);
            });

        }
        catch (e) {
            console.error('Error while sending user analytics', e);
        }
    };

    self.startTimingReport = function (eventName) {
        _.set(self.concurrentEvents, [eventName, 'startTime'].join('.'), +Date.now());
    };

    self.finishTimingReport = function (eventName, eventData) {
        eventData = eventData || {};
        var now = +Date.now();
        eventData.processTime = now - _.get(self.concurrentEvents, [eventName, 'startTime'].join('.'), now);

        if (eventData.processTime === 0) {
            delete eventData.processTime;
        }

        self.report(eventName, eventData);
    };
});
/* origin: public/webapp/services/auth.js */
angular.module('webApp').service('AuthService', function($http, $location, $state, $stateParams, $timeout, localStorageService,
                                                         $rootScope, Backend, $q, appEmbedded, cacheService,
                                                         CookiesService, enums) {

    var _userSession = {},
        _authToken = undefined,
        _adminToken = undefined,
        _authTokenKey = 'logz-authToken',
        _adminTokenKey = 'logz-adminToken';

    _checkForAuthToken();

    function _checkForAuthToken() {
        _authToken = CookiesService.getCookieValue(_authTokenKey);

        if (_authToken) {
            _adminToken = CookiesService.getCookieValue(_adminTokenKey);
            if (_adminToken)
                _adminTokenReceived(_adminToken);
        }
    }

    function _fetchUser() {
        if (appEmbedded)
            return $q.when({
                // todo: fill this with something
            });

        // todo: this check shouldn't be here...
        if (!isAuthenticated() && (!$state.current.data || !$state.current.data.authenticate))
            return $q.when({});

        var promise = cacheService.get('user-session', function() {
            return Backend.GET('/session');
        });

        promise.then(function(response) {
            _.extend(_userSession, response.data);
        });

        return promise;
    }

    function _authTokenReceived(authToken) {
        if (authToken !== _authToken) {
            _authToken = authToken;
            CookiesService.setCookie(_authTokenKey, authToken);
        }
    }

    function _adminTokenReceived(adminToken) {
        if (adminToken !== _adminToken) {
            _adminToken = adminToken;
            CookiesService.setCookie(_adminTokenKey, _adminToken);
        }
    }

    function isAuthenticated() {
        var token = CookiesService.getCookieValue(_authTokenKey);

        // We shouldn't do any authentication required actions if we are in shareToken mode
        return $location.search().shareToken === undefined && !!token;
    }

    function setAuthToken(token) {
        _authTokenReceived(token);
    }

    function setAdminToken(token) {
        _adminTokenReceived(token);
    }

    function clearAuthToken() {
        CookiesService.removeCookie(_authTokenKey);
    }

    function clearAdminToken() {
        CookiesService.removeCookie(_adminTokenKey);
    }

    function loggedIn(webSession) {
        _authTokenReceived(webSession.sessionToken);
        if (webSession.admin === true)
            _adminTokenReceived(webSession.sessionToken);

        $rootScope.$emit('user-logged-in');
    }

    function logout() {
        Backend.POST('/logout');

        $timeout(function() {
            _authToken = undefined;
            Backend.authTokenHeader.clear();

            _adminToken = undefined;
            Backend.adminTokenHeader.clear();

            // Clear Kibana cache.
            cacheService.clearAllCache();

            // TODO: Use already supplied functions
            CookiesService.removeCookie(_authTokenKey);
            CookiesService.removeCookie(_adminTokenKey);

            // tell intercom.io the user logged out
            try {
                window.Intercom('shutdown');
            }
            catch (err) { }

            if (_.get($state, 'current.data.authenticate')) {
                $state.go('login');
            }
            else {
                location.reload();
            }
        }, 200);
    }

    function getAuthToken() {
        return _authToken;
    }

    function getAdminToken() {
        return _adminToken;
    }

    function isAdmin() {
        return _adminToken !== undefined;
    }

    /**
     * Available also by adding `accountId` to the url
     * @param accountId
     */
    // TODO: Change switch account to just return the promise, and not handle reload.
    function switchAccount(accountId) {
        return Backend.GET('/user/session/replace/' + accountId).then(function(newSession) {
            cacheService.clearAllCache();

            _authTokenReceived(newSession.data.sessionToken);

            if (newSession.data.admin) {
                _adminTokenReceived(newSession.data.sessionToken);
            }

            // TODO: Angular is a SPA... Why do we refresh?
            // We can't reload an abstract state (let's say we haven't loaded the app yet)
            if ($state.current.name === 'dashboard.kibana' && $stateParams.kibanaRoute) {
                $state.go('dashboard.kibana', { kibanaRoute: undefined });
                $timeout(function () {
                    $state.reload();
                }, 0);
            }
            else {
                !$state.current.abstract ? $state.reload() : location.reload();
            }
        });
    }

    function isHerokuUser() {
        return !!localStorageService.get('_heroku_');
    }

    function herokuSsoValidation(id, token, timestamp) {
        Backend.POST('/heroku/sso-validate', {
            accountId: id,
            token: token,
            timestamp: timestamp
        }).then(function(res) {
            var newSession = res.data;
            localStorageService.set('_heroku_', true);
            _authTokenReceived(newSession.sessionToken || newSession.token);
            _adminTokenReceived(newSession.adminToken);
            $location.url($location.path());
        });
    }

    function _isInternal() {
        if (!/^app(-(eu|us))?\.logz\.io$/.test(window.location.host)) {
            return true;
        }
        if (isAdmin()) {
            return true;
        }
        if (_userSession && _userSession.accountId === 300) {
            return true;
        }
        return false;
    }

    function _getUserSession () {
        return _fetchUser().then(function () {
            return _userSession;
        });
    }

    function _isAdminRole () {
        return _getUserSession().then(function(){
            return _userSession.role === enums.USER_ROLES.ADMIN;
        });
    }

    return {
        loggedIn: loggedIn,
        logout: logout,
        isAuthenticated: isAuthenticated,
        isAdmin: isAdmin,
        getAuthToken: getAuthToken,
        setAuthToken: setAuthToken,
        clearAuthToken: clearAuthToken,
        getAdminToken: getAdminToken,
        setAdminToken: setAdminToken,
        clearAdminToken: clearAdminToken,
        getUser: _fetchUser,
        switchAccount: switchAccount,
        isHerokuUser: isHerokuUser,
        herokuSsoValidation: herokuSsoValidation,
        isInternal: _isInternal,
        getUserSession: _getUserSession,
        isAdminRole: _isAdminRole
    };
});

/* origin: public/webapp/services/auth0-wrapper.js */
angular.module('webApp').service('Auth0Wrapper', function($stateParams, LogzConfig) {

    var service = {
        login: function(options, callback) {
            options = options || {};

            var baseUrl = [ window.location.protocol, '//', window.location.host ].join('');

            var auth0 = new Auth0({
                domain: options.domain || LogzConfig.auth0.domain,
                clientID: options.clientId || LogzConfig.auth0.clientID,
                callbackURL: options.callbackUrl || [ baseUrl, '/login/auth0code?baseUrl=', baseUrl ].join(''),
                responseType: options.responseType || 'token'
            });

            var loginRequest = {
                connection: options.connection || 'Username-Password-Authentication',
                username: options.email,
                password: options.password,
                popup: false,
                sso: false,
                scope: options.scope || 'openid email connection',
                mfa_code: options.mfa_code
            };

            auth0.login(loginRequest, callback);
        },
        signup: function(options, callback) {

            var auth0 = new Auth0({
                domain: options.domain || LogzConfig.auth0.domain,
                clientID: options.clientId || LogzConfig.auth0.clientID,
                responseType: options.responseType || 'token'//,
                //callbackURL: options.callbackUrl || window.location.protocol + '//' + window.location.host + '/login/auth0code'
            });

            var signupRequest = {
                connection: 'Username-Password-Authentication',
                username: options.email,
                password: options.password,
                popup: false,
                sso: false,
                auto_login: false
            };

            signupRequest.user_metadata = {
                fullName: options.fullName,
                company: options.company,
                phone: options.phone
            };

            auth0.signup(signupRequest, callback);
        }
    };

    return service;
});

/* origin: public/webapp/services/backend.js */
angular.module('webApp').service('Backend', function($rootScope, $http, CookiesService, cacheService) {

    var AUTH_TOKEN_HEADER = 'X-AUTH-TOKEN',
        ADMIN_TOKEN_HEADER = 'X-ADMIN-TOKEN',
        COOKIE_AUTH_TOKEN_KEY = 'logz-authToken',
        COOKIE_AUTH_ADMIN_TOKEN_KEY = 'logz-adminToken',
        USER_TOKEN_HEADER = 'X-USER-TOKEN',
        CONTENT_TYPE_POST_HEADER = 'Content-Type';

    var _authToken;

    function _setHeaders() {
        $http.defaults.headers.post[CONTENT_TYPE_POST_HEADER] = 'text/plain;charset=utf-8';

        var shareTokenParam = 'shareToken';
        var shareTokenLength = 36;

        var url = window.location.href;
        var shareTokenPosition = url.indexOf(shareTokenParam);
        if (shareTokenPosition > 0) {
            var shareToken = url.substring(shareTokenPosition + shareTokenParam.length + 1, shareTokenPosition + shareTokenParam.length + 1 + shareTokenLength);
            $http.defaults.headers.common[USER_TOKEN_HEADER] = shareToken;
            $http.defaults.headers.common[AUTH_TOKEN_HEADER] = 'undefined';
        }
        else {
            var userSession = cacheService.getCached('user-session');
            if (userSession && userSession.data && userSession.data.sessionToken) {
                _authToken = userSession.data.sessionToken;
            }
            else {
                _authToken = CookiesService.getCookieValue(COOKIE_AUTH_TOKEN_KEY);
            }

            if (_authToken)
                $http.defaults.headers.common[AUTH_TOKEN_HEADER] = _authToken;

            var adminToken = CookiesService.getCookieValue(COOKIE_AUTH_ADMIN_TOKEN_KEY);
            if (adminToken)
                $http.defaults.headers.common[ADMIN_TOKEN_HEADER] = adminToken;
        }

        if ($rootScope.accountRegion)
            $http.defaults.headers.common['X-ACCOUNT-REGION'] = $rootScope.accountRegion;
    }

    function _clearHeader(key) {
        delete $http.defaults.headers.common[key];
    }

    function applyReqParams(path, reqParams) {
        if (!reqParams) {
            return path;
        }

        var reqParamKeys = Object.keys(reqParams);
        if (!reqParamKeys.length) {
            return path;
        }

        var keyValueQueryStrings = [];
        _.forEach(reqParamKeys, function (key) {
            keyValueQueryStrings.push([ key, reqParams[key]].join('='));
        });

        return [ path, keyValueQueryStrings.join('&') ].join('?');
    }

    return {
        GET: function(path, reqParams, internalData) {
            path = applyReqParams(path, reqParams);
            _setHeaders();
            return $http.get(path, internalData);
        },
        POST: function(path, params, internalData) {
            _setHeaders();
            return $http.post(path, params, internalData);
        },
        DELETE: function(path, params) {
            _setHeaders();
            return $http({
                url: path,
                method: 'DELETE',
                data: params
            });
        },
        PUT: function(path, params) {
            _setHeaders();
            return $http.put(path, params);
        },
        authTokenHeader: {
            clear: function() {
                _clearHeader(AUTH_TOKEN_HEADER);
            }
        },
        adminTokenHeader: {
            clear: function() {
                _clearHeader(ADMIN_TOKEN_HEADER);
            }
        }
    };

});

/* origin: public/webapp/services/cache-service.js */
angular.module('webApp').service('cacheService', function($q, $window, localStorageService) {

    var service = {};

    var inProgress = {};
    var persistentKeyName = '_persistent_';

    var getFullCacheKey = function (key) {
        return 'logzCache.' + key;
    };

    service.set = function(key, value, secondsToLive) {
        if (!$window.sessionStorage)
            return;

        var cacheObject = {
            value: angular.fromJson(value),
            exp: parseInt((Date.now() / 1000) + secondsToLive)
        };
        $window.sessionStorage.setItem(getFullCacheKey(key), angular.toJson(cacheObject));
    };

    service.getCached = function(key) {
        var value = $window.sessionStorage.getItem(getFullCacheKey(key));

        if (typeof value === 'string') {
            var valObj = angular.fromJson(value);
            if (valObj && typeof valObj === 'object' && valObj.exp && valObj.exp >= (Date.now() / 1000)) {
                return angular.fromJson(valObj.value);
            }
        }
        return null;
    };

    service.get = function(key, getterFunc, secondsToLive) {
        var d = $q.defer();
        secondsToLive = secondsToLive || 12 * 60 * 60; //default to 12 hours

        var cacheKey = getFullCacheKey(key);
        var value = service.getCached(key);
        if (value) {
            d.resolve(value);
            return d.promise;
        }

        if (inProgress.hasOwnProperty(cacheKey))
            return inProgress[cacheKey];

        inProgress[cacheKey] = d.promise;

        // if we got a regular function as a getterFunc
        if (typeof getterFunc === 'function') {
            var getResponse = getterFunc();
            if (typeof getResponse === 'object' && getResponse.then && typeof getResponse.then === 'function') {
                getResponse.then(function(g) {
                    service.set(key, g, secondsToLive);
                    d.resolve(g);
                    delete inProgress[cacheKey];
                }, function(e) {
                    // todo: should i do something else ?
                    d.reject(e);
                    delete inProgress[cacheKey];
                });
                return d.promise;
            }

            service.set(key, getResponse, secondsToLive);
            d.resolve(getResponse);
            delete inProgress[cacheKey];
            return d.promise;
        }

        // if we got a promise as a getterFunc
        if (typeof getterFunc === 'object' && getterFunc.then && typeof getterFunc.then === 'function') {
            getterFunc.then(function(getResponse) {
                service.set(key, getResponse, secondsToLive);
                d.resolve(getResponse);
                delete inProgress[cacheKey];
            });
            return d.promise;
        }
    };

    service.setPersistent = function (key, value) {
        localStorageService.set([persistentKeyName, key].join('.'), value);
    };

    service.getPersistent = function (key) {
        return localStorageService.get([persistentKeyName, key].join('.'));
    };

    service.clear = function(key) {
        var cacheKey = 'logzCache.' + key;
        $window.sessionStorage.removeItem(cacheKey);
    };

    service.clearImpersistentLocalStorage = function () {
        var localKeys = localStorageService.keys();
        var inconsistentKeys = _.remove(localKeys, function (key) {
            return key.indexOf(persistentKeyName) === -1;
        });
        _.forEach(inconsistentKeys, localStorageService.remove);
    };

    service.clearAccountEndpointsCache = function () {
        service.getAllItems().forEach(function(item) {
            if (item.indexOf('logzCache./account/') !== 0) {
                return;
            }

            service.clear(item.replace('logzCache.', ''));
        });
    };

    service.clearAllCache = function() {
        $window.sessionStorage.clear();
        service.clearImpersistentLocalStorage();
    };

    service.getAllItems = function() {
        return Object.keys($window.sessionStorage);
    };

    return service;

});
/* origin: public/webapp/services/color-service.js */
angular.module('webApp').service('ColorService', function () {

    var module = {};

    module.colorScheme = [
        '#e3ba46',
        '#b763de',
        '#54c7c6',
        '#3b448b',
        '#219dd4',
        '#589026',
        '#eb8490',
        '#f19300', // EOF -> Colors from Adi
        '#3b73ac',
        '#479dc6',
        '#32a7c2',
        '#c5d558',
        '#f7be4f',
        '#f4a755',
        '#f29656',
        '#f08656',
        '#ec6856',
        '#eb5357',
        '#e04d70',
        '#c2458e',
        '#9e5297',
        '#6c478f',
        '#4f478f',
        '#444c92',
        '#42599b',
        '#2d5b89',
        '#287296',
        '#2e889e',
        '#cbc952',
        '#e1d76e',
        '#caaa52',
        '#c89951',
        '#ca8a52',
        '#c97b50',
        '#cb6f50',
        '#cd5451',
        '#c94a4f',
        '#b14458',
        '#9f4076',
        '#8a428a',
        '#5b3f7c',
        '#3d4078',
        '#3c4b7f',
        '#679ac9',
        '#67aed1',
        '#6cc2d5',
        '#82c2a3',
        '#b6d06f',
        '#d5de77',
        '#f6ef84',
        '#fff88e',
        '#fbe27d',
        '#ffd480',
        '#f9c57f',
        '#f6b87e',
        '#f4aa80',
        '#f0957e',
        '#ee7c7d',
        '#e8759a',
        '#cc6ea7',
        '#ab6aa2',
        '#89639e',
        '#6f65a0',
        '#636ca7',
        '#647fb3'
    ];

    module.getColorByString = function (name) {
        // This converts the string to a 32bit integer hash
        // taken from here :http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
        var hash = 0;
        if (name.length === 0)
            return hash;

        for (var i = 0; i < name.length; i++) {
            var char = name.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }

        var normalized = Math.abs(hash) % module.colorScheme.length;
        return module.colorScheme[normalized];
    };

    module.hexToRgb = function (hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16)} : null;
    };

    module.hashCode = function (str) { // java String#hashCode
        var hash = 0;
        for (var i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        return hash;
    };

    module.intToRGB = function (i) {
        var c = (i & 0x00FFFFFF)
            .toString(16)
            .toUpperCase();

        return '00000'.substring(0, 6 - c.length) + c;
    };

    module.convertStringToRGBA = function (string, opacity) {
        return module.convertHexToRgba(module.getColorByString(string), opacity);
    };

    module.convertHexToRgba = function(hex, opacity) {
        opacity = (opacity >= 0) && (opacity <= 1) ? opacity : 1;
        var rgba = module.hexToRgb(hex);
        return ['rgba(', rgba.r, ',', rgba.g, ',', rgba.b, ',', opacity, ')'].join('');
    };

    var calculateColor16 = function (colorStrength, percent) {

        colorStrength = parseInt(colorStrength * (100 + percent) / 100);
        colorStrength = colorStrength < 255 ? colorStrength : 255;

        var color16 = colorStrength.toString(16);
        return _.padStart(color16, 2, 0);
    };

    module.shadeColor = function (color, percent) {

        var R = parseInt(color.substring(1, 3), 16);
        var G = parseInt(color.substring(3, 5), 16);
        var B = parseInt(color.substring(5, 7), 16);

        return [ '#', calculateColor16(R, percent), calculateColor16(G, percent), calculateColor16(B, percent) ].join('');
    };

    return module;
});

/* origin: public/webapp/services/confirm.js */
angular.module('webApp').service('ConfirmService', function(ngDialog) {

    return {
        open: function(options) {
            ngDialog.open({
                template: options.template,
                controller: function($scope) {
                    $scope.title = options.title;
                    $scope.action = options.action;
                    // TODO: When reformatting, we can decorate the confirm with the closeThisDialog event
                    $scope.confirm = options.confirm;
                    $scope.cancel = options.cancel || $scope.closeThisDialog;
                    $scope.confirmButtonText = options.confirmButtonText || 'Yes';
                    $scope.isFormValid = options.isFormValid || true;
                },
                showClose: false,
                width: options.width || '450px',
            });
        }
    };

});
/* origin: public/webapp/services/cookies.js */
angular.module('webApp').service('CookiesService', [function() {

    var hostName = window.location.hostname.toLowerCase();
    var isLogzioDomain = hostName.indexOf('.logz.io') !== -1;
    var domain = isLogzioDomain ? '.logz.io' : hostName;

    var envNameAddon = '';
    if (!isLogzioDomain) {
        envNameAddon += '-local';
    }
    else if (hostName.indexOf('staging') !== -1) {
        envNameAddon += '-staging';
    }
    // Shouldn't have internal case handled due to impersonation cookie share
    // else if (hostName.indexOf('internal') !== -1) {
    //     envNameAddon += '-internal';
    // }

    return {
        getCookieValue: function(name) {
            var match = document.cookie.match(new RegExp([ name, envNameAddon, '=([^;]+)' ].join('')));
            if (match) return match[1];
        },

        setCookie: function(name, value, supressEnvSuffix) {
            document.cookie = [ name, supressEnvSuffix ? '' : envNameAddon, '=', value, '; domain=', domain, '; path=/' ].join('');
        },

        removeCookie: function(name) {
            var expiredDate = new Date();
            expiredDate.setTime(expiredDate.getTime()+(-1*24*60*60*1000));
            var expires = 'expires=' + expiredDate.toGMTString();
            document.cookie = [ name, envNameAddon, '=; domain=', domain, '; ', expires, '; path=/' ].join('');
        }
    };
}]);
/* origin: public/webapp/services/csv-service.js */
angular.module('webApp').service('CsvService', function (LogzioFileSaver) {

    // https://tools.ietf.org/html/rfc4180

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    //                  NEED TO BE GENERALLY TESTED (DONE WITH HASTE TO RELEASE A FEATURE
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    /**
     * Can handle deep lookup (using _.get)
     * @param fileName
     * @param data - {json[]}
     * @param options - {object} - Optional:
     *                  headers - {any[]}: Titles for the CSV (the first line)
     *                  fields - {string[]}: What fields to use from the JSON (strings as used in _.get())
     */
    this.json2Csv = function (fileName, data, options) {
        var self = this;

        fileName = fileName || 'Exported Data.csv';
        options = options || {};
        var headers = options.headers || [];
        var fields = options.fields || [];
        var emptyCellValue = options.emptyCellValue || '';

        if (!Array.isArray(data)) {
            console.warn('Received non-arrayed JSON. Wrapping it with an array.');
            data = [data];
        }

        data.forEach(function (jsonObj, rowIndex) {
            var modifiedRowFields = [];

            // Operate according to the presence of fields settings
            if (fields.length === 0) {
                _.values(jsonObj).forEach(function (fieldValue) {
                    modifiedRowFields.push(self._modifyValue(fieldValue || emptyCellValue));
                });
            }
            else {
                fields.forEach(function(field) {
                    modifiedRowFields.push(self._modifyValue(_.get(jsonObj, field) || emptyCellValue));
                });
            }

            data[rowIndex] = modifiedRowFields.join(', ');
        });

        if (headers.length > 0) {
            data.unshift(headers.map(self._modifyValue));
        }

        var mimeType = self._createMimeType(!!headers);

        LogzioFileSaver(fileName, data.join('\r\n'), mimeType);
    };

    /**
     * @param headersPresent - {boolean}
     * @returns {string}
     * @private
     */
    this._createMimeType = function(headersPresent) {
        return [ 'data:text/csv;charset=utf-8;header=', headersPresent ? 'present' : 'absent' ].join('');
    };

    /**
     * @param val - {string}
     * @private
     */
    this._modifyValue = function(val) {
        // Also escapes
        val = val.toString().replace(/"/g, '\"\"');
        return [ '\"', val, '\"' ].join('');
    };

});
/* origin: public/webapp/services/delay-chunk-loader.js */
angular.module('webApp').service('DelayChunkLoader', function ($timeout) {
    return function (pool, models, bucketSize, millisecondsDelay) {
        var chunks = _.chunk(models, bucketSize);
        if (!chunks || !chunks.length) {
            return; // Nothing to load
        }

        // We keep this isolated from the loop because we want to load the first chunk of models immediately
        // instead of using $timeout(0) which will load the models after the first screen render
        pool.push.apply(pool, chunks[0]);

        var timeoutLoop = function (chunkIndex) {
            if (chunks.length <= chunkIndex) {
                return; // No more chunks to load
            }

            $timeout(function () {
                pool.push.apply(pool, chunks[chunkIndex]);
                timeoutLoop(chunkIndex + 1);
            }, millisecondsDelay);
        };
        timeoutLoop(1);
    };
});
/* origin: public/webapp/services/elastic-search-service.js */
angular.module('webApp').service('ElasticSearchService', function ($q, Backend, KibanaFrameService, AnalyticsService, AccountService) {

    var module = {};
    var validationPromise = undefined;
    var validationInProgress = false;

    module.getElasticSearchDatePrefix = function (date) {
        var d = date.getDate();
        var m = date.getMonth() + 1;
        var y = date.getYear() % 100;
        return [y, (m <= 9 ? '0' + m : m), (d <= 9 ? '0' + d : d)].join('');
    };

    module.validateQuery = function (query) {
        if (validationInProgress) {
            return validationPromise;
        }

        validationInProgress = true;
        validationPromise = module.sendQueryForValidation(query);
        return validationPromise;
    };

    module.sendQueryForValidation = function (query) {
        var endpointAddress = '/kibana/elasticsearch/logzioCustomerKibanaIndex/__kibanaQueryValidator/_validate/query?explain=false&ignore_unavailable=true';
        var reqData = {
            query: {
                query_string: {
                    analyze_wildcard: true,
                    query: query
                }
            }
        };

        return Backend.POST(endpointAddress, reqData).catch(function () {
            return false;
        }).then(function (response) {
            return _.get(response, 'data.valid', false);
        }).finally(function () {
            validationInProgress = false;
        });
    };

    // todo change this to a more general query
    module.getElasticSearchLogLines = function (from, to, fieldExists) {
        var endpointAddress = 'kibana/elasticsearch/logzioCustomerIndex*/_search/';
        var reqData = {
            'size': 10,
            // 'sort': [{'@timestamp': {'order': 'desc', 'unmapped_type': 'boolean'}}],
            'query': {
                'bool': {
                    'must': [
                        {'match_all': {}}, {
                            'range': {
                                '@timestamp': {
                                    'gte': from,
                                    'lte': to
                                }
                            }
                        }],
                    'must_not': []
                }
            }
            //TODO should we use aggregation here?
            // 'aggs': {
            //     '2': {
            //         'date_histogram': {
            //             'field': '@timestamp',
            //             'interval': '1m',
            //             // 'time_zone': 'Asia/Jerusalem',
            //             'min_doc_count': 1
            //         }
            //     }
            // }
        };
        //TODO make this usable and better
        // if (field) {
        //     _.get(reqData, 'query.bool.must').push({'match': {'type': {'query': logType, 'type': 'phrase'}}});
        // }
        // if (query) {
        //     _.get(reqData, 'query.bool.must').push({'query_string': {'query': query, 'analyze_wildcard': true}})
        // }
        // if (fieldQuery) {
        //     _.get(reqData, 'query.bool.must').push({'match_phrase': {[fieldQuery.field]: {'query': fieldQuery.query}}})
        // }
        if (fieldExists) {
            _.get(reqData, 'query.bool.must').push({'exists': {'field': fieldExists}});
        }
        return Backend.POST(endpointAddress, reqData);
    };

    module.retrieveElasticIndexedFields = function () {
        var reqData = {
            docs: [{
                _index: 'logzioCustomerKibanaIndex',
                _type: 'index-pattern',
                _id: ['[logzioCustomerIndex]YYMMDD'].join('')
            }]
        };
        return Backend.POST('/kibana/elasticsearch/_mget?timeout=30000&ignore_unavailable=true', reqData).then(function (response) {
            // TODO Kibana ditched analyzed flag in version 5, we ditched it on October 25th 2017 (services)
            // TODO we should remove aggregatable type check but we cannot do that till all our users refresh their index mapping,
            // TODO till they do that they wont have aggregatable flag at all (that's why the boolean type check). We can't do
            // TODO that for them because it will change real time data they did not ask to be changed, it may cause critical issues.
            // TODO In 4-6 months (when we feel safe enough) we should remove this code and uncomment the line below (original code)
            // return JSON.parse(response.data.docs[0]._source.fields);
            var fields = JSON.parse(response.data.docs[0]._source.fields);
            _.forEach(fields, function (field) {
                field.aggregatable = typeof field.aggregatable === 'boolean' ? field.aggregatable : !field.analyzed;
            });

            return fields;
        });
    };

    module.isInProgress = function () {
        return validationInProgress;
    };

    module.refreshMapping = function (category, location, avoidKibanaFrameRefresh) {
        AnalyticsService.report('refresh-mapping',
            {category: category, location: location}
        );

        AccountService.clearAccountLogTypesCache();
        AccountService.clearAccountFieldsCache();

        return Backend.GET('/update-kibana-index').finally(function () {
            if (avoidKibanaFrameRefresh) {
                return;
            }

            KibanaFrameService.refresh();
        });
    };

    return module;

});
/* origin: public/webapp/services/feature-flag-service.js */
angular.module('webApp').service('FeatureFlagService', function ($state, $q, $location, Backend, cacheService, AuthService) {

    var service = {
        cacheKey: 'features-enabled'
    };

    var getFeatureFlagData = function () {
        if (!$location.search().shareToken && !AuthService.isAuthenticated())
            return $q.when();

        return cacheService.get(service.cacheKey, function () {
            return Backend.GET('/feature-flag/enabled-features');
        }, 60 * 60 * 24);
    };

    service.clearCacheAndLoadData = function () {
        cacheService.clear(service.cacheKey);
        return getFeatureFlagData();
    };

    service.isFeatureEnabled = function (featureName) {
        return getFeatureFlagData().then(function (res) {
            return res.data.indexOf(featureName) >= 0;
        });
    };

    service.redirectIfFeatureDisabled = function (featureName, toState) {
        toState = toState || 'dashboard.kibana';

        return service.isFeatureEnabled(featureName).then(function (enabled) {
            if (!enabled) {
                $state.go(toState);
            }
        });
    };

    return service;
});

/* origin: public/webapp/services/field-mappings/mappings-service.js */
angular.module('webApp').service('MappingsService', function ($q, Backend, UserService, cacheService) {
    var module = {};

    var availableFieldTypes =
        {
            '': 'Automatic',
            'automatic': 'Automatic',
            'boolean': 'Boolean',
            'date': 'Date (timestamp)',
            'double': 'Double',
            'geoip': 'GeoIp Enrichment',
            'ip': 'IP',
            'keyword': 'Keyword (String)',
            'long': 'Long',
            'byte': 'Byte',
            'geo_point': 'Geo Point',
            'float': 'Float',
            'integer': 'Integer',
            'text': 'Text (Analysed Field)',
            'short': 'Short'
        };

    var reversedFieldTypes = {
        'Automatic': '',
        'Boolean': 'boolean',
        'Date (timestamp)': 'date',
        'Double': 'double',
        'GeoIp Enrichment': 'geoip',
        'IP': 'ip',
        'Keyword (String)': 'keyword',
        'Long': 'long',
        'Byte': 'byte',
        'Geo Point': 'geo_point',
        'Float': 'float',
        'Integer': 'integer',
        'Text (Analysed Field)': 'text',
        'Short': 'short'
    };

    module.getAllVisualizations = function () {
        return cacheService.get('all-visualizations', function () {
            return UserService.getSummary().then(function (res) {
                var endpointAddress = ['/kibana/elasticsearch/', 'kibana-', res.data.accountEsIndexPrefix, '/visualization/_search?size=500'].join('');
                var reqData = {
                    query: {
                        match_all: {}
                    }
                };

                return Backend.POST(endpointAddress, reqData);
            }).catch(function () {
                return false;
            }).then(function (response) {
                return response.data.hits;
            });
        }, 1800);
    };

    module.getAllDashboards = function () {

        return cacheService.get('all-dashboards', function () {
            return UserService.getSummary().then(function (res) {
                var endpointAddress = ['/kibana/elasticsearch/', 'kibana-', res.data.accountEsIndexPrefix, '/dashboard/_search?size=500'].join('');
                var reqData = {
                    query: {
                        match_all: {}
                    }
                };

                return Backend.POST(endpointAddress, reqData);
            }).catch(function () {
                return false;
            }).then(function (response) {
                return response.data.hits;
            });
        }, 1800);
    };

    module.getAllVisualizationsWithDashboardsByFieldName = function (fieldName) {

        var defer = $q.defer();

        module.getAllVisualizations().then(function (visualizations) {
            var dashData, res = [];

            visualizations.hits.forEach(function (vis) {

                JSON.parse(vis._source.visState).aggs.forEach(function (val) {
                    dashData = _.find(val, ['field', fieldName]);

                    if (dashData) {
                        res.push(vis);
                    }
                });
            });

            module.getAllDashboards().then(function (dashboards) {

                res.forEach(function (visualization) {
                    visualization['dashboardsData'] = [];

                    dashboards.hits.forEach(function (dashboard) {
                        dashData = _.find(JSON.parse(dashboard._source.panelsJSON), ['id', visualization._id]);

                        if (dashData) {
                            dashboard._id = decodeURIComponent(dashboard._id);
                            visualization['dashboardsData'].push(dashboard);
                        }
                    });
                });
                defer.resolve(res);
            });
        });

        return defer.promise;
    };

    module.isFieldInManyLogTypes = function (logTypes) {
        return logTypes.length > 0;
    };

    module.parseData = function (data, initialObj, changedObj) {

        var parsedElement = {};

        data.forEach(function (element) {

            parsedElement = {};

            for (var key in element) {
                if (key === 'fieldType') {
                    parsedElement[key] = {'val': availableFieldTypes[element[key]], 'editable': 'select'};
                }
                else if (key ==='fieldTypeInES') {
                    parsedElement['fieldType'] = {'val': availableFieldTypes[element[key]], 'editable': 'select'};
                }
                else if (key ==='sentLogType') {
                    parsedElement['logType'] = {'val': element[key], 'editable': false};
                }
                else if (key === 'fieldRename') {
                    parsedElement[key] = {'val': element[key], 'editable': 'input'};
                }
                else if (key === 'otherlogTypes' || key === 'otherLogTypesInES') {
                    if (module.isFieldInManyLogTypes(element[key])) {
                        //disable combobox
                        parsedElement['otherlogTypes'] = true;
                    }
                    else {
                        //disable rename
                        parsedElement['otherlogTypes'] = false;
                    }
                }
                else {
                    parsedElement[key] = {'val': element[key], 'editable': false};
                }
                parsedElement['resolved'] = parsedElement['disableRename'] = parsedElement['disableSelect'] = false;
            }
            changedObj['mappings'].push(parsedElement);
        });
        initialObj['mappings'] = _.cloneDeep(changedObj['mappings']);
    };

    module.diffBetweenInitialAndChangedData = function (initialObj, changedObj) {

        var initial = _.cloneDeep(initialObj);
        var changed = _.cloneDeep(changedObj);

        initial.forEach(function (el) {
            delete el['disableRename'];
            delete el['disableSelect'];
        });

        changed.forEach(function (el) {
            delete el['disableRename'];
            delete el['disableSelect'];
            delete el['$$hashKey'];
        });

        return _.reduce(changed, function (result, value, key) {
            if (_.isEqual(value, initial[key])) {
                return result;
            }
            value['modifiedFields'] = [];

            if (initial[key]['fieldRename'].val !== value['fieldRename'].val) {
                value['modifiedFields'].push('fieldRename');
            }
            if (initial[key]['fieldType'].val !== value['fieldType'].val.trim()) {
                value['modifiedFields'].push('fieldType');
            }

            return result.concat(value);

        }, []);
    };


    module.parseDataBeforeApply = function (updatedData) {

        var data = {'renames': [], 'mappings': [], 'falseErrors': []};
        updatedData.forEach(function (element) {
            if (element.modifiedFields.indexOf('fieldRename') > -1) {
                data['renames'].push({
                    'field': element['fieldName'].val,
                    'logType': element['logType'].val,
                    'newField': element['fieldRename'].val
                });
            }
            if (element.modifiedFields.indexOf('fieldType') > -1) {
                data['mappings'].push({
                    'field': element['fieldRename'].val || element['fieldName'].val,
                    'fieldType': reversedFieldTypes[element['fieldType'].val],
                    'logType': element['logType'].val
                });
            }
            if (element.resolved) {
                data['falseErrors'].push({'field': element['fieldName'].val, 'logType': element['logType'].val});
            }
        });

        return data;
    };

    module.discardMappedFields = function (initialObj, changedObj) {
        if (!initialObj && !changedObj)
            return;
        changedObj['mappings'] = _.cloneDeep(initialObj['mappings']);

    };

    return module;
});
/* origin: public/webapp/services/gabby-service.js */
angular.module('webApp').factory('gabby', function() {
    return {
        for: function(scope) {
            var scopedService = {};

            scopedService.settings = function(defaults) {
                angular.extend(scope, defaults, scope.settings);
                return scopedService;
            };

            scopedService.api = function(apiDefinition) {
                scope.api = scope.api || {};
                angular.extend(scope.api, apiDefinition);
                return scopedService;
            };

            return scopedService;
        },
        scope: function(fields, optionalPrefix) {
            return angular.extend({
                settings: '=' + (optionalPrefix ? optionalPrefix + 'Settings' : ''), //should be '<' once we move to angular 1.5 or above
                api: '=' + (optionalPrefix ? optionalPrefix : '')
            }, fields);
        }
    };
});
/* origin: public/webapp/services/google-analytics-service.js */
angular.module('webApp').service('GoogleAnalyticsService', function () {
    var service = {};
    var dataLayer = window.dataLayer = window.dataLayer || [];

    var mapDataToCustomDimensions = {
        'timestamp': 'timestamp',
        'isImpersonating': 'isImpersonating',
        'accountId': 'userSummary.accountId',
        'userId': 'userSummary.userId',
        'accountName': 'userSummary.accountName',
        'planType': 'userSummary.planType',
        'actionLocation': 'location',
        'pageFullUrl': 'url',
        'processTime': 'processTime'
    };

    service.reportToGA = function (data) {
        var event = {
            eventName: data.eventName,
            eventData: JSON.parse(data.eventData),
            eventTimestamp: data.timestamp
        };

        if (event.eventName === 'pageview') {
            reportPageView(event);
        }
        else {
            reportEvent(event);
        }
    };

    var reportPageView = function (event) {
        var analyticsPageView = {
            event: 'logzioPageView',
            pageName: _.get(event, 'eventData.page')
        };
        reportToTagManager(analyticsPageView, event);
    };

    var reportEvent = function (event) {
        var analyticsEvent = {
            event: 'logzioAutoEvent',
            eventCategory: _.get(event, 'eventData.category', 'general'),
            eventAction: event.eventName,
            eventLabel: _.get(event, 'eventData.location', ''),
        };
        reportToTagManager(analyticsEvent, event);
    };

    var reportToTagManager = function (eventToSend, UserAnalyticsData) {
        _.forEach(mapDataToCustomDimensions, function (UAValue, GTMValue) {
            var value = _.get(UserAnalyticsData.eventData, UAValue);
            if (value) _.set(eventToSend, GTMValue, value);
        });

        eventToSend.timestamp = UserAnalyticsData.eventTimestamp;

        dataLayer.push(eventToSend);
    };

    return service;
});
/* origin: public/webapp/services/http-requests-service.js */
angular.module('webApp').service('HttpRequestsService', function ($rootScope, $http, ngProgressFactory) {

    var service = {
        loadingProgressBar: {
            height: '4px',
            color: '#FF820B'
        },
        kibanaPendingRequests: [] // Used in heavy-es-queries-controller.js
    };

    var ngProgress = ngProgressFactory.createInstance();

    // For Snapshotter Selenium
    ngProgress.progressbarEl.addClass('loading-progress-bar');

    // Snapshotter Selenium expects ng-hide when progress bar is completed (legacy reasons), we gonna supply that but make sure ng-hide has no styling effect
    ngProgress.progressbarEl[0].style.setProperty('display', 'block', 'important');

    ngProgress.setHeight(service.loadingProgressBar.height);
    ngProgress.setColor(service.loadingProgressBar.color);

    $rootScope.$watch(function () {
        return $http.pendingRequests.length + service.kibanaPendingRequests.length;
    }, function () {
        var httpRequests = _.union($http.pendingRequests, service.kibanaPendingRequests);
        httpRequests = _.filter(httpRequests, function (request) {
            return !request.dontShowProgressBar;
        });

        if (httpRequests.length) {
            ngProgress.start();
            ngProgress.progressbarEl.removeClass('ng-hide'); // For Snapshotter Selenium, has no styling effect (display: none is overridden)
        }
        else {
            if (ngProgress.status() > 0) {
                ngProgress.complete(); // Only if started, calling complete runs a quick progress bar completion from zero
            }
            ngProgress.progressbarEl.addClass('ng-hide'); // For Snapshotter Selenium, has no styling effect (display: none is overridden)
        }
    });

    service.updateKibanaPendingRequests = function (pendingRequests) {
        service.kibanaPendingRequests = pendingRequests;
    };

    return service;
});

/* origin: public/webapp/services/impersonation.js */
angular.module('webApp').service('ImpersonationService', function ($rootScope, AuthService, Backend, cacheService, CookiesService, Logger, FeatureFlagService, UserPermissionsService, UserService, UserTokensService, AccountService) {

    var impersonationStateCookieName = 'logz-isImpersonating';

    var clearPersonalCacheValues = function () {
        cacheService.clear('user-session');
        cacheService.clear('planPrices');
        cacheService.clear('plan-details');
        cacheService.clear('user-summary');
        cacheService.clear('sub-accounts');
        cacheService.clear('accounts-index-map');
        cacheService.clear(FeatureFlagService.cacheKey);
        cacheService.clear(UserPermissionsService.cacheKey);

        AccountService.clearAccountListCache();
        cacheService.clearAccountEndpointsCache();

        UserService.cleanUserSettings();
        UserTokensService.clearCache();
    };

    var adminStopImpersonationUrlCookieName = 'logz-admin-stop-impersonation-url';

    function impersonate(accountId, username) {
        CookiesService.setCookie(adminStopImpersonationUrlCookieName, window.location.href);
        CookiesService.setCookie(impersonationStateCookieName, true);

        var url = [ '/__admin__/impersonate?accountId=', accountId ].join('');
        return Backend.POST(url, { username: username }).then(function (resp) {
            clearPersonalCacheValues();
            CookiesService.setCookie('logz-authToken', resp.data.sessionToken);
            window.location.href = window.location.origin;
        });
    }

    function stopImpersonation() {
        clearPersonalCacheValues();
        AuthService.setAuthToken(AuthService.getAdminToken());

        var adminStopImpersonationUrl = CookiesService.getCookieValue(adminStopImpersonationUrlCookieName);

        CookiesService.removeCookie(adminStopImpersonationUrlCookieName);
        CookiesService.removeCookie(impersonationStateCookieName);

        if (!adminStopImpersonationUrl) {
            // Probably due to double click on stop impersonation
            window.location.reload();
            return;
        }

        window.location.href = adminStopImpersonationUrl;
        // Need to reload if were not redirecting to a new origin, otherwise angular will treat this state change and will not reload all personal cache
        if (adminStopImpersonationUrl.startsWith(window.location.origin)) {
            // TODO avoid page reloading, there's a plan to refactor switchAccount() and avoid reloading of the page,
            // TODO maybe it can help in this scenario (we need to reload all personal cache instead of just remove it and reload the page
            window.location.reload();
        }
    }

    function isImpersonating() {
        var isActuallyImpersonating = CookiesService.getCookieValue(impersonationStateCookieName);
        var isAdminWithTwoTokens = AuthService.isAdmin() && (AuthService.getAuthToken() !== AuthService.getAdminToken());
        if (!isActuallyImpersonating) {
            if (isAdminWithTwoTokens) {
                Logger.log({
                    message: 'User got user token and admin token but he\'s not impersonating',
                    userToken: AuthService.getAuthToken(),
                    adminToken: AuthService.getAdminToken()
                });

                AuthService.clearAdminToken();
                AuthService.clearAuthToken();
                clearPersonalCacheValues();
            }

            return false;
        }

        if (!isAdminWithTwoTokens) {
            CookiesService.removeCookie(impersonationStateCookieName);
            clearPersonalCacheValues();

            return false;
        }

        return true;
    }

    return {
        impersonate: impersonate,
        stopImpersonation: stopImpersonation,
        isImpersonating: isImpersonating
    };
});


/* origin: public/webapp/services/insights-service.js */
/* eslint-disable max-lines */
angular.module('webApp').service('InsightsService', function ($rootScope, $q, $interval, Backend, UserService, UpgradeService, AccountService, AuthService, ngDialog, cacheService) {

    var module = {};

    var cachedKibanaInsights = {}; // This is an inner cache for the insights we loaded from the db
    var disableShowFeedbackDialogSeconds = 5; //todo change this to a reasonable time

    // Returns the already loaded insight, we assume that any place that reaches here called loadInsightsByIdsForKibana before.
    // We build it like this in order to share data between Kibana log lines, now that the users are able to edit the insight data
    // we have to do a two way bindings
    module.getLoadedKibanaInsightById = function (id) {
        return cachedKibanaInsights[id];
    };

    module.getLoadedKibanaInsightByIds = function (ids) {
        var insightsToReturn = [];

        _.forEach(ids, function (id) {
            var insight = cachedKibanaInsights[id];
            if (insight) {
                insightsToReturn.push(insight);
            }
        });

        return insightsToReturn;
    };

    module.updateKibanaCachedInsight = function (updatedInsight) {
        var insightToUpdate = cachedKibanaInsights[updatedInsight.insight.id];
        if (!insightToUpdate) {
            return; // Yet to be loaded inside the Kibana
        }

        insightToUpdate.read = updatedInsight.read;
        insightToUpdate.helpful = updatedInsight.helpful;
        insightToUpdate.insight.severity = updatedInsight.insight.severity;
        insightToUpdate.insight.title = updatedInsight.insight.title;
        insightToUpdate.insight.description = updatedInsight.insight.description;
        insightToUpdate.insight.links = updatedInsight.insight.links;
        insightToUpdate.textLastEditedDate = updatedInsight.textLastEditedDate;
        insightToUpdate.textLastEditedBy = updatedInsight.textLastEditedBy;
        insightToUpdate.severityLastEditedDate = updatedInsight.severityLastEditedDate;
        insightToUpdate.severityLastEditedBy = updatedInsight.severityLastEditedBy;
    };

    module.updateIncidentCachedInsight = function (updatedIncident) {
        var insightToUpdate = cachedKibanaInsights[updatedIncident.id];
        if (!insightToUpdate) {
            return; // Yet to be loaded inside the Kibana
        }

        insightToUpdate.helpful = updatedIncident.helpful;
        insightToUpdate.insight.severity = updatedIncident.severity;
        insightToUpdate.insight.title = updatedIncident.title;
        insightToUpdate.insight.description = updatedIncident.description;
        insightToUpdate.insight.links = updatedIncident.links;
        insightToUpdate.textLastEditedDate = updatedIncident.textLastEditedDate;
        insightToUpdate.textLastEditedBy = updatedIncident.textLastEditedBy;
        insightToUpdate.severityLastEditedDate = updatedIncident.severityLastEditedDate;
        insightToUpdate.severityLastEditedBy = updatedIncident.severityLastEditedBy;
    };

    var insightIdToPromise = {};
    module.getLoadedKibanaInsightByIdAsPromise = function (id) {
        if (!insightIdToPromise[id]) {
            insightIdToPromise[id] = $q.defer();
        }

        return insightIdToPromise[id].promise;
    };

    module.loadInsightsByIdsForKibana = function (ids) {
        if (!ids || !ids.length)
            return $q.when([]);

        var d = $q.defer();

        _.forEach(ids, function (id) {
            if (insightIdToPromise[id]) {
                return; // Already created a promise for this insight id
            }

            insightIdToPromise[id] = $q.defer();
        });

        Backend.POST('/insights', {ids: ids}).then(function (res) {

            var returnedInsightIds = [];
            _.forEach(res.data || [], function (insightData) {
                var insightId = insightData.insight.id;
                returnedInsightIds.push(insightId);

                if (cachedKibanaInsights[insightId]) {
                    module.updateKibanaCachedInsight(insightData);
                }
                else {
                    cachedKibanaInsights[insightId] = insightData;
                }
            });

            _.forEach(ids, function (id) {
                if (!insightIdToPromise[id]) {
                    insightIdToPromise[id] = $q.defer();
                }

                insightIdToPromise[id].resolve();
            });

            d.resolve();
        });

        return d.promise;
    };

    module.getInsightsAccountUsers = function () {
        var accountUsers = [];
        return $q.all({
            usersRes: AccountService.getCachedAccountUsers(),
            userRes: AuthService.getUser()
        }).then(function (result) {
            _.forEach(result.usersRes, function (userData) {
                if (userData.user.fullName === result.userRes.data.fullName) {
                    return; // Will be added at the top of the list after sorting it
                }

                accountUsers.push({
                    fullName: userData.user.fullName,
                    username: userData.user.username,
                    userId: userData.user.userId,
                });
            });

            accountUsers = _.sortBy(accountUsers, 'fullName');
            accountUsers.splice(0, 0, {
                fullName: result.userRes.data.fullName,
                username: result.userRes.data.username,
                userId: result.userRes.data.userId,
                myUser: true
            });

            return accountUsers;
        });
    };

    module.revertInsightDataChanges = function (insightId) {
        return Backend.POST(['/insights-account-revert-data/', insightId].join(''));
    };

    module.revertImportanceChanges = function (insightId) {
        return Backend.POST(['/insights-account-revert-severity/', insightId].join(''));
    };

    module.setInsightSeverity = function (insightId, severity) {
        return Backend.POST(['/insights/', insightId].join(''), {insight: {severity: severity}});
    };

    module.setInsightStatus = function (insightId, status) {
        return Backend.POST(['/insights/', insightId].join(''), {status: status});
    };

    module.setInsightAssignee = function (insightId, assignee, message) {
        return Backend.POST(['/insights-assign/', insightId].join(''), {
            assignee: assignee,
            msg: message
        });
    };

    module.sendImprovementSuggest = function (insightId, helpful, message) {
        return Backend.POST(['/insights-feedback/', insightId].join(''), {
            helpful: helpful,
            msg: message
        });
    };

    module.setInsightRead = function (insightId, read, updateSummary) {
        if (updateSummary) {
            cachedInsightsSummary.amountOfUnread += read ? -1 : 1;

            if (cachedInsightsSummary.amountOfUnread < 0) {
                module.loadSummary();
            }
        }

        return Backend.POST(['/insights/', insightId].join(''), {read: read});
    };

    module.setInsightHidden = function (insightId, hidden) {
        return Backend.POST(['/insights/', insightId].join(''), {hidden: hidden});
    };

    module.popupEditInsightDialog = function (editInsightData, saveCallback) {
        var editInsightScope = $rootScope.$new();
        editInsightScope.editInsightData = editInsightData;
        editInsightScope.saveCallback = saveCallback;

        ngDialog.open({
            template: 'app/dashboard/incidents/edit-insight/edit-insight.html',
            controller: 'EditInsightController',
            width: '778px',
            closeByEscape: true,
            closeByDocument: true,
            showClose: false,
            scope: editInsightScope,
        });
    };

    module.popupDismissInsightDialog = function (changeStatusCallback, revertStatusCallback) {
        var dismissInsightScope = $rootScope.$new();
        dismissInsightScope.changeStatus = changeStatusCallback;
        dismissInsightScope.revertStatus = revertStatusCallback;

        ngDialog.open({
            template: 'app/dashboard/incidents/dismiss-insight/dismiss-insight.html',
            controller: 'DismissInsightController',
            width: '344px',
            closeByEscape: false,
            closeByDocument: false,
            showClose: false,
            scope: dismissInsightScope,
        });
    };

    module.feedbackPopped = function (insight) {
        insight.feedback_popped = true;
        return Backend.POST(['/insights/', insight.insight.id].join(''), {feedback_popped: true});
    };

    module.doNotPopFeedback = function () {
        return Backend.POST('/insights-feedback-pop-enabled', {dont_pop_feedback: true}).then(function () {
            _.forEach(cachedKibanaInsights, function (cachedInsight) {
                cachedInsight.dont_pop_feedback = true;
            });
        });
    };

    var changeLater = true; // TODO this is for phase 1, backend is not ready yet
    module.shouldPopupAppear = function (insight, timeOfOpen) {
        var q = $q.defer();
        var timeOfCollapse = new Date();

        if (changeLater || !insight ||
            insight.helpful !== undefined ||
            timeOfCollapse - timeOfOpen <= disableShowFeedbackDialogSeconds * 1000 ||
            insight.dont_pop_feedback === true ||
            insight.feedback_popped) {

            q.resolve(false);
            return q.promise;
        }

        cacheService.clear('user-session');
        AuthService.getUser().then(function (userSession) {
            var lastFeedback = Number(userSession.lastFeedback) || 0;
            q.resolve(timeOfCollapse - lastFeedback > 3 * 60 * 60 * 1000); //longer than 3 hours from last feedback popped.
        });

        return q.promise;
    };

    module.popupInsightFeedbackDialog = function (insight) {
        var editInsightScope = $rootScope.$new();

        editInsightScope.sendImprovementDialogSuggest = function (insightData, dont_pop_feedback, feedbackMessage, helpful) {
            if (helpful !== undefined) insight.helpful = helpful;
            if (dont_pop_feedback === true) module.doNotPopFeedback();
            return module.sendImprovementSuggest(insightData.insight.id, helpful, feedbackMessage);
        };
        editInsightScope.insightData = insight;

        ngDialog.open({
            template: 'app/dashboard/insights/insight-feedback/insight-feedback.html',
            controller: 'InsightFeedbackController',
            width: '540px',
            closeByEscape: true,
            closeByDocument: true,
            showClose: false,
            scope: editInsightScope,
        });
        module.feedbackPopped(insight);
    };


    var cachedInsightsSummary = {}; // This is a insights summary cache used for both Cognitive Insights page and header (unread insight notifications)
    module.loadSummary = function () {
        var d = $q.defer();

        if (!AuthService.isAuthenticated()) {
            d.resolve();
            return d.promise;
        }

        Backend.GET('/insights-summary', {}, {dontShowProgressBar: true}).then(function (res) {
            _.forEach(Object.keys(res.data), function (key) {
                // We do it this way instead of cachedInsightsSummary = res.data in order
                // to keep the reference link between the components that use the summary
                cachedInsightsSummary[key] = res.data[key];
            });
            d.resolve();
        });

        return d.promise;
    };
    module.loadSummary();
    $interval(module.loadSummary, 1000 * 60 * 5); // Every 5 minutes

    module.getSummary = function () {
        return cachedInsightsSummary;
    };

    module.getInsightsTags = function () {
        return Backend.GET('/insights-tags').then(function (res) {
            return res.data;
        });
    };

    return module;
});
/* eslint-enable max-lines */
/* origin: public/webapp/services/interval-calculator.js */
angular.module('utils').service('IntervalCalculator', function () {
    var service = {};
    var time = new function () {
        this.second = 1000;
        this.minute = 60 * this.second;
        this.hour = 60 * this.minute;
        this.day = 24 * this.hour;
        this.week = 7 * this.day;
        this.year = 365 * this.day;
    };

    var intervalMin = [
        ['100ms', time.second * 0.5],       // < 0.5s
        ['1s', time.second * 5],            // < 5s
        ['5s', time.second * 7.5],          // < 7.5s
        ['10s', time.second * 15],          // < 15s
        ['30s', time.second * 45],          // < 45s
        ['1m', time.minute * 3],            // < 3m
        ['5m', time.minute * 9],            // < 9m
        ['10m', time.minute * 20],          // < 20m
        ['30m', time.minute * 45],          // < 45m
        ['1h', time.hour * 2],              // < 2h
        ['3h', time.hour * 6],              // < 6h
        ['12h', time.hour * 24],            // < 24h
        ['24h', time.day * 2],              // < 2d
        ['2d', time.week],                  // < 1w
        ['1w', time.week * 3],              // < 3w
        ['30d', time.week * 6],              // < 6w
        ['60d', time.year * 2],              // < 2y
        ['1y', Infinity],                   // OMG
    ];

    function roundInterval(interval) {
        var chosen = '24h';
        _.forEach(intervalMin, function (limit) {
            if (interval < limit[1]) {
                chosen = limit[0];
                return false; // this will break lodash forEach
            }
        });
        return chosen;

    }

    service.calculateInterval = function (from, to, size) {
        size = size || 200;
        return roundInterval((to - from) / size);
    };

    return service;

});

/* origin: public/webapp/services/kibana-filters-service/kibana-filters-service.js */
angular.module('webApp').service('KibanaFiltersService', function () {

    var service = {};

    var filterTypes = ['match_phrase', 'exists', 'bool', 'range', 'query_string'];

    /**
     * return all the relevant filter values
     * @return {Array} filter types list
     */
    service.getFilterTypes = function () {
        return filterTypes;
    };

    /**
     * clean filter from unused parameters
     * @param  {Array} filters - dirty filters list
     * @return {Array} clean filters list
     */
    service.cleanFilter = function (filters) {

        var cleanFilters = [];

        _.forEach(filters, function (filter) {

            //check if this is the default time range filter, if it is ignore it
            var isDefaultRangeFilter = _.has(filter, 'range') && !_.has(filter, '$state');

            if (isDefaultRangeFilter) {
                return;
            }

            cleanFilters.push(_.omit(filter, ['$state']));
        });

        return cleanFilters;
    };

    /**
     * Extract value from filter named 'is one of' in kibana
     * @param  {Object} values - The filter values in the kibana format
     * @param  {string} keyName - The filter key name as been chosen in the kibana
     * @return {Object} parsed filter values
     */
    service.extractValuesFromIsOneOfFilter = function (values, keyName) {

        return _.map(values, function (value) {
            return value.match_phrase[keyName];
        }).join(',');

    };

    /**
     * Extract value from filter named 'is between' in kibana
     * @param  {Object} values - The filter values in the kibana format
     * @return {Object} parsed filter values
     */
    service.extractValuesFromIsBetweenFilter = function (values) {

        var start = _.has(values, 'gte') ? _.get(values, 'gte') : _.get(values, 'gt');
        var end = _.has(values, 'lte') ? _.get(values, 'lte') : _.get(values, 'lt');

        return [start, end].join(' to ');
    };

    /**
     * Gets the filters from 'bool' section in the response from kibana
     * @param  {Array} filters - All the filters from kibana
     * @return {Array} The relevant filters according to the defined filter types
     */
    service.retrieveFiltersFromBoolPart = function (filters) {

        return _.pickBy(filters, function (key) {
            return _.size(_.intersection(filterTypes, _.keys(key))) > 0;
        });
    };

    return service;
});
/* origin: public/webapp/services/kibana-frame-service.js */
angular.module('webApp').service('KibanaFrameService', function ($location, $timeout, $q, appEmbedded, UrlBuilder,
                                                                 CookiesService, cacheService, AccountService, UserService, WaitUntil) {
    var self = this;

    self.refresh = function () {
        var url = self.kibanaIframeUrl;

        if (!url) {
            return;
        }

        self.kibanaIframeUrl = '';
        $timeout(function () {
            self.kibanaIframeUrl = url;
        }, 0);
    };

    self.kibanaIframeUrl = '';
    self.navigate = function (kibanaRoute) {
        // Old share versions injected embed in kibanaRoute, new versions don't do that and inject
        // embed=true before the kibanaRoute, this way we support both ways
        if (appEmbedded && kibanaRoute && kibanaRoute.indexOf('embed') === -1) {
            kibanaRoute = kibanaRoute
                .replace(/auth=[A-z]/g, '')
                .replace(/\?/g, '?embed&');
        }

        var url = new UrlBuilder();
        url.schema = $location.protocol();
        url.host = $location.host();
        url.port = $location.port();
        url.path = '/kibana-app/kibana';

        if (kibanaRoute) {
            url.hash = decodeURIComponent(kibanaRoute);
        }

        var userSession = cacheService.getCached('user-session');
        var auth = _.get(userSession, 'data.sessionToken') || CookiesService.getCookieValue('logz-authToken');
        url.setQueryParam('auth', auth);

        self.kibanaIframeUrl = url.toString();
    };

    /**
     *  ElasticSearch index must be prepared for the account before we can open kibana
     *  so we want to make sure that the index has been initialized and check every 2 seconds that it is ready.
     *  nevertheless, if the promise already resolved, return the resolved promise.
     */
    var waitUntilPromise = new WaitUntil();
    self.waitForAccountInitialLoad = function () {
        // this might be called multiple times until it is being resolved
        // so we want to share the same promise for all, such that no redundant calls are made
        if (waitUntilPromise.isWaiting()) {
            return waitUntilPromise.getPromise();
        }

        return waitUntilPromise
            .stopAfter(30 * 1000)
            .tryEvery(2 * 1000)
            .execute(function () {
                // if share token is presented, we assume account is ready
                var hasShareToken = window.location.href.indexOf('shareToken') !== -1;
                if (hasShareToken) {
                    return $q.resolve(true);
                }

                // first naively check cache if the account is ready
                return UserService.getSummary().then(function (res) {
                    if (res.data.accountState === AccountService.ACCOUNT_CREATION_STATES.READY) {
                        return true;
                    }
                    // then, if not, try get fresh results every 2s to see if there's a status change
                    return UserService.getSummary(true).then(function (res) {
                        return res.data.accountState === AccountService.ACCOUNT_CREATION_STATES.READY;
                    });
                });
            });
    };
});

/* origin: public/webapp/services/kibana-navigator.js */
/* eslint-disable */
angular.module('webApp').service('kibanaNavigator', function ($state, $window, dateService) {

    var service = {};

    service.navigateToDiscover = function (query, from, to, filters, indexPrefix, newTab) {
        var queryStr = query,
            endDateUTC = dateService.formatTimestampUTC(to),
            startDateUTC = dateService.formatTimestampUTC(from);

        var globalState = {
            refreshInterval: {display: 'Off', section: 0, value: 0},
            time: {from: startDateUTC, to: endDateUTC, mode: 'absolute'}
        };

        var appState = {
            columns: ['message'],
            filters: filters ? prepareFilters(filters, indexPrefix) : null, // Not mandatory
            query: {'query_string': {'analyze_wildcard': ['t'], query: queryStr}},
            sort: ['_score', 'desc']
        };

        var kibanaRoute = [ '/discover?_g=', window.rison.encode(globalState), '&_a=', window.rison.encode(appState) ].join('');

        if (newTab) {
            var url = $state.href('dashboard.kibana', {kibanaRoute: kibanaRoute});
            $window.open(url, '_blank');
        } else {
            $state.go('dashboard.kibana', {kibanaRoute: kibanaRoute});
        }
    };

    function prepareFilters(jsonFilter, indexPrefix) {
        var a = JSON.parse(jsonFilter);

        if (!a.bool)
            return null;

        var filters = [];
        //noinspection Eslint
        for (var mu in a.bool) {
            var negate = mu === 'must_not';
            //noinspection Eslint
            _(a.bool[mu]).forEach(function (item) {
                if (item.match_phrase) {
                    var key = Object.keys(item.match_phrase)[0];
                    pushFilters(filters, key, item.match_phrase[key].query, negate, indexPrefix);
                }
            });
        }

        return filters;
    }

    function pushFilters(filters, key, val, negate, indexPrefix) {
        var match = {};
        match[key] = {query: val, type: 'phrase'};
        var innerObj = {
            meta: {
                disabled: false,
                index: '%5B' + indexPrefix + '%5DYYMMDD',
                key: key,
                negate: negate,
                value: val
            },
            query: {
                match: match
            }
        };
        filters.push(innerObj);
    }

    return service;
});
/* eslint-enable */

/* origin: public/webapp/services/kibana-services-provider.js */
angular.module('utils').service('kibanaServicesProvider', ['$window', function($window) {
    return {
        get: function(service) {
            var kibanaFrame = $window.frames[0];
            var injector = kibanaFrame.window.angular.element(kibanaFrame.document.body).injector();
            return injector.get(service);
        }
    };
}]);

/* origin: public/webapp/services/logger.js */
angular.module('webApp').service('Logger', function(Backend, AuthService, UserService) {

    var logzioUsersRegex = new RegExp('@logz\.io');

    return {
        log: function() {
            try {
                var log, _logArguments = arguments;

                if (!AuthService.isAuthenticated()) {
                    if (_logArguments && _logArguments.length > 0 && typeof _logArguments[0] === 'string') {
                        log = {message: _logArguments[0]};
                    }
                    else if (_logArguments && _logArguments.length > 0 && typeof _logArguments[0] === 'object') {
                        log = _logArguments[0];
                    }
                    else {
                        log = _logArguments;
                    }
                    Backend.POST('/logger/log', log);
                    return;
                }

                UserService.getSummary().then(function (res) {
                    // dont send internal use logs - when username contains @logz.io
                    if (logzioUsersRegex.test(_.get(res, 'data.username')))
                        return;
                    delete res.data['accountToken'];
                    if (_logArguments && _logArguments.length > 0 && typeof _logArguments[0] === 'string') {
                        log = {
                            message: _logArguments[0],
                            userSummary: res.data
                        };
                    }
                    else if (_logArguments && _logArguments.length > 0 && typeof _logArguments[0] === 'object') {
                        log = _logArguments[0];
                        log['userSummary'] = res.data;
                    }
                    else {
                        log = _logArguments;
                    }
                    Backend.POST('/logger/log', log);
                });
            }
            catch(ex) {
                console.log('Couldn\'t send log', ex);
            }
        }
    };

});

/* origin: public/webapp/services/logz-config.js */
angular.module('webApp').service('LogzConfig', function($window) {
    var configFromServer = $window.logzConfig;
    return configFromServer;
});

/* origin: public/webapp/services/logz-toast/logz-toast.js */
angular.module('webApp').service('LogzToast', function($mdToast) {
    var self = this;

    // Lazy preset init
    self.getLogzPreset = function (){
        var formPresetToast = $mdToast.formToast();
        self.getDefaultPreset = function (){ return formPresetToast; };
        return formPresetToast;
    };

    self.error = function (message, autoHide){
        var toastOptions = self.getLogzPreset()
            .mode('error')
            .textContent(message);

        if(autoHide === false){
            toastOptions.action('Dismiss')
                        .hideDelay(false);
        }

        return $mdToast.show(toastOptions);
    };

    self.success = function (message){
        var toastOptions = self.getLogzPreset()
            .mode('success')
            .textContent(message);

        return $mdToast.show(toastOptions);
    };
});
/* origin: public/webapp/services/logzio-api.js */
/* eslint-disable max-lines */
/*
 This is the 'kibana api'
 It is for communicating from inside the kibana content frame and our app.
 This service will be exposed as a parameter on the global scope,
 so kibana will be able to access it from within.
 */

// todo: split this into separate domains

angular.module('webApp').service('logzioApi', function ($rootScope, $q, $timeout, $interval, $state, Backend, AccountService, UserService, LabsService, AuthService, ngDialog, AlertWizardService, TriggerWizardService, UpgradeService, FeatureFlagService) {

    /*
     Currently this is a general service with some unrelated methods.
     In the future we will need to split this into separate services,
     and this will just act as a proxy to those separate services.
     */

    var _getUser = function () {
        return AuthService.getUser();
    };

    var _getUsers = function () {
        return AccountService.getUsers();
    };

    var _intercomEvent = function(eventName) {
        if (!Intercom || typeof Intercom !== 'function')
            return $q.when();
        Intercom('trackEvent', eventName);
        console.log('Intercom event : ' + eventName);
        return $q.when();
    };

    var _intercomUpdateCompany = function(details) {
        if (!Intercom || typeof Intercom !== 'function')
            return $q.when();

        var d = $q.defer();
        UserService.getSummary().then(function(res) {
            var userSummary = res.data;
            var company = { id: userSummary.accountId };
            // TODO: we need to send the hash with this
            var updatedCompany = { app_id: 'bkz9ugqv', user_id: userSummary.userId, email: userSummary.username, company: _.assign(company, details) };
            Intercom('update', updatedCompany);
            console.log('Intercom update : ' + angular.toJson(updatedCompany));
            d.resolve();
        });
        return d.promise;
    };

    var _getUserTokens = function() {
        var d = $q.defer();
        Backend.GET('/user-tokens').then(function(tokens) {
            d.resolve(tokens.data);
        });
        return d.promise;
    };

    var _contributeLabsObject = function(object) {
        LabsService.contribute(object);
    };

    var _getSummary = function() {
        return UserService.getSummary();
    };

    var _isAdmin = function() {
        return AuthService.isAdmin();
    };

    var _hideSearchTooltip = function() {
        _getUserSettings().then(function(resp) {
            resp.hideKibanaSearchTooltip = true;
            Backend.POST('/user-settings', resp);
        });
    };

    var _getUserSettings = function() {
        if (!AuthService.isAuthenticated()) {
            return $q.when({});
        }

        return Backend.GET('/user-settings').then(function(res) {
            return res.data;
        });
    };

    var _uninstallLabObject = function(objectId) {
        return Backend.DELETE('/labs/uninstall', { id:objectId });
    };

    var _isErrorDialogOpen = false;
    var GENERIC_ERROR = 'An error occurred, please contact support.';
    var _errorPopup = function (title, body, reloadOnClose) {
        if (_isErrorDialogOpen) {
            return; // An error dialog is already shown to the user
        }

        _isErrorDialogOpen = true;

        ngDialog.open({
            data: {
                title: title || 'Oops',
                body: body || GENERIC_ERROR
            },
            template: 'errors/error-dialog/error-dialog.html',
            width: '500px',
            showClose: false,
            closeByEscape: true,
            preCloseCallback: function () {
                _isErrorDialogOpen = false;

                if (reloadOnClose) {
                    window.location.reload();
                }
            }
        });
    };

    var _formatElasticErrorMessage = function (errObj, fromPrefix) {
        try {
            errObj = typeof errObj === 'object'
                ? errObj
                : JSON.parse(errObj);

            var messageObj = _.get(errObj, 'body.message', errObj.message);
            if (!messageObj) {
                throw new Error('No message object');
            }

            messageObj = typeof messageObj === 'string'
                ? JSON.parse(messageObj.replace('unhandled courier request error: ', '')) // Kibana may add this in fatal error case
                : messageObj;

            if (!messageObj.hasOwnProperty('logzioError')) {
                throw new Error('No logzioError object');
            }

            var logzioError = typeof messageObj.logzioError === 'object'
                ? messageObj.logzioError
                : JSON.parse(messageObj.logzioError);
            logzioError = _.get(logzioError, 'message', logzioError); // May be an object with message or simple string

            return fromPrefix && fromPrefix !== 'Courier Fetch Error' // Kibana may send this as fromPrefix if it wasn't fully load during the error
                ? [ fromPrefix, ': ', logzioError ].join('')
                : logzioError;
        }
        catch (e) {
            return GENERIC_ERROR;
        }
    };

    var _openCreateAlertWizard = function (createAlertData) {
        UpgradeService.getPlanDetails().then(function (planDetails) {
            var maxAlerts = planDetails.data.maxAlertsDefinition;
            if (maxAlerts === 0) {
                UpgradeService.showAlertsNotAvailableForPlanDialog();
                return;
            }

            FeatureFlagService.isFeatureEnabled('continuous-aggregation').then(function (continuousAggregationEnabled) {
                continuousAggregationEnabled ? TriggerWizardService.storeDataAndOpenWizard(createAlertData) : AlertWizardService.storeDataAndOpenWizard(createAlertData);
            });
        });
    };

    return {
        intercomEvent: _intercomEvent,
        intercomUpdateCompany: _intercomUpdateCompany,
        getUserTokens: _getUserTokens,
        contributeLabsObject: _contributeLabsObject,
        getSummary: _getSummary,
        isAdmin: _isAdmin,
        getUserSettings: _getUserSettings,
        hideSearchTooltip: _hideSearchTooltip,
        uninstallLabObject: _uninstallLabObject,
        errorPopup: _errorPopup,
        openCreateAlertWizard: _openCreateAlertWizard,
        getUser: _getUser,
        getUsers: _getUsers,
        formatElasticErrorMessage: _formatElasticErrorMessage
    };
});
/* eslint-enable max-lines */
/* origin: public/webapp/services/logzio-file-saver.js */
angular.module('webApp').service('LogzioFileSaver', function (Blob, FileSaver) {

    return function (name, content, typeOverride) {
        var blob = new Blob([ content ], { type: typeOverride || 'text/plain;charset=utf-8' });
        FileSaver.saveAs(blob, name);
    };
});
/* origin: public/webapp/services/marketo.js */
angular.module('webApp').service('MarketoService', function(AuthService) {

    var marketoCookieKey = 'marketoHash';

    var _getCookie = function(name) {
        var match = document.cookie.match(new RegExp(name + '=([^;]+)'));
        if (match) return match[1];
    };

    var _associateLead = function(data) {

        try {
            var marketoHash = _getCookie(marketoCookieKey);
            if (data.marketoHash) {
                marketoHash = data.marketoHash;
                delete data['marketoHash'];
            }

            if (data.fullName) {
                data.FirstName = data.fullName.split(' ')[0];
                data.LastName = data.fullName.indexOf(' ') > 0 ? data.fullName.substr(data.fullName.indexOf(' ') + 1) : '';
                delete data['fullName'];
            }

            if (!data.Email) {
                AuthService.getUser().then(function (user) {
                    data.Email = user.data.username;
                    data['LogzId__c'] = user.data.accountId;
                    data['LogzID_Text__c'] = user.data.accountId;
                    Munchkin.munchkinFunction('associateLead', data, marketoHash);
                });
                return;
            }

            Munchkin.munchkinFunction('associateLead', data, marketoHash);
        }
        catch (ex) {
            console.log('Error reporting to marketo.');
            // todo: add logging to our server about this.
        }
    };

    return {
        associateLead: _associateLead
    };

});
/* origin: public/webapp/services/notification-endpoint-service.js */
angular.module('webApp').service('NotificationEndpointService', function($q, Backend, cacheService) {

    var service = {};
    var maxEmailsToStore = 15;

    service.saveNotificationEndpoint = function(notificationEndpoint) {
        var saveMode = notificationEndpoint.id ? 'edit' : 'create';
        var url = saveMode === 'create' ? '/account/create-notification-endpoint' : ('/account/update-notification-endpoint');
        var request = {notificationEndpoint: notificationEndpoint};

        return Backend.POST(url, request);
    };

    service.deleteNotificationEndpoint = function(notificationEndpoint) {
        if (notificationEndpoint.id) {
            var url = '/account/delete-notification-endpoint/' + notificationEndpoint.id;
            return Backend.DELETE(url);
        }
        return $q.reject([]);
    };

    service.getAllNotificationEndpoints = function() {
        var url = '/account/notification-endpoints';
        return Backend.GET(url);
    };

    service.getAllNotificationEndpointTemplates = function() {
        var url = '/notification-endpoint-templates';
        return Backend.GET(url);
    };

    service.handleCachedEmailsList = function (emails) {
        emails = emails || [];
        var cachedEmails = cacheService.getPersistent('emails');
        cachedEmails = _.union(emails, cachedEmails);
        if (cachedEmails.length > maxEmailsToStore)
            cachedEmails = _.dropRight(cachedEmails, cachedEmails.length  - maxEmailsToStore);

        cacheService.setPersistent('emails', cachedEmails);

        return $q.when(cachedEmails);
    };

    return service;
});
/* origin: public/webapp/services/plan-pricing.js */
angular.module('webApp').service('PlanPricingService', function($q, Backend, cacheService) {

    var _plans = {
        'standard': 2,
        'pro': 3
    };

    var _getPlanPrices = function() {
        return cacheService.get('planPrices', function() {
            return Backend.GET('/plan-prices').then(function(planPricesResponse) {
                return planPricesResponse.data;
            });
        });
    };

    var _getVolumeSizes = function(planType) {
        return _getPlanPrices().then(function(planPrices) {
            return _.map(_.filter(planPrices, function(plan) {
                return plan.planTypeId === _plans[planType.toLowerCase()];
            }), 'maxDailyUsage').sort(function(a, b) { return a-b; });
        });
    };

    var _getRetentionSizes = function(planType, volSize) {
        return _getPlanPrices().then(function(planPrices) {
            return _.map(_.filter(planPrices, function(plan) {
                return plan.planTypeId === _plans[planType.toLowerCase()] && plan.maxDailyUsage === parseInt(volSize);
            }), 'retention');
        });
    };

    var _getPlanDetails = function(planType, volSize, retention) {
        return _getPlanPrices().then(function(planPrices) {
            return _.find(planPrices, function(plan) {
                return plan.planTypeId === _plans[planType.toLowerCase()] &&
                    parseInt(volSize) === plan.maxDailyUsage &&
                    parseInt(retention) === plan.retention;
            });
        });
    };

    return {
        getVolumeSizes: _getVolumeSizes,
        getRetentionSizes: _getRetentionSizes,
        getPlanDetails: _getPlanDetails
    };

});

/* origin: public/webapp/services/sawmill-endpoint-service.js */
angular.module('webApp').service('sawmillEndpointService', function ($q, Backend) {

    var _saveSawmillType = function (sawmillType, sawmillJSON, sawmillScope, accountID, step, readOnly) {
        var url = '';
        switch (sawmillScope) {
        case 'ADMIN':
            url = 'supported-log-types/' + sawmillType + '/sawmill-config';
            break;
        case 'GLOBAL':
            url = '/__admin__/account/' + accountID + '/sawmill-config/' + step;
            break;
        case 'LOG_TYPE':
            url = '__admin__/account/' + accountID + '/log-types/' + sawmillType + '/sawmill-config?readOnly=' + readOnly;
            break;
        default:
            return;
        }
        return Backend.POST(url, sawmillJSON);
    };

    var _editGlobalSawmillType = function (sawmillConfig, sawmillJSON, accountID, step) {
        var url = '/__admin__/account/' + accountID + '/sawmill-config/' + step + '/' + sawmillConfig.pipelineId;
        return Backend.POST(url, sawmillJSON);
    };

    var _getAllAccountLogTypePipelineConfigs = function (accountID) {
        var url = '/__admin__/account/' + accountID + '/log-types/sawmill-config';
        return Backend.GET(url);
    };

    var _getAllAccountGlobalPipelineConfigs = function (accountID) {
        var baseUrl = '/__admin__/account/' + accountID + '/sawmill-config/';

        var steps = _getAllGlobalSawmillProcessingSteps();
        var stepsPromises = steps.map(function (step) { return Backend.GET(baseUrl + step.key); });

        return $q.all(stepsPromises)
            .then(function (responses) {
                var configs = [];
                for (var i = 0; i < responses.length; i++) {
                    var stepKey = steps[i].key;
                    /* eslint-disable */
                    var stepData = responses[i].data.map(function (config) {
                        config.step = stepKey;
                        return config;
                    });
                    /* eslint-enable */

                    configs = configs.concat(stepData);
                }

                return { data: configs };
            });
    };

    var _getAllGlobalSawmillProcessingSteps = function () {
        return [
            { key: 'PRE_PROCESSING', name: 'Pre Processing' },
            { key: 'GENERAL_PROCESSING', name: 'General Processing' },
            { key: 'POST_PROCESSING', name: 'Post Processing' }
        ];
    };

    var _getAllSawmillSupportedLogTypes = function () {
        return Backend.GET('/supported-log-types');
    };

    var _getAllSawmillConfigs = function () {
        return Backend.GET('/supported-log-types/sawmill-config');
    };

    var _getAllSawmillByScope = function (sawmillScope, accountID) {
        switch (sawmillScope) {
        case 'ADMIN':
            return _getAllSawmillConfigs();
        case 'GLOBAL':
            return _getAllAccountGlobalPipelineConfigs(accountID);
        case 'LOG_TYPE':
            return _getAllAccountLogTypePipelineConfigs(accountID);
        }
    };

    var _deleteSawmillConfig = function (sawmillConfig, sawmillScope, accountId) {
        var url = '';
        switch (sawmillScope) {
        case 'ADMIN':
            url = 'supported-log-types/' + sawmillConfig + '/sawmill-config';
            break;
        case 'GLOBAL':
            url = '/__admin__/account/' + accountId + '/sawmill-config/' + sawmillConfig.step + '/' + sawmillConfig.pipelineId;
            break;
        case 'LOG_TYPE':
            url = '/__admin__/account/' + accountId + '/log-types/' + sawmillConfig.logType + '/sawmill-config';
            break;
        default:
            return;
        }
        return Backend.DELETE(url);
    };

    var _updateSawmillGlobalConfigOrder = function (stepsData, accountId) {
        var requests = [];

        _.forEach(Object.keys(stepsData), function (stepName) {
            requests.push(Backend.PUT([ '/__admin__/account/', accountId, '/sawmill-config/', stepName ].join(''), stepsData[stepName]));
        });

        return $q.all(requests);
    };

    return {
        getAllSawmillConfigs: _getAllSawmillConfigs,
        getAllSawmillSupportedLogTypes: _getAllSawmillSupportedLogTypes,
        getAllAccountGlobalPipelineConfigs: _getAllAccountGlobalPipelineConfigs,
        getAllAccountLogTypePipelineConfigs: _getAllAccountLogTypePipelineConfigs,
        getAllSawmillByScope: _getAllSawmillByScope,
        saveSawmillType: _saveSawmillType,
        editGlobalSawmillType: _editGlobalSawmillType,
        getAllGlobalSawmillProcessingSteps: _getAllGlobalSawmillProcessingSteps,
        deleteSawmillConfig: _deleteSawmillConfig,
        updateSawmillGlobalConfigOrder: _updateSawmillGlobalConfigOrder
    };

});
/* origin: public/webapp/services/searchable-indexes-service.js */
angular.module('webApp').service('SearchableIndexesService', function ($q, Backend, cacheService, sharedObjects) {

    var MAIN_ACCOUNT_TYPE = 'OWNER_ACCOUNT';

    var service = function () { };

    var endpoint = '/searchable-accounts';

    var getFreshSearchableIndexes = function () {
        return Backend.GET(endpoint).then(function (res) {
            return res.data;
        });
    };

    service.prototype.getCachedSearchableIndexes = function() {
        return cacheService.get(endpoint, getFreshSearchableIndexes, 300);    // cache for 5 min
    };


    service.prototype.getSearchableIndexByDocId = function(docId) {
        var accountId = sharedObjects.parseAccountId(docId);
        if (!accountId) {
            return $q.when(null);
        }

        return this.getCachedSearchableIndexes()
            .then(function (searchableIndexes) {
                var matchedAccounts = searchableIndexes.filter(function (searchableIndex) { return searchableIndex.accountId === accountId && searchableIndex.type !== MAIN_ACCOUNT_TYPE; });//filter tags to not be shown on main account
                if (matchedAccounts.length) {
                    return matchedAccounts[0];
                }

                return null;
            });
    };


    return new service();
});
/* origin: public/webapp/services/session-service.js */
/**
 * Created by alonmiz on 28/11/2017.
 */
angular.module('webApp').service('SessionService', function () {
    var sessionIdKey = '__logz.sessionId__';

    this.getSessionId = function () {
        var currentSessionId = window.sessionStorage.getItem(sessionIdKey);
        if (currentSessionId !== null)
            return currentSessionId;

        // generate random string
        var options = 'abcdefghijklmnopqrstuvwxyz0987654321';
        var newSessionId = '..........'.split('')
            .map(function () {
                return options.charAt(Math.floor(Math.random() * (options.length)));
            })
            .join('');

        window.sessionStorage.setItem(sessionIdKey, newSessionId);
        return newSessionId;
    };
});
/* origin: public/webapp/services/shared-objects-service.js */
angular.module('webApp').factory('sharedObjects', function (cacheService, Backend, $q) {

    var service = {};
    var sharedObjectIdRegex = /\.account-(\d+)$/;
    var endpoint = '/account/shared-objects';

    service.getSharingAccounts = function () {
        return cacheService.get(endpoint, function () {
            return Backend.GET(endpoint).then(function (response) {
                return response.data;
            });
        }, 60 * 5);
    };

    service.clearCache = function () {
        cacheService.clear(endpoint);
    };

    service.getAccountByObjectId = function (objId) {
        var accountId = this.parseAccountId(objId);
        if (!accountId)
            return $q.when(null);

        return this.getSharingAccounts().then(function (accounts) {
            return accounts.filter(function (a) {
                return a.accountId === accountId;
            })[0];
        });
    };

    service.parseAccountId = function(objId) {
        var matches = sharedObjectIdRegex.exec(objId);
        if (matches && matches.length > 1)
            return parseInt(matches[1]);

        return null;
    };

    service.hasAccountId = function(objId) {
        return !!this.parseAccountId(objId);
    };

    return service;
});

/* origin: public/webapp/services/snapshotter/snapshot-service.js */
angular.module('webApp').service('SnapshotService', function ($q, $rootScope, ngDialog, Backend, NotificationEndpointService, UserService) {
    var service = {};

    service.share = function (shareData) {
        return Backend.POST('/snapshotter', shareData);
    };

    service.getSlackAlertNotificationEndpoints = function () {
        return NotificationEndpointService.getAllNotificationEndpoints().then(function (res) {
            var slackEndpoints = _.filter(res.data, {templateName: 'Slack'});
            return _.map(slackEndpoints, function (endpoint, index) {
                return {data: endpoint, name: endpoint.title, id: index};
            });
        });
    };

    service.getDefault = function () {
        return Backend.GET('/snapshotter/default').then(function (res) {
            return $q.when(res.data);
        }).catch(function () {
            return {
                message: '',
                recipients: []
            };
        });
    };

    service.saveAsDefault = function (recipients, message) {
        return Backend.POST('/snapshotter/default', {
            recipients: recipients,
            message: message
        });
    };

    service.handleCachedEmailsList = function (emails) {
        return NotificationEndpointService.handleCachedEmailsList(emails);
    };

    service.addNewEndpoint = function (endpoints, selectedRecipients) {
        var dialogScope = $rootScope.$new();
        dialogScope.notificationEndpoints = [];
        dialogScope.forceTemplateTypesToShow = ['Slack'];

        ngDialog.open({
            template: 'directives/alert-webhooks/upsert-notification-endpoint.html',
            controller: 'UpsertNotificationEndpointController',
            width: '765px',
            scope: dialogScope,
            showClose: false,
            preCloseCallback: function () {
                if (dialogScope.notificationEndpoints.length && dialogScope.notificationEndpoints[0].templateName === 'Slack') {
                    var newEndpoint = {
                        data: dialogScope.notificationEndpoints[0],
                        id: endpoints.length,
                        group: 0,
                        name: dialogScope.notificationEndpoints[0].title
                    };
                    endpoints.push(newEndpoint);
                    selectedRecipients.push(newEndpoint);
                }
            }
        });
    };

    service.isUsingDarkTheme = function () {
        return UserService.getUserSettings().then(function (userSettings) {
            return userSettings.kibanaTheme === 1;
        }).catch(function () {
            return false;
        });
    };

    return service;
});
/* origin: public/webapp/services/trigger-wizard/trigger-service.js */
angular.module('webApp').service('TriggerWizardService', function ($state, $q, localStorageService, AnalyticsService, UserService, Backend, UpgradeService, TimelessAccountsService, ngDialog) {

    var service = {};
    var _key = '__alertWizardData'; //local storage key
    
    var DIALOG_WIDTH = '624px';
    var CONFIRM_AGG_DIALOG_TEMPLATE = 'app/dashboard/alerts/alert-wizard/trigger-dialogs/confirm-aggregation-dialog.html';
    var TRIGGER_SAVED_DIALOG_TEMPLATE = 'app/dashboard/alerts/alert-wizard/trigger-dialogs/trigger-saved-dialog.html';

    service.getData = function () {
        return localStorageService.get(_key);
    };

    service.clearData = function () {
        localStorageService.remove(_key);
    };

    service.getTriggerDataById = function (triggerId, triggerType) {
        return Backend.GET('/triggers/'+ triggerType + triggerId);
    };

    service.getTimelessIndicesAndTypes = function(){

        return TimelessAccountsService.getAllSearchableAccounts().then(function(res){
            var timelessIndices = [];
            var timelessIndicesTypesMap;

            _.forEach(res.data, function(value){
                timelessIndices.push({text: value.name, value: value.accountId, type: value.name});
            });

            timelessIndicesTypesMap = _.zipObject(_.map(timelessIndices, 'value'), _.map(timelessIndices, 'type'));

            return [timelessIndices, timelessIndicesTypesMap];
        });
    };

    service.report = function (eventName, eventData) {
        eventData = eventData || {};
        eventData = _.assign(eventData, {
            category: 'triggers',
            triggerData: service.getData(),
        });
        eventName = ['triggers', eventName].join(':');
        AnalyticsService.report(eventName, eventData);
    };

    service.storeData = function (data) {
        localStorageService.set(_key, data);
    };

    service.storeDataAndOpenWizard = function (data, triggerType) {
        data.senderState = $state.current.name; // In case the user will cancel operation he will be redirected to the previous state
        data.triggerType = triggerType || 'ALERT';
        service.storeData(data);
        $state.go('dashboard.alerts.triggers');
    };

    service.parseMinutesToTimeUnitAndAmount = function(minutes, unit, amount){

        if(Math.floor(minutes / 1440)){
            unit.value = 'day';
            amount.value = minutes / 1440;
        }
        else if(Math.floor(minutes / 60)){
            unit.value = 'hour';
            amount.value = minutes / 60;
        }
        else{
            unit.value = 'minute';
            amount.value = minutes;
        }
    };

    service.setNotificationEndpointsAndEmails = function (recipientsData) {

        var endpoints = _.partition(recipientsData, function(recipient) { return !!recipient.data; })[0];
        var emails = _.partition(recipientsData, function(recipient) { return !!recipient.data; })[1];

        emails = _.map(emails, function(email){
            return {'address': email.name, 'type': 'EMAIL'};
        });
        endpoints = _.map(endpoints, 'data');

        return [endpoints, emails];
    };

    service.getGroupByFieldsList = function (aggGroupByFields) {
        var fieldList = [];

        _.forEach(aggGroupByFields, function (value) {
            if (value.value) fieldList.push(value.value);
        });
        return fieldList;
    };

    service.openTriggerSavedDialog = function(triggerData, isOptimizer){
        ngDialog.open({
            template: TRIGGER_SAVED_DIALOG_TEMPLATE,
            width: DIALOG_WIDTH,
            showClose: false,
            // we use data and not scope because this dialog is shown after a state change, and the parent scope is destroyed
            data: {
                triggerTypeName: isOptimizer ? 'Optimizer' : 'Alert',
                actionSuccessName: _.get(triggerData, 'id') ? 'updated' : 'created',
                triggerName: triggerData.name
            }
        });
    };

    service.openConfirmAggregationDialog = function(shouldDisplayDialog){
        if(!shouldDisplayDialog){
            return $q.resolve();
        }
        return ngDialog.openConfirm({
            template: CONFIRM_AGG_DIALOG_TEMPLATE,
            width: DIALOG_WIDTH,
            showClose: false
        });
    };

    function changeStateAccordingToTriggerType(triggerType){
        triggerType === 'ALERT' ? $state.go('dashboard.alerts.definitions') : $state.go('dashboard.alerts.continuous');
    }

    function setNullValuesOnNotRelevantValuesForSpesificTriggerType(triggerType, copyTriggerData){
        if(triggerType === 'ALERT') {
            copyTriggerData.output.target.timelessIndex = null;
            copyTriggerData.search.metricsAggregations = null;
        }
        else{
            copyTriggerData.search.periodInMinutes = null;
            copyTriggerData.triggerOn.aggregation = null;
            copyTriggerData.triggerOn.comparisonOperator = null;
            copyTriggerData.triggerOn.threshold = null;
            copyTriggerData.output.target.severity = null;
        }
    }

    service.isAggMode = function(triggerData){
        return _.size(triggerData.search.groupBy) > 0 || !!triggerData.triggerOn.aggregation.fieldToAggregateOn;
    };

    function handleTriggerAggregation(copyTriggerData) {

        if(_.size(copyTriggerData.search.groupBy) && copyTriggerData.triggerOn.aggregation.aggregationType === 'NONE'){
            copyTriggerData.triggerOn.aggregation.aggregationType = 'COUNT';
        }

        var aggType = copyTriggerData.search.metricsAggregations[0].aggregationType;
        var groupByCount = _.size(copyTriggerData.search.groupBy);
        if(!groupByCount && aggType === 'NULL'){
            copyTriggerData.search.metricsAggregations = [];
        }
    }

    service.adjustTriggerDataObjectForServer = function (triggerData, triggerType) {//adjusting data because of legacy code in server :/

        var copyTriggerData = _.cloneDeep(triggerData);

        copyTriggerData.search.filter = angular.toJson(triggerData.search.filter);
        copyTriggerData.output.format.fieldsConfig = angular.toJson(triggerData.output.format.fieldsConfig);
        copyTriggerData.output.target.emailNotifications = angular.toJson(triggerData.output.target.emailNotifications);

        var aggMode = service.isAggMode(triggerData);
        if(triggerData.output.format.type === 'JSON' || !_.size(triggerData.output.format.fieldsConfig) || aggMode) {
            copyTriggerData.output.format.fieldsConfig = null;
        }

        handleTriggerAggregation(copyTriggerData);
        setNullValuesOnNotRelevantValuesForSpesificTriggerType(triggerType, copyTriggerData);

        return copyTriggerData;
    };

    service.getTableSamples = function (triggerData) {

        if(triggerData.name === '') {
            triggerData = _.omit(triggerData, 'name');
        }

        return Backend.POST('/triggers/alerts/samples', this.adjustTriggerDataObjectForServer(triggerData, 'ALERT')).then(function (res) {
            service.report('preview-table');
            return res;
        });
    };

    service.submitTrigger = function (triggerData, triggerType) {
        var triggerPostType = '/triggers', triggerTypeToReport = 'continuous-aggregation';

        if (triggerType === 'ALERT') {
            triggerPostType = '/triggers/alerts';
            triggerTypeToReport = 'alert';
        }

        if(_.get(triggerData, 'id')){//if there's id then its update and not create
            triggerPostType += '/'+_.get(triggerData, 'id');

            return Backend.PUT(triggerPostType, this.adjustTriggerDataObjectForServer(triggerData, triggerType)).then(function (res) {
                if (_.get(res.data, 'enabled') === false) { // May be undefined, that's why I compare it to false instead of doing if(!...)
                    UpgradeService.showAlertDisabledDialog(true, false);
                }
                service.storeData(triggerData);
                changeStateAccordingToTriggerType(triggerType);
                service.report('update-' + triggerTypeToReport);
            });
        }
        else{//create
            return Backend.POST(triggerPostType, this.adjustTriggerDataObjectForServer(triggerData, triggerType)).then(function (res) {
                if (_.get(res.data, 'enabled') === false) {
                    UpgradeService.showAlertDisabledDialog(true, 'create');
                }
                service.storeData(triggerData);
                changeStateAccordingToTriggerType(triggerType);
                service.report('create-' + triggerTypeToReport);
            });
        }
    };

    return service;
});
/* origin: public/webapp/services/upgrade-service/upgrade-service.js */
angular.module('webApp').service('UpgradeService', function($rootScope, ngDialog, Backend, cacheService) {

    var planTypes = {
        free: 'FREE',
        trial: 'TRIAL',
        standard: 'STANDARD',
        pro: 'PRO',
        enterprise: 'ENTERPRISE'
    };

    var getPlanDetails = function() {
        return cacheService.get('plan-details', function() { return Backend.GET('/plan-details'); });
    };

    var getRetentionDays = function () {
        return getPlanDetails().then(function (planDetails) {
            return planDetails.data.retentionDays;
        });
    };

    $rootScope.$on('plan-details-updated', function() {
        cacheService.clear('plan-details');
    });

    var isAlertDialogOpen = false;
    var showAlertsNotAvailableForPlanDialog = function () {
        if (isAlertDialogOpen) {
            return;
        }

        isAlertDialogOpen = true;
        ngDialog.open({
            template: 'services/upgrade-service/alerts/alerts-not-available-for-plan.html',
            width: '662px',
            closeByEscape: true,
            showClose: false,
            preCloseCallback: function () {
                isAlertDialogOpen = false;
            }
        });
    };

    var showAlertDisabledDialog = function (afterAlertWizard, dueToAlertCreation) {
        if (isAlertDialogOpen) {
            return;
        }

        var dialogScope = $rootScope.$new();
        dialogScope.afterAlertWizard = afterAlertWizard;
        dialogScope.dueToAlertCreation = dueToAlertCreation;

        isAlertDialogOpen = true;
        ngDialog.open({
            template: 'services/upgrade-service/alerts/alert-disabled.html',
            width: '583px',
            closeByEscape: true,
            showClose: false,
            scope: dialogScope,
            preCloseCallback: function () {
                isAlertDialogOpen = false;
            }
        });
    };

    var usersDialog = function() {
        getPlanDetails().then(function(planDetails) {
            ngDialog.open({
                template: 'services/upgrade-service/users-upgrade.html',
                controller: ['$scope', '$state', function($scope, $state) {
                    $scope.usersLimit = planDetails.data.maxUsersCount;
                    $scope.upgradeNow = function() {
                        $scope.closeThisDialog();
                        $state.go('dashboard.settings.usage-and-billing');
                    };
                }],
                width: '600px',
                closeByEscape: true,
                showClose: false
            });
        });
    };

    var s3archiveDialog = function() {
        ngDialog.open({
            template: 'services/upgrade-service/s3archive-upgrade.html',
            controller: ['$scope', '$state', function($scope, $state) {
                $scope.upgradeNow = function() {
                    $scope.closeThisDialog();
                    $state.go('dashboard.settings.usage-and-billing');
                };
            }],
            width: '600px',
            closeByEscape: true,
            showClose: false
        });
    };

    return {
        getPlanDetails: getPlanDetails,
        showAlertsNotAvailableForPlanDialog: showAlertsNotAvailableForPlanDialog,
        showAlertDisabledDialog: showAlertDisabledDialog,
        usersDialog: usersDialog,
        s3archiveDialog: s3archiveDialog,
        planTypes: planTypes,
        getRetentionDays: getRetentionDays
    };

});
/* origin: public/webapp/services/url-builder.js */
angular.module('webApp').service('UrlBuilder', function ($location) {

    var regex = /^(?!$)(?:(?:([A-z0-9]+?):(?=\/\/))?(?:\/\/)?([^:\/?]+)(?::(\d+))?)?(\/.*?(?=$|\?|#))?(?:(?!^)\?([^#]+))?(?:#(.+))?$/;

    var tryDecodeURIComponent = function (part) {
        try {
            return decodeURIComponent(part);
        }
        catch (e) {
            return part;
        }
    };

    var urlBuilder = function (url) {
        var self = this;
        url = url === undefined ? $location.href : url;

        var matches = regex.exec(url);
        self.schema = matches[1];
        self.host = matches[2];
        self.port = matches[3];
        self.path = matches[4];

        var query = matches[5] || '';
        self.queryParams = query
            .split('&')
            .map(function (x) {
                var parts = x.split('=');
                return {key: tryDecodeURIComponent(parts[0]), value: tryDecodeURIComponent(parts[1])};
            })
            .filter(function (x) { return x.key !== ''; });

        self.hash = (matches[6] || '').replace(/%23/g, '#');
    };

    urlBuilder.prototype.setQueryParam = function (key, value) {
        var self = this;
        var existing = self.queryParams.filter(function (x) {
            return x.key === key;
        });
        if (existing.length > 0) {
            existing[0].value = value;
            return self;
        }

        self.queryParams.push({key: key, value: value});
        return self;
    };

    urlBuilder.prototype.removeQueryParam = function (key) {
        var self = this;
        self.queryParams = self.queryParams.filter(function (x) {
            return x.key !== key;
        });
        return self;
    };

    urlBuilder.prototype.getQueryParam = function (key) {
        var self = this;
        var existing = self.queryParams.filter(function (x) {
            return x.key === key;
        });
        if (existing.length > 0) {
            return existing[0].value;
        }

        return undefined;
    };

    urlBuilder.prototype.toString = function () {
        var self = this;
        var str = '';
        if (self.schema)
            str = self.schema + '://';

        if (self.host)
            str += self.host;

        if (self.port)
            str += ':' + self.port;

        if (self.path)
            str += self.path;

        if (self.queryParams.length > 0) {
            str += '?';
            self.queryParams.forEach(function (x, i) {
                str += encodeURIComponent(x.key) + '=' + encodeURIComponent(x.value);
                if (i < self.queryParams.length - 1)
                    str += '&';
            });
        }

        if (self.hash) {
            str += '#' + self.hash.replace(/#/g, '%23');
        }

        return str;
    };

    return urlBuilder;
});
/* origin: public/webapp/services/user-permissions-service.js */
angular.module('webApp').service('UserPermissionsService', function ($q, $location, AuthService, Backend, cacheService) {

    var service = {
        cacheKey: 'user-permissions',
        permissions: {
            FORCE_IMPERSONATION: 'FORCE_IMPERSONATION'
        }
    };

    var getData = function () {
        if (!$location.search().shareToken && !AuthService.isAuthenticated())
            return $q.when();

        return cacheService.get(service.cacheKey, function () {
            return Backend.GET('/permissions');
        }, 60 * 60 * 24);
    };

    service.clearCacheAndLoadData = function () {
        cacheService.clear(service.cacheKey);
        return getData();
    };

    service.hasPermission = function (permissionName) {
        return getData().then(function (res) {
            return res.data.indexOf(permissionName) >= 0;
        });
    };

    return service;
});

/* origin: public/webapp/services/user-tokens-service.js */
angular.module('webApp').service('UserTokensService', function($q, cacheService, Backend) {

    var self = this;

    this.getQueryFilters = function() {
        return cacheService.get('query-filters', function() {
            return Backend.GET('/account/query-filters').then(function(res) {
                return res.data;
            });
        });
    };

    var getTokenFilterRelations = function() {
        return Backend.GET('/user-token-query-filters').then(function(res) {
            return res.data;
        });
    };

    this.getIndexPrefix = function() {
        var cacheValue = cacheService.getCached('user-summary');

        if (!cacheValue)
            throw new Error('logzCache.user-summary not present in cache');

        var indexPrefix = cacheValue.data.accountEsIndexPrefix;
        if (!indexPrefix)
            throw new Error('Failed to get Index Prefix from user-summary in SessionStorage');

        return indexPrefix;
    };

    this.getUserTokens = function() {
        return cacheService.get('user-tokens', function() {
            return Backend.GET('/user-tokens').then(function(res) {

                var userTokens = res.data;

                return $q.all([self.getQueryFilters(), getTokenFilterRelations()]).then(function(responses) {
                    var queryFilters = responses[0];
                    var tokenFilterRelations = responses[1];

                    if (!tokenFilterRelations || !tokenFilterRelations.length)
                        return userTokens;

                    userTokens.forEach(function(userToken) {
                        var foundRelations = _.filter(tokenFilterRelations, function(relation) { return relation.userTokenId === userToken.id; });
                        userToken.filters = userToken.filters || [];
                        if (foundRelations && foundRelations.length) {
                            foundRelations.forEach(function(relation) {
                                userToken.filters.push(_.find(queryFilters, function(filter) { return filter.id === relation.filterId; }));
                            });
                        }
                    });

                    return userTokens;
                });
            });
        });
    };

    this.clearCache = function() {
        cacheService.clear('user-tokens');
        cacheService.clear('query-filters');
    };

});
/* origin: public/webapp/services/user.js */
angular.module('webApp').service('UserService', function($q, $state, localStorageService, Backend, appEmbedded, AuthService, cacheService) {

    var self = this;

    var userSettingsCacheKey = '__userSettings';
    this.cacheKey = 'user-summary';


    self.getSummary = function(getFresh) {
        if (getFresh === true) {
            self.clearCache();
        }

        return cacheService.get(self.cacheKey, function() {
            return Backend.GET('/summary');
        }, 600).then(function (summary) {
            if (summary.data && summary.data.accountEsIndexPrefix) {
                window.es = window.customerIndexPrefix = summary.data.accountEsIndexPrefix;
            }
            return summary;
        });
    };

    self.clearCache = function() {
        cacheService.clear(self.cacheKey);
    };

    self.getUsage = function() {
        return Backend.GET('/usage').then(function(resp) {
            return resp.data.usage || [];
        });
    };

    self.getUsageByType = function() {
        return Backend.GET('/usage-by-type').then(function(resp) {
            return resp.data.usageByType;
        });
    };

    self.updateUser = function(username, accountId, suspend) {
        var postUrl = suspend ? '/__admin__/block-user' : '/__admin__/unblock-user';
        Backend.POST(postUrl, {
            username: username,
            accountId: accountId
        });
    };

    self.getUserSettings = function() {
        if (appEmbedded)
            return $q.when();

        var q = $q.defer();

        var settings = localStorageService.get(userSettingsCacheKey);
        if (settings) {
            q.resolve(settings);
            return q.promise;
        }

        Backend.GET('/user-settings').then(function(settings) {
            localStorageService.set(userSettingsCacheKey, settings.data);
            q.resolve(settings.data);
        });

        return q.promise;
    };

    self.cleanUserSettings = function() {
        localStorageService.set(userSettingsCacheKey, null);
    };

    return self;
});
/* origin: public/webapp/services/window-focus-service.js */
angular.module('webApp').factory('windowFocus', function($window) {
    var service = {
        isFocused: $window.document.hasFocus()
    };
    $window.onfocus = function () {
        service.isFocused = true;
    };
    $window.onblur = function () {
        service.isFocused = false;
    };
    return service;
});
/* origin: public/webapp/utils.js */
Array.prototype.contains = function(v) {
    return this.indexOf(v) > -1;
};

if (!String.prototype.trim) {
    String.prototype.trim = function () {
        return this.replace(/^\s+|\s+$/g, '');
    };
}

window.LogzIO = window.LogzIO || {};
window.LogzIO.Strings = {
    FriendlyNumber: function(number, digitsAfterDecimal) {
        digitsAfterDecimal = digitsAfterDecimal || 2;

        if (number === null || number === undefined || isNaN(number))
            return 0..toFixed(digitsAfterDecimal);
        if (number === 0)
            return 0..toFixed(digitsAfterDecimal);

        var numberParts = number.toString().split('.');
        numberParts[0] = numberParts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');

        if (numberParts.length === 1)
            numberParts.push('0');

        if (numberParts[1].length > digitsAfterDecimal)
            return numberParts[0] + '.' + numberParts[1].substring(0, 2);

        for (var i=numberParts[1].length; i<digitsAfterDecimal; i++) {
            numberParts[1] += '0';
        }
        return numberParts[0] + '.' + numberParts[1];
    },
    HumanReadableNumber: function(num) {
        if (num < 1000) return num;
        var s = ['', 'k', 'M', 'G', 'T', 'P', 'E'];
        var e = Math.floor(Math.log(num) / Math.log(1000));
        var a = parseFloat((num / Math.pow(1000, e)).toFixed(1));
        if (Math.round(a) === a)
            return Math.round(a) + '' + s[e];
        return a + '' + s[e];
    },
    FriendlyPrice: function(num) {
        var numberParts = num.toString().split('.');
        numberParts[0] = numberParts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        if (numberParts.length > 1)
            return numberParts[0] + '.' + (parseInt(numberParts[1]) > 10 ? numberParts[1].toString().substring(0, 2) : numberParts[1] + '0');
        return numberParts[0];
    },
    SlugifyId: function(id) {

        // This method converts a kibana object title, to an elasticsearch id
        // I copied this from the method that kibana uses, so I know it's the same logic.
        // The original file is in '/kibana/utils/_slugify_id.js'

        if (id === null) return;

        var trans = {
            '/' : '-slash-',
            '\\?' : '-questionmark-',
            '\\&' : '-ampersand-',
            '=' : '-equal-'
        };
        _.each(trans, function(val, key) {
            var regex = new RegExp(key, 'g');
            id = id.replace(regex, val);
        });
        id = id.replace(/[\s]+/g, '-');
        id = id.replace(/[\-]+/g, '-');
        return id;
    }
};

window.LogzIO.Dates = {
    /**
     * Converts a unix timestamp to a friendly date that looks like this : dd/MM/yyyy
     */
    unixToFriendly: function(time) {
        time = new Date(time);
        var month = time.getMonth() + 1;
        return time.getDate() + '/' + (month <= 9 ? '0' + month : month) + '/' + time.getFullYear();
    },
    /**
     * This method receives a number of days to add (or subtract if it's negative)
     * and it adds it to the current date.
     */
    addDays: function(numDays) {
        var d = new Date(Date.now());
        d.setDate(d.getDate() + numDays);
        return d;
    }
};

window.LogzIO.formatBytes = function (bytes, decimals) {
    if (bytes === 0) return '0 Bytes';
    var k = 1024,
        dm = decimals || 2,
        sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
        i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};
